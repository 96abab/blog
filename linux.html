<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>리눅스 명령어 정리</title>
    <link rel="stylesheet" href="stylesheet.css">
    <link rel="icon" href="https://96abab.github.io/test.io/ducklogo.png">
    
</head>
<body>
<div id="container">
<header>
  <h2>리눅스 명령어 정리</h2>
  <nav>
    <ul id="topMenu">
      <li><a href="https://96abab.github.io/test.io">home</a></li>
      <li><a href="#">menu1</a></li>
      <li><a href="#">menu2</a></li>
    </ul>
  </nav>
</header>
</div>
<aside>
<ul id="sidebar">
  <li><a href="index.html">Home</a></li>
  <br>
  <li><a href="assignment.html">과제</a></li>
  <br>
  <li><a href="tictactoe.html">TICTACTOE</a></li>
  <br>
  <li><a href="cloudOS.html">1.CloudOS(리눅스서버설치)</a></li>
  <br>
  <li><a href="linux.html">2.리눅스 명령어 정리</a></li>
  <br>
  <li><a href="HTML5.html">3.HTML수업</a></li>
  <br>
  <li><a href="CSS.html">4.CSS수업</a></li>
  <br>
  <li><a href="JAVAscript.html">5.JAVAscript</a></li>
  <br>
  <li><a href="JAVA.html">6.JAVA</a></li>
</ul>
</aside>
<main class="contents">
  <section id="headling">

        <li>파일 시스템 탐색 기본 명령어
      <br></li>
      </ol>
      
      <p><br></p>
      
      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ pwd   : 작업 디렉토리 위치를 확인한다
      
          /home/vagrant/git
      </code></pre></div></div>
      
      <p><br>
      <br></p>
      
      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cd  (디렉토리명) : 현재 작업하는 디렉토리의 위치를 이동 시킨다 
      
          [vagrant@host1 git]$ cd bitcamp-ncp
      
          [vagrant@host1 bitcamp-ncp]$
      </code></pre></div></div>
      
      <p><br>
      <br></p>
      
      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ls  : 현재 위치한 디렉토리에 있는 디렉토리와 파일들의 리스트를 출력한다
      
          b.txt    x.txt    README.md 
      </code></pre></div></div>
      
      <p><br>
      <br></p>
      
      <p>$ file (파일명):  지정한 파일의 타입을 확인한다</p>
      
      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    [vagrant@host1 bitcamp-ncp]$ file README.md
      
          README.md: ASCII text, with no line terminators
      </code></pre></div></div>
      
      <p>$ less  (파일명): 텍스트형식의 파일의 내용을 1페이지씩 보여준다 pageup과 pagedown으로 이동가능하고 화살표 커맨드와 스페이스바로도 이동이 가능하다 그리고 q를 누르면 출력모드가 종료된다</p>
      
      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    1111
      
          2222
      
          3333
      
          4444
      
          5555
      
          6666
      
          b.txt (END)
      </code></pre></div></div>
      
      <ol>
        <li>파일과 디렉토리 조작 명령어</li>
      </ol>
      
      <p>$ cp (복사할파일) (붙여넣을 파일) : 지정파일 내용을 붙여넣을 파일에 복사하여 넣는다 만약 붙여넣을 파일이 없다면 생성하여 붙여넣는다</p>
      
      <p><br></p>
      
      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[vagrant@host1 bitcamp-ncp]$ cp b.txt bb.txt &lt;- 해당 파일이 없을경우 만들어서 붙여넣는다 (파일생성가능)
      </code></pre></div></div>
      
      <p><br>
      <br></p>
      
      <p>$ mv (파일의 현재 경로/파일 이름)(이동시킬 경로) : 파일의 경로를 이동시킬때 사용한다  *주의점 : pwd등을 이용하여 home/경로부터 지정해줘야 이동한다</p>
      
      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    [vagrant@host1 bitcamp-ncp]$ ls
      
          bb.txt  b.txt
      
          [vagrant@host1 bitcamp-ncp]$ mv b.txt /home/vagrant/git/bitcamp-ncp/xxx
      
          [vagrant@host1 bitcamp-ncp]$ ls
      
          bb.txt
      
          [vagrant@host1 bitcamp-ncp]$ cd xxx
      
          [vagrant@host1 xxx]$ ls
      
          b.txt
      </code></pre></div></div>
      
      <p><br>
      <br></p>
      
      <p>$ mkdir (디렉토리명):  디렉토리를 생성한다</p>
      
      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    [vagrant@host1 xxx]$ ls
      
          b.txt
      
          [vagrant@host1 xxx]$ mkdir ccc
      
          [vagrant@host1 xxx]$ ls
      
          b.txt  ccc
      </code></pre></div></div>
      
      <p><br>
      <br></p>
      
      <ol>
        <li>명령어를 다루는 명령어</li>
      </ol>
      
      <p><br></p>
      
      <p>$type : 지정한 리눅스 명령어를 내장된 명령어 외부명령어인지 확인해준다</p>
      
      <p>[vagrant@host1 xxx]$ type ls</p>
      
      <p>ls is aliased to `ls –color=auto’</p>
      
      <p>$which : 명령어 위치를 찾는다</p>
      
      <p>[vagrant@host1 xxx]$ which ls</p>
      
      <p>alias ls=’ls –color=auto’</p>
      
      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    /usr/bin/ls
      </code></pre></div></div>
      
      <p>$ man (명령어): 설명페이지를 볼 수 있다</p>
      
      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LS(1)                                               User Commands                                               LS(1)
      
      
      
      NAME
      
          ls - list directory contents
      
      
      
      SYNOPSIS
      
          ls [OPTION]... [FILE]...
      
      
      
      DESCRIPTION
      
          List  information  about the FILEs (the current directory by default).  Sort entries alphabetically if none of
      
          -cftuvSUX nor --sort is specified.
      
      
      
          Mandatory arguments to long options are mandatory for short options too.
      
      
      
          -a, --all
      
                  do not ignore entries starting with .
      
      
      
          -A, --almost-all
      
                  do not list implied . and ..
      
      
      
          --author
      
                  with -l, print the author of each file
      
      
      
          -b, --escape
      
                  print C-style escapes for nongraphic characters
      
      
      
          --block-size=SIZE
      
                  scale sizes by SIZE before printing them; e.g., '--block-size=M' prints sizes  in  units  of  1,048,576
      </code></pre></div></div>
      
      <p>$apropos (명령어): 해당 명령어와 관련있는 명령어를 설명과 같이 보여준다</p>
      
      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    _llseek (2)          - reposition read/write file offset
      
          afs_syscall (2)      - unimplemented system calls
      
          assert (3)           - abort the program if assertion is false
      
          auth_destroy (3)     - library routines for remote procedure calls
      </code></pre></div></div>
      
      <p><br>
      <br></p>
      
      <p>$ info : 명령어를 하이퍼텍스트 형식으로 관련정보를 알려준다</p>
      
      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    File: coreutils.info,  Node: ls invocation,  Next: dir invocation,  Up: Directory listing
      
      
      
          10.1 'ls': List directory contents
      
          ==================================
      
      
      
          The 'ls' program lists information about files (of any type, including
      
          directories).  Options and file arguments can be intermixed arbitrarily,
      
          as usual.
      </code></pre></div></div>
      
      <p>$ whatis : 해당명령어의 간단한 설명</p>
      
      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    [vagrant@host1 xxx]$ whatis ls
      
          ls (1)               - list directory contents
      
          ls (1p)              - list directory contents
      </code></pre></div></div>
      
      <p>$ alias : 사용 가능한 단축 명령어를 확인 할 수 있다</p>
      
      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    alias
      
          alias egrep='egrep --color=auto'
      
          alias fgrep='fgrep --color=auto'
      
          alias grep='grep --color=auto'
      
          alias l.='ls -d .* --color=auto'
      
          alias ll='ls -l --color=auto'
      
          alias ls='ls --color=auto'
      
          alias which='alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'
      </code></pre></div></div>
<br>
<hr>
<br>
<h1>2023-03-21</h1>
<pre>


<h3>virtualbox</h3>

https://www.virtualbox.org/

에서 downloads -> windows host 설치하기

https://www.vagrantup.com/

에서 download -> windows -> AMD64 설치

mkdir vm-projects 
->
mkdir host1
으로 들어간후 

config.vm.box = "sysnet4admin/CentOS-k8s"
- contos7설치

또는

config.vm.box = "sysnet4admin/Ubuntu-k8s"
- ubuntu 설치

설정후 vagrant up 으로 설치

vagrant ssh 로 접속

vagrant@k8s:~$ 
~$는 사용자
~#은 관리자

man grep 으로 메뉴얼 확인가능 // 엔터로 한줄씩 내려감,스페이스바 한페이지씩, 나가려면 q


<h3>inode와 파일의 관계</h3> 

file.txt 는 inode를 지칭하는 이름이고
inode 는 파일의 데이터가 저장될 위치를 알려주는 정보이다


vagrant@k8s:~$ sudo ln /etc/hosts host_link2
로 링크를 생성 

-rw-r--r-- 3 root    root     218 Mar 20  2021 host_link2
3 은 링크수다 이 링크 수가 0이 되면 inode가 사라진다

rm -rf test1
하위 디렉토리까지 삭제

cat host_link
파일 내용 출력

mv temp1 ok
파일명 ok로 변경

grep "alias" .bashrc
.bashrc 에서 "alias" 라는 단어가 있는 줄을 출력

find /etc -name "cron" -ls
etc에서 cron이라는 파일을 찾고 리스트로 출력

sudo apt install nano
나노 설치

Shell의 특성 인터페이스 

REPL(Read-Eval-Print-Loop)


alias 별명을 부여해줌


\ 는 이스케이프 특수기능을 탈출하는 기능이다
또 마지막에 입력하면 다음 라인도 입력을하겟다 라는 의미이다

vagrant@k8s:~$ echo "MY name is "hong"."
MY name is hong.
vagrant@k8s:~$ echo "MY name is \"hong\"."
MY name is "hong".


cat << hello
hello가 나오기전까지 입력할수 있다

cat << EOF > hello
EOF가 나오기전까지 입력하고 나오면 hello에 내보낸다


약자

urs (User requirements document)
- 소프트웨어 제품이나 서비스를 개발할 때, 사용자가 필요로 하는 기능, 요구 사항, 제약 사항 등을
  문서화하여 개발 프로젝트의 기반을 제공하는 문서입


pwd (print working directory)
- 컴퓨터의 명령 줄 인터페이스에서 현재 작업 중인 디렉터리의
  이름을 출력하는 데 쓰인다


grep (Global regular expression print)
- 정규 표현식을 사용하여 파일 내에서 문자열을 검색하는 강력한 검색 도구


</pre>
<br>
<hr>
<br>
<h1>2023-03-22</h1>
<pre>


$ env
환경변수만 출력 


<h3>shell사용법과 환경변수</h3>

shell 에서 만든 변수를 다른 프로그램에서 사용하고 싶다면 환경변수로 만들어 공개하야한다
단 해당 환경변수를 만든 shell 부모인 shell에서는 사용불가


파일권한 

마스크값


리눅스/유닉스 파일 권한은 10진수와 8진수 두 가지 방법으로 표시할 수 있습니다.
 파일 권한은 일반적으로 세 부분으로 구성됩니다

1. 파일 유형: 파일인지 디렉토리인지 등을 나타냅니다.
2. 소유자 권한: 파일 소유자의 권한을 나타냅니다.
3. 그룹 권한: 파일이 속한 그룹의 권한을 나타냅니다.

각 부분은 3개의 비트로 구성되며, 각 비트는 해당 권한을 나타내는데 사용됩니다.
 각 비트의 의미는 다음과 같습니다.

1. r (읽기): 4
2. w (쓰기): 2
3. x (실행): 1

파일 유형 비트, 소유자 권한 비트, 그룹 권한 비트를 순서대로 3비트씩 묶어서
 10진수나 8진수로 표현할 수 있습니다.

 예)

 -rwxr-xr-x  1 user  group   4096 Mar 21  2023 example.txt

위 예시에서 파일 권한은 -rwxr-xr-x입니다. 이 권한은 소유자에게는 읽기, 쓰기
 실행 권한이 있고, 그룹과 기타 사용자에게는 읽기, 실행 권한이 있다는 것을 나타냅니다.


<h3>docker</h3>


컨테이너 기반의 오픈소스 가상화 플랫폼입니다.
컨테이너는 가상화 기술의 한 종류로, 운영체제 수준에서 격리된 실행 환경을 제공하여 애플리케이션을
실행할 수 있게 합니다


<h3>도커 사용법</h3>


`$ sudo apt remove docker docker-engine docker.io containerd runc`

기존에 저장된 도커 오브젝트(images, containers, volumes, network) 제거
`$ sudo rm -rf /var/lib/docker`
`$ sudo rm -rf /var/lib/containerd`

### 도커 설치 스크립트 다운로드

`$ sudo apt-get update`
`$ sudo apt-get install curl`
`$ curl https://get.docker.com > docker-install.sh`
`$ chmod 755 docker-install.sh`

### 도커 설치

`$ sudo ./docker-install.sh`

## 도커 컨테이너 다루기

### 도커 컨테이너 생성 및 실행

우분투 14.04 컨테이너 생성

- `$ sudo docker run -i -t ubuntu:14.04`
- `-i` : 상호 입출력 하겠다고 설정
- `-t` : tty를 활성화해서 bash 셸을 사용하도록 설정

컨테이터 나가기 및 종료

- `$ exit` 또는 Ctrl + D : 배시셸을 종료함으로써 컨테이너를 정지시킨다.
- Ctrl + P 다음에 Ctrl + Q: 단순히 컨테이너의 셸만 빠져나온다.

### 도커 컨테이너 실행 세부 단계

도커 이미지 내려받기

- `$ sudo docker pull centos:7`

도커 이미지 목록 확인하기

- `$ sudo docker images`

도커 이미지로 컨테이너 생성하기

- `$ sudo docker create -i -t --name mycentos centos:7`

도커 컨테이너 실행하기

- `$ sudo docker start mycentos`
- `$ sudo docker start 해시아이디일부분`

도커 컨테이너에 들어가기

- `$ sudo docker attach mycentos`

정리

- `docker run`
  - 이미지 없으면 `docker pull`
  - `docker create -i -t`
  - `docker start`
  - `docker attach` : -i -t 옵션을 사용했을 때
- `docker create`
  - 이미지 없으면 `docker pull`
  - `docker create -i -t`

### 도커 컨테이너 목록 확인

실행 중인 컨테이너 목록 보기

- `$ sudo docker ps`

모든 컨테이너 목록 보기

- `$ sudo docker ps -a`
  - CONTAINER ID: 컨테이너에 자동 할당되는 고유한 ID.
    - `$ sudo docker inspect 컨테이너이름 | grep Id` : 컨테이너 ID 전체 보기
  - IMAGE: 컨테이너 이미지 이름
  - COMMAND: 컨테이너가 시작될 때 실행될 명령
  - CREATED: 컨테이너가 생성된 후 흐른 시간
  - STATUS: 컨테이너 상태. Up(실행중), Exited(종료), Pause(중지)
  - PORTS: 컨테이너가 개방한 포트와 호스트에 연결한 포트. 외부에 노출하도록 설정하지 않았다면 출력 내용 없음.
  - NAMES: 컨테이너의 고유한 이름. --name 옵션으로 설정한 이름. 설정하지 않으면 형용사와 명사를 사용해 무작위 생성.
    - `$ sudo docker rename 무작위이름 새이름`

### 도커 컨테이너 삭제

사용하지 않는 컨테이너 삭제하기

- `$ sudo docker rm epic_dubinsky`

실행 중인 컨테이너 삭제하기

- `$ sudo docker stop mycentos` : 실행 중인 컨테이너 정지시키기
- `$ sudo docker rm mycentos` : 컨테이너 삭제하기

또는 `-f` 옵션을 사용하여 종료와 삭제를 한 번에 처리하기

- `$ sudo docker rm -f mycentos`

정지된 모든 컨테이너 삭제하기

- `$ sudo docker container prune`

실행 중인 컨테이너 모두 정지 후 삭제하기

- `$ sudo docker stop $(sudo docker ps -a -q)`
- `$ sudo docker rm $(sudo docker ps -a -q)`

### 도커 컨테이너를 외부에 노출하기

도커가 설치된 호스트에서만 접근 가능

- `$ sudo docker run -i -t --name network_test ubuntu:14.04`
  - NIC 확인: `# ifconfig`

컨테이너를 노출 시키기

- `$ sudo docker run -i -t --name mywebserver -p 80:80 ubuntu:14.04`
  - `-p 호스트포트:컨테이너포트`
  - 여러 개의 포트 노출: `-p` 옵션을 여러 개 삽입

컨테이너에 아파치 웹 서버 설치 및 시작시키기

- `root@xxx# apt-get update`
- `root@xxx# apt-get install apache2 -y`
- `root@xxx# service apache2 start`








</pre>
<br>
<hr>
<br>
<h1>2023-03-23</h1>
<pre>


<h3>Host 볼륨(저장공간=directory) 공유하기</h3>

host 

-> volume 생성

myvolume

<h3>Docker 이미지 생성과 배포</h3>

ubuntu:14.04 

-> 생성


### 데이터베이스 컨테이너와 웹서버 컨테이너 만들기

데이터베이스 컨테이너 만들기

- `$ sudo docker run -d --name wordpressdb -e MYSQL_ROOT_PASSWORD=password -e MYSQL_DATABASE=wordpress mysql:5.7`

워드프레스 기반 블로그 서비스 만들기

- `$ sudo docker run -d --name wordpress -e WORDPRESS_DB_HOST=mysql -e WORDPRESS_DB_USER=root -e WORDPRESS_DB_PASSWORD=password --link wordpressdb:mysql -p 80 wordpress`

접속 확인

- `http://vagrant리눅스IP:자동설정된포트번호/`
  - vagrant ssh 밖에서 실행할 것

도커 컨테이너 run 옵션

- `$ sudo docker run -d ... -e ... --link ...`
  - `-d` : Detached 모드로 컨테이너 실행. 컨테이너에서 백그라운드에서 동작하는 애플리케이션을 실행할 때 사용.
    - 이 모드에서는 실행되는 컨테이너가 실행하는 프로그램이 없으면 자동 종료된다.
      - 테스트: `$ sudo docker run -d --name detach_test ubuntu:14.04`
      - `$ sudo docker ps -a` 로 확인해보면 컨테이너가 실행 즉시 종료되었음을 확인할 수 있다.
  - `-e 환경변수명=값` : 컨테이너 내부의 환경변수 설정. 컨테이너에서 실행되는 애플리케이션이 이 환경 변수를 사용한다.
    - Detached 모드 컨테이너의 내부 환경 변수 확인하기
      - 셸 접속: `$ sudo docker exec -i -t wordpressdb /bin/bash`
      - 환경 변수 확인: `# echo $MYSQL_ROOT_PASSWORD`
  - `--link 컨테이너명:별명` : 내부 IP를 알 필요 없이 컨테이너 별명으로 접근하도록 설정
    - 도커 엔진은 컨테이너에게 내부 IP를 172.17.0.2, 3, 4, ... 와 같이 순차적으로 할당.
    - 테스트: `$ sudo docker exec wordpress curl mysql:3306 --silent`

### 도커 볼륨 다루기

#### 호스트 볼륨 공유하기

- `$ sudo docker run -d --name wordpressdb_hostvolume -e MYSQL_ROOT_PASSWORD=password -e MYSQL_DATABASE=wordpress -v /home/wordpress_db:/var/lib/mysql mysql:5.7 `
  - `-v 호스트의공유디렉토리:컨테이너의공유디렉토리`
  - 호스트의 공유 디렉토리가 없으면 도커가 자동 생성한다.
- `$ sudo docker run -d --name wordpress_hostvolume -e WORDPRESS_DB_HOST=mysql -e WORDPRESS_DB_USER=root -e WORDPRESS_DB_PASSWORD=password --link wordpressdb_hostvolume:mysql -p 80 wordpress`

컨테이너 삭제 후에도 데이터가 보존되는 것을 확인하기

- `$ sudo docker stop wordpress_hostvolume wordpressdb_hostvolume`
- `$ sudo docker rm wordpress_hostvolume wordpressdb_hostvolume`

호스트 디렉토리를 컨테이너의 존재하는 디렉토리와 연결할 때

- `$ sudo docker run -i -t --name volume_dummy alicek106/volume_test`
  - 컨테이너에 존재하는 디렉토리 확인: `# ls /home/testdir_2/`
- `$ sudo docker run -i -t --name volume_override -v /home/wordpress_db:/home/testdir_2 alicek106/volume_test`
  - 컨테이너에 존재하는 디렉토리 확인: `# ls /home/testdir_2/`
    - 기존의 디렉토리를 호스트 디렉토리로 대체한다.

#### 볼륨 컨테이너 공유하기

volume_override 컨테이너의 볼륨을 공유하기

- `$ sudo docker run -i -t --name volumes_from_container --volumes-from volume_override ubuntu:14.04`
  - 컨테이너에 추가된 디렉토리 확인: `# ls /home/testdir_2/`

#### 도커 볼륨 사용하기

도커 볼륨 생성하기

- `$ sudo docker volume create --name myvolume`

도커 볼륨 조회하기

- `$ sudo docker volume ls`

도커 볼륨 사용하기

- `$ sudo docker run -i -t --name myvolume_1 -v myvolume:/root/ ubuntu:14.04`
  - `# echo Hello, volume! >> /root/volume`

도커 볼륨 공유하기

- `$ sudo docker run -i -t --name myvolume_2 -v myvolume:/root/ ubuntu:14.04`
  - `# cat /root/volume`

도커 볼륨의 실제 위치 알아내기

- `$ sudo docker inspect --type volume myvolume`
  - `docker inspect` 명령: 컨테이너, 이미지, 볼륨 등 도커의 모든 구성 단위의 정보를 확인할 때 사용
    - `--type [image|volume|container]`

도커 볼륨 자동 생성하기

- `$ sudo docker run -i -t --name volume_auto -v /root/ ubuntu:14.04`

컨테이너가 사용하는 도커 볼륨 확인하기

- `$ sudo docker container inspect volume_auto`

사용하지 않는 볼륨을 자동으로 삭제하기

- `$ sudo docker volume prune`

#### mount 옵션

mount 옵션으로 도커 볼륨 연결하기

- `$ sudo docker run -i -t --name mount_option_1 --mount type=volume,source=myvolume,target=/root/ ubuntu:14.04`

mount 옵션으로 호스트 디렉토리를 컨테이너에 연결하기

- `$ sudo docker run -i -t --name mount_option_2 --mount type=bind,source=/home/wordpress_db,target=/root/ ubuntu:14.04`

### 도커 네트워크 다루기

도커 호스트의 가상 이더넷 카드

- `$ ifconfig`
  - 실행 중인 컨테이너 개수 만큼 `vethxxxx` 가상 이더넷 카드가 생성된 것을 확인 할 수 있다.

#### 도커 네트워크

도커에서 기본적으로 쓸 수 있는 네트워크 확인하기

- `$ sudo docker network ls`
  - bridge: 컨테이너를 생성할 때 자동으로 연결되는 docker0 브리지를 활용하도록 설정됨
    - 172.17.0.x IP 대역을 컨테이너에 순차적으로 할당한다.

## 도커 이미지 다루기

도커 허브라는 중앙 이미지 저장소에서 도커 이미지 검색하기

- `$ sudo docker search 키워드`

### 도커 이미지 생성

이미지 목록 조회

- `$ sudo docker images`

이미지로 만들 컨테이너 준비

- `$ sudo docker run -i -t --name commit_test ubuntu:14.04`
  - 컨테이너 변경: `# echo test_first! >> first`

컨테이너를 이미지로 만들기

- `$ sudo docker commit 옵션 컨테이너명 REPOSITORY:TAG`
- `$ sudo docker commit -a "alicek106" -m "my first commit" commit_test commit_test:first`
  - `-a author` : 이미지 작성자에 대한 정보를 이미지에 포함시킨다.
  - `-m 커밋메시지` : 이미지에 포함될 부가 설명을 설정한다.

만든 이미지로 컨테이너 만들기

- `$ sudo docker run -i -t --name commit_test2 commit_test:first`
  - 컨테이너 변경: `# echo test_second! >> second`

변경한 컨테이너로 새 이미지 만들기

- `$ sudo docker commit -a "alicek106" -m "my second commit" commit_test2 commit_test:second`

### 도커 이미지 정보 조회

이미지 정보 살펴보기

- `$ sudo docker inspect ubuntu:14.04`
- `$ sudo docker inspect commit_test:first`
  - Layers = ubuntu:14.04 Layers + 추가사항 I
- `$ sudo docker inspect commit_test:second`
  - Layers = commit_test:first Layers + 추가사항 II
  - Layers = ubuntu:14.04 Layers + 추가사항 I + 추가사항 II

이미지 레이어 구조에 대한 변경 내역 확인하기

- `$ sudo docker history 도커이미지명`
- `$ sudo docker history commit_test:first`

### 도커 이미지 삭제

이미지 삭제하기

- `$ sudo docker rmi commit_test:first`
  - 이미지를 사용 중인 컨테이너가 있을 경우 삭제할 수 없다.
  - 컨테이너를 먼저 삭제한 후 이미지를 삭제해야 한다.
    - `$ sudo docker stop commit_test2 && sudo docker rm commit_test2`

댕글링(dangling) 이미지 다루기

- 컨테이너 생성
  - `$ sudo docker run -i -t --name dangle_test commit_test:second`
  - 컨테이너 확인: `$ sudo docker ps -a`
- 컨테이너가 사용한 이미지 강제 삭제
  - `$ sudo docker rmi -f commit_test:second`
  - 컨테이너 확인: `$ sudo docker ps -a`
    - 이미지 이름이 변경되어 있다.
- 삭제된 이미지 확인
  - `$ sudo docker images -f dangling=true`

### 도커 이미지 추출

도커 이미지를 한 개의 파일로 추출하기

-`$ sudo docker save -o ubuntu_14_04.tar ubuntu:14.04`

도커 이미지 로드하기

- `$ sudo docker load -i ubuntu_14_04.tar`

### 도커 이미지 배포

#### 도커 허브(<https://hub.docker.com/>)에 회원 가입 및 로그인

#### 이미지 저장소 생성

- _Create a Repository_ 클릭
- 저장소명: hello-docker
- 설명: 테스트용
- Visibility: private

#### 테스트용 이미지 생성

- `$ sudo docker run -i -t --name mycontainer ubuntu:14.04`
  - 컨테이너 변경: `# echo my first push >> test`

#### 테스트용 이미지 커밋하기

- `$ sudo docker commit mycontainer hello-docker:0.1`

#### 이미지에 태깅하기

- `$ sudo docker tag local-image:tagname new-repo:tagname`
- `$ sudo docker tag hello-docker:0.1 96abab/hello-docker:0.1`

#### 도커 허브에 로그인 하기

- `$ sudo docker login`

#### 저장소에 이미지 올리기

- `$ sudo docker push new-repo:tagname`
- `$ sudo docker push 96abab/hello-docker:0.1`

도커 허브 사이트의 Tags 탭에서 확인할 것!

#### 저장소에 업로드한 이미지 가져오기

- `$ sudo docker pull eomjinyoung/hello-docker:0.0`

#### 가져온 이미지로 컨테이너 생성, 실행 및 접속

도커 이미지 목록 확인하기

- `$ sudo docker images`

도커 이미지로 컨테이너 생성하기

- `$ sudo docker create -i -t --name hello1 eomjinyoung/hello-docker:0.0`

도커 컨테이너 실행하기

- `$ sudo docker start hello1`

도커 컨테이너에 들어가기

- `$ sudo docker attach hello1`






</pre>
  </section>
</main>
</div>
<footer id="footer">

<li><small><a href="https://github.com/96abab/test.io.git">96abab.GitHub.com - test.io</a></small></li>
</footer>
</body>
</html>
