<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>96abab</title>
    <link rel="stylesheet" href="stylesheet.css">
    <link rel="icon" href="https://96abab.github.io/test.io/ducklogo.png">
    
</head>
<body>
<div id="container">
<header>
  <h2>JAVA</h2>
  <nav>
    <ul id="topMenu">
      <li><a href="https://96abab.github.io/test.io">home</a></li>
      <li><a href="#">menu1</a></li>
      <li><a href="#">menu2</a></li>
    </ul>
  </nav>
</header>
</div>
<aside>
<ul id="sidebar">
  <li><a href="index.html">Home</a></li>
  <br>
  <li><a href="assignment.html">과제</a></li>
  <br>
  <li><a href="tictactoe.html">TICTACTOE</a></li>
  <br>
  <li><a href="cloudOS.html">1.CloudOS(리눅스서버설치)</a></li>
  <br>
  <li><a href="linux.html">2.리눅스 명령어 정리</a></li>
  <br>
  <li><a href="HTML5.html">3.HTML수업</a></li>
  <br>
  <li><a href="CSS.html">4.CSS수업</a></li>
  <br>
  <li><a href="JAVAscript.html">5.JAVAscript</a></li>
  <br>
  <li><a href="JAVA.html">6.JAVA</a></li>

</ul>
</aside>
<main class="contents">
<section id="headling">
<h1>2022-12-26</h1>
<br>
<br>
<pre>
<strong>web Application Architecture</strong>


client (web browser)
HTML
CSS
JAVAscript
+
jquery
bootstrap
+
react

-서버에 있는 자원을 받아 실행


web server 

HTML,CSS,javascript등 읽는다
-정적자원 :실행하지 않고 그대로 읽어 리턴해 주는것(static resource)


<strong>springboot 기술스택</strong>


java로 만들어졋다 (JVM - interpreter,player,runtime Engine) -> tomcat server -> jakartaEE API(javaEEApi) -> spring Framework -> java APP , mybatis , JSP , thymeleaf

JDK

<strong>java설치 준비</strong>

1. java.oracle에서  x64 MSI Installer 다운
2. 환경변수 설정
JAVA_HOME -> JDK 설치 폴더
PATH -> JDK/bin 폴더경로 추가


setx JAVA_HOME JDK설치폴더 /m
setx PATH "JDK/bin;%PATH%"

/usr/libexec/java_home -V


gradle.org



*JAVA_HOME
1. JDK가 설치된 폴더 경로
2. java App 이 JDK를 찾을떄 이 환경변수를 이용한다


*PATH
-> 실행프로그램이 있는 폴더 경로
-> CLI에서 프로그램 이름으로 
바로 실행하고 싶을 때  

빌드 도구 설치 및 설정
1. 프로잭트폴더를 준비
2. JDK 를 이용하여 컴파일 신청, 테스트 수행
3. 아카이브 (archive) 파일을 생성 
배포파일 (.jar,)


*인터프리터 방식 

node hello.js


*컴파일 방식

gcc -o hello.exe hello.c

실행 hello.exe or hello


*하이브리드 방식 


컴파일 방식보다 나은 이유

1. 동일한 바이트코드를 생성하여 OS마다 컴파일 할 필요가 없다

2. OS용 JVM이 설치되어 있다면 실행할 수 있다

3. 컴파일 과정에서 문법의 오류를 모두 찾아낸다 
(실행마다 문법검사를 하는 순수 인터프리터방식 보다 실행속도가 빠르다)

4. 완전 기계어는 아니지만 기계어에 가까운 언어로 
   변환된 명령을 실행하기 때문에 소스에 작성된 
   명령을 실행하는 것보다 빠르다



Hello.java

-컴파일

문법검사 수행 -> 문법오류를 모두 찾아냄
최적화 -> 실행 성능 향상


<strong>LLVM 컴파일</strong>
low level virtural Machine

1. LLVM 이전

 
hello.c -> C compiler -> 기계어 -> windows or macOS or Linux

컴파일러를 만드는 입장에서 c 언어를 해석하는 부분은 동일하다
=> 중복개발 


서로 다른언어 일때 컴파일러가 windows 에 맞는 기계어로 바꾸는
부분은 동일
=> 중복개발


*기존방식의 문제점

compiler제작자는 변환시킬 언어들과 변환후 적용할 기계어 또한
알아야한다는 부담


2. LLVM 이후 
LLVM 방식을 사용하는 이유
새 프로그래밍 언어와 컴파일러를 만들기 쉽다
다양한 언어를 쉽게 중간어로 바꾸고 다시 기계어로 변환시킬 수 있다


1단계 컴파일

-각 언어들을 중간어로 바꾸면 된다 컴파일러 제작자는 
한개의 가상기계어만 다루면 된다 


2단계 컴파일

-중간어를 기계어로 바꾸기만 하면 된다 


<strong>JAVA 와 LLVM</strong>


java -> .java
kotlin -> .kt
scala -> .scala  
groovy -> groovy.
자바 호환 언어

=> .class (bytcode)

=> 기계어



<strong>JDK,JRE,JVM</strong>

.class -> JVM -> 실행


JRE (java Runtime Environment)
javalibrary


JDK (java development kit)
개발도구(컴파일러,디버거등)


<strong>java EE, java SE, java ME</strong>


java EE (Enterprise Edition) -> 기업용 Applucation 제작에 필요한 도구

java SE (Standard Edition) -> java.app 제작 필수 도구
-JDK, JRE, server 용 JRE

java ME (Micri Edition) -> 임베디드 app 제작에 필요한 도구


<strong>Eclipse IDE</strong>


개발 플랫폼 + plug-in => 개발도구확장



<strong>java project 폴더 준비</strong>


1. 프로젝트 폴더 생성

c:/users/bitcamp/git/bitcamp-ncp/boot-project


2. 'boot-project/' 폴더를 java프로젝트 폴더로 초기화 

$gradle init

패키지는 보통 회사.프로잭트명 으로한다

kr.co.bitcamp.bootapp


3. 기본 예제 프로그램 실행

gradle -q run  (설명 빼고 결과만 실행)


프로젝트 폴더 boot-app


app 하위 프로젝트. 메인프로젝트
src/main/java   -> java소스파일을 두는 폴더
src/main/resources -> 기타 파일을 두는 폴더
src/test/java -> 단위테스트를 수행하는 자바소스파일
src/test/resources -> 단위테스트 관련 기타 파일

app
build.gradle -> build script파일 (빌드설정정보)
build -> 빌드로 생성한 파일 및 디렉토리를 두는 폴더 


boot-app
setting.gradle -> 프로그램 설정정보
gradlew,gradlew.bat -> gradle 도구 설치 명령 파일 
                      (gradle 도구가 설치되지 않았을때 사용)
gradle/ -> gradlew,gradlew.bat 가 사용하는 파일이 들어있다
.gradle/ -> gradle 도구들  


<strong>springboot 프로젝트 만들기</strong>


spring.io방문 -> project -> springboot 메뉴 -> spring initializr 클릭 
add dependencies

1. spring boot dev tool     -> 자동 로딩
2. spring configuration processor  -> project
3. spring web


<strong>JAVA에서 Spring Boot 까지</strong>


Spring Boot -> Tomcat server (networking API, thrend prog.) 
+ spring framework(spring webVMC,spring IOC)+ mybatis+(JSBC API) + SQL)


-> servlet/JSP, JSBC API

-> java I/O API, collection API

-> java 기본 문법 (built-in class)

-객체지향문법
-메서드/클레스
-연산자/제어문/반복문
-변수/리터럴

</pre>
<br>
<hr>
<br>
<h1>2022-12-27</h1>
<br>
<br>
<pre>
<strong>Maven 빌드 도구의 표준 프로젝트 디렉토리 구조</strong>

~/git/bitcamp-ncp/      //git repo.
~/git/bitcamp-ncp/boot-app/ // project 폴더


settings.gradle       // gradle 빌드 보조그크립트 파일
gradle/       // gradle 프로그램을 local에 설치해주는 도우미 프로그램
gradlew.bat     // gradle/ 폴더에 들어있는 설치프로그램을 실행하여 gradle을 설치하고
                // 설치한 gradle을 사용해 gradle 명령어를 실행하는 shell 프로그램
gradlew     // unix/linux/winOS 용
.gradle/ gradle 도구가 작업하는 동안 사용하는 임시 폴더


/app/     // sub project 
/app/src/     //소스폴더
/app/build.gradle/      gradle 빌드 스크립트 파일


/////////

<strong>App.java 에서 @명령어 로 import 가 자동 완성 안됬을 때</strong>


1. boot-app (프로젝트 파일에 .gradle 이 repo. 등 다른 곳에 있는지
확인 하여야한다)

2. .gradle이 잘못된 경로에 있을 경우 지웟다가 gradle -q run 을 
정확한 경로에 지정해줘야 한다

3. 이게 경우가 아닐시에는 해당 기능을 하는 서포트 프로그램이 작동하는지 확인
(java일 경우 language support of java(TM) by Red Hat  있는지 확인)



<strong>Gradle 빌드 도구</strong>

Gradle
default tasks (기본 실행작업)

.init
.project
.wrapper
.tasks

gradle tasks --all
현재할 수 있는 모든 작업


build.gradle
plug-in {           //  build script 빌드도구의 설정정보
  id '플러그인 ID'

}


eclipse 

.eclipse 로 아래 있는 모든것을 한번에 생성 

.eclipseProject -> .project 파일 생성
.eclipseClasspath -> .classpath 생성
.eclipseJdt -> .settings 생성 (지울시 파일 껍때기가 남음)


*eclipse 에러날시에  clean으로 지우고 다시 설치하는게 빠를수도 있다



<strong>.java 와.class 컴파일</strong>


Test1.java  (source)

class A {}  
class B {}
class C {}

javac Test1.java 컴파일시 class 만큼 bytcode 생성 
위상황에는 3개의 클래스 생성


A.java
class A {}  

B.java
class B {}

유지보수가 쉽도록 하나에 하나씩만 생성


<strong>소스파일과 .class파일 분리</strong>
배포 파일을 추출하는 등 관리가 쉽도록 분리


src/A.java
/B.java
/C.java

bin//A.java
/B.java
/C.java


javac -d bin src/A.java src/B.java  //  해당 자바파일 컴파일
javac -d bin src/*.java    // 모든 자바 컴파일
// 파일이 없으면 만들어서 생성 (bin)
// src는 파일 경로 안에 있는 A.java 를 컴파일 해서 bin에 넣는다


<strong>소스파일과 디렉토리</strong>
여러개의 소스파일을 관리하기 쉽하기 위해 하위디렉토리에 분류
-하지만 src파일에 여러개의 파일안에 소스가 존재해도 bin폴더에 한번에 컴파일한다


<strong>소스파일과 패키지</strong>  
클래스 블록을 유지 보수를 쉽게 하기 위해 만든 문법

src/A.java

src/B.java
package p1;
class B {}

src/p1/*.java

package 하면 컴파일시 p1 파일안에 B.class가 생긴다
소스파일을 찾기 쉽도록 소스파일도 package 이름과 같
은 폴더에 둔다


package는 여러개를 안에 넣을 수 있다

예)
package p1.px;   // package 를 안에 생성시 . 을 붙여준다
class B {}

src/p1/px/*.java 

와같이 소스파일과 package파일의 경로를 똑같이 맞춰준다  


</pre>
<br>
<hr>
<br>
<h1>2022-12-28</h1>
<br>
<br>
<pre>
<strong>shell script</strong>

set outputdir="C:\Users\bitcamp\git\bitcamp-nap\myapp\bin\main"
-파일 경로지정

echo %outputdir%
-경로 확인

for /d /r %v in (*) do javac -d %outputdir% %v\*.java
-반복문을 이용한 컴파일 작업


<strong>Maven</strong>

프로젝트 객체모델(Project Object Model: POM) 이라는 개념을 바탕으로  
프로젝트의 의존성관리, 라이브러리관리, 프로젝트 라이프사이클 관리 
기능등을 제공하는 프로젝트 관리도구이다. 플러그인을 기반으로 소스
코드로부터 배포 가능한 산출물을 만들어내는 빌드 기능을 제공한다.


<strong>클래스 블록의 공개 여부</strong>

public class A {}

public
-> 공개여부를 지정 : 다른 패키지에서 이 클래스에 접근할 수 있다 
공개 클래스명과 파일명이 같아야한다
하나의 파일에 2개 이상의 public클래스를 둘수 없다 
파일명과 동일해야하기 때문이다  

src\main\java\p1\X.java:2: error: class B is public, should be declared in a file named B.java
public class B {}
       ^


<strong>다른 패키지 클래스에 접근</strong>


p1.B obj;
다른패키지 클래스에 접근하는법


javac -d bin/main -classpath bin/main src/main/java/A.java

-classpath
컴파일시 다른 패키지 클래스에 접근

-bin/main
루트패키지가 들어있는 폴더여야 한다

예) bin/main/p1  (X)
패키지에 소속되지 않은 클래스를 나타냄


<strong>접근제한자</strong>

접근 제한자(Access Modifier)는 말 그대로 접근을 제한하기 위해 사용
여기서 접근이란 클래스 및 인터페이스 그리고 이들이 가지고 있는 멤버의
접근을 말합니다. 


- public 접근 제한자
 단어 뜻 그대로 외부 클래스가 자유롭게 사용할 수 있도록 합니다.

- protected 접근 제한자
 같은 패키지 또는 자식 클래스에서 사용할 수 있도록 합니다.

- private 접근 제한자
 단어 뜻 그대로 개인적인 것이라 외부에서 사용될 수 없도록 합니다

- default 접근 제한
 같은 패키지에 소속된 클래스에서만 사용할 수 있도록 합니다.


 ////////////////////


*import
경로를 미리 지정해준다

예)
import p1.B;
// import p2.C;
import p2.px.C;
import p2.px.aaaaa.bbbbb.ccccc.ddddd.D;
class A {
  B obj; 
  p2.C obj2;
  C obj3;
  D obj4;
}

- 둘다 같은 코드이나 import문장을 활용한 차이이다 
- 위를 이용시 아래처럼 바꿔서 컴파일 한다 

class A {
  p1.B obj; 
  p2.C obj2;
  p2.px.C obj3;
  p2.px.aaaaa.bbbbb.ccccc.ddddd.D obj4;
}


<strong>-sourcepath</strong>



javac -d bin/main -sourcepath src/main/java src/main/java/A.java


-sourcepath src/main/java

->
사용하는 클래스의 소스파일이 있다면
classpath로 경로를 지정할 필요가 없다

A.java 를 컴파일할때 A클래스가 사용하는 다른
클래스의 소스파일 경로를 알려준다
=> 
A.java를 컴파일 할 때
A가 사용하는 클래스의 소스파일도 함께 컴파일 된다


<strong>main()</strong>

$java A

java
-bytecode인터프리터
-bytecode player
-JVM (자바버추얼머신)

1. A 클래스 코드를 메모리에 적재(loading)
2. byetcode 검증
3. main() 호출 

puclic static void main(String[] args) {}

-엔트리포인트 (entry point)
-main 메소드 형식(Method Signature = function prototype)을 반드시 
지켜야하며 args (변수명) 은 달라도 된다


-classpath

$java -classpath bin/main A
$java -cp bin/main A
$java -cp bin/main p1.B

루트패키지와 클래스가 들어있는 디렉토리 경로
자바컴파일러와 JVM은 클래스를 찾을 때 이 옵션의 경로를 따라간다


<strong>소스파일 인코딩</strong>

vs코드에서 저장하여 a.java 파일을 컴파일 하고
eclipse에서 읽을 때 window는 한글이 깨진다
949로 저장하기 때문


-encoding UTF-8
을 지정


<strong>정수 리터럴</strong>

4byte

10진수: 100
8진수:  078
2진수:  0b0101
        0B0101
16진수: 0XAC00
        0xAC00


javascript와 다르게 정수 리터럴의 메모리 크기(표현할 수 있는 값의 범위가 있다)가 있다

100 (4byte 정수): -2147483648 ~ 2147483647


<strong>데이터 타입과 리터릴</strong>


정수

4byte 리터럴 (int) 100
8byte 리터럴 (long) 100L 100l

부동소수점

4byte 리터럴 (float <- 단정도) 3.14f 3.14F
8byte 리터럴 (double <- 배정도) 3.14

논리

4byte 리터럴 true,false

문자

2byte 리터럴 'A' '가'

문자열 
- 9.x 버전보다 낮으면 char(2byte) 배열
- 9.x 높다면 byte(1~3)배열

객체 "Hello"

자바기본데이터타입 (primitive Data Type)



값을 메모리에 저장

encoding(변환)

sign-magnitude

논리
true(1) false(0)

한개(4byte)
배열(1byte)



부동소수점 -> IEEE-754 명세서 


12.375 -> 2진수 -> 전기신호 -> 메모리저장

2진수 
-> 1100.011
-> 1.100011 X 10**3
-.100011(가수부), 3(지수부)


</pre>
<br>
<hr>
<br>
<h1>2022-12-29</h1>
<br>
<br>
<pre>
<strong>변수선언(delaration)</strong>
값을 담는 메모리를 준비시키는 문법


자바기본데이터타입 (primitive Data Type)
데이터타입 변수명;

정수 
-byte(1byte)
-short(2byte)
-int(4byte)
-long(8byte)

부동소수점
-float(4byte)
-double(8byte)

논리
-boolean (4/1)

문자
-char(2byte)


reference type

그외
-클래스


*활용*


int a(storage location);

a = 100;

=
-> assignment operator(할당연산자,배당연산자,대입연산자)


<strong>정수 변수</strong>
int a(4byte 정수 메모리) = 100(4byte 정수 리터럴);
long b(8byte 정수 메모리) = 100(4byte 정수 리터럴);

// 예외조건: 리터럴 값이 메모리보다 크기가 크더라도 담을 수
있다면 허용한다! 
->
short c(2byte 정수 메모리) = 100(4byte 정수 리터럴); 
byte d(1byte 정수 메모리) = 100(4byte 정수 리터럴);


<strong>char 변수</strong>


char c;

c (범위: 0~65535)
=> 문자코드(ucs2=UTF-16) 를 저장하는 2byte 메모리
c = 65;


System.out.println(c);

1. 현재 프로그램에서 사용하는 폰트 파일을 찾는다 => D2coding
2. D2coding 폰트 파일에서 65에 해당하는 문자를 찾는다
3. 폰트파일에서 읽은 A문자그림을 출력한다 

결과 
=> A



short s;

s (범위: -32768~ +32767)
s = 65;
System.out.println(c);
결과 
=> 65


<strong> '' 연산자</strong>


'A' -> return -> 65 
A문자에 대한 ucs2 코드값

char c = 'A';




/////////////////////////

public static void main(String[] args) {
  // 한 번에 한 개씩 변수를 선언할 수 있고,
  int i1;
  int i2;
  int i3;
  
  // 콤마(,)를 사용하여 여러 개의 변수를 한 번에 선언할 수 있다.
  int j1, j2, j3;
}


<strong>변수에 값 할당</strong>


- 변수가 가리키는 메모리에 값을 저장하는 것
- 문법
    변수명 = 변수 또는 리터럴;
- 용어 
    = : 할당 연산자(assignment operator)
    l-value : = 왼쪽에 있는 변수를 가리킨다. l-value는 리터럴이 될 수 없다.
    r-value : = 오른쪽에 있는 변수나 리터럴을 가리킨다.
- 의미
    = 오른쪽에 지정된 값을 왼쪽 변수가 가리키는 메모리에 저장.


<strong>변수 선언과 값 할당을 동시에 하기</strong> 


- 변수과 동시에 값을 즉시 저장할 수 있다.
- 문법
    데이터타입 변수명 = 값;


public class Exam0140 {
  public static void main(String[] args) {
    
    //변수 선언 + 값 저장
    //- 이렇게 변수 선언과 값 저장을 한 번에 하는 것을 '변수 초기화 문장'이라 부른다.
    int age = 20; 
  }
}


<strong># 여러 개의 변수를 한 번에 선언하고 초기화도 함께 수행하기 II</strong>


public class Exam0160 {
  
  public static void main(String[] args) {
    //모든 변수를 다 초기화시킬 필요는 없다.
    int a1, a2 = 200, a3, a4 = 400, a5;
  }
}


<strong>변수 사용</strong>

다른 도구(메서드; 함수라고도 부른다)에 값을 전달 할 수 있다.


int age = 20;

println() 메서드(도구)
- 콘솔(console)로 값을 출력할 때 사용하는 도구이다.
- 즉 JVM의 표준 출력 장치로 값을 출력한다.
- 사용법
    System.out.println(리터럴 또는 변수, 결과가 생성되는 명령문)

System.out.println(age); 
 println()을 실행할 때 age 변수를 넘기는 것이 아니라
 age 변수에 들어있는 값을 넘기는 것이다!!!!


<strong>레퍼런스 변수</strong>


public class Exam0451 {
  public static void main(String[] args) {

    java.util.Date d1 = new java.util.Date();
    java.util.Date d2 = d1;
    
    System.out.printf("%d, %d\n", d1.getDate(), d2.getDate());
    
    d1.setDate(22);
    
    System.out.printf("%d, %d\n", d1.getDate(), d2.getDate());
    // d1에 저장된 일자 값을 변경한 후 
    // d2에 저장된 일자 값을 출력해 보면 d1과 똑같이 변경되어 있다.
    // 이유는?
    // d1과 d2에 저장되는 것은 값이 아니라 (날짜 정보가 저장되어 있는 메모리의) 주소이다.
    // 이렇게 값을 저장하지 않고 값이 저장된 위치(주소)를 저장하는 변수를 
    // "레퍼런스 (변수)"라 부른다.
    // 자바 기본 데이터 타입(byte, short, int, long, float, double, boolean, char)을
    // 제외한 모든 타입의 변수는 레퍼런스이다.
  }
}


<strong>배열</strong>
같은 종류의 메모리를 여러개 생성할 때 사용하는 문법

데이터타입[] 변수명;  <- 권장
데이터타입 변수명[];  <- c style

변수명
=> 주소를 담는 변수 = reference 변수

변수명 = new 


<strong>배열선언</strong>


int a1, a2, a3, a4;
-변수들이 개별적이기 때문에 연속된 메모리가 아니다

a 
다른 메모리의 주소를 담을 만큼 적절한 크기


int[] a;

a = new int[4];
-연속된 메모리다

new
JVM은 Heap 영역이 연속된 int 타입의 메모리를 준비
리턴값은 준비한 메모리의 시작주소이다


<strong>RAM과 메모리 주소</strong>


app을 실행하면 OS가 사용할 메모리를 제공하고 app 실행 종료시 
사용한 메모리 영역은 사용가능한 영역으로 바뀐다 하지만 영역에
는 쓰레기(garbage value)가 남는다 이를 사용할 때 초기화하여 
사용한다고 의미한다 

메모리는 연속된 바이트의 1 차원 배열이다 
이해를 돕기위해 2차원으로 표현한다

app -> OS로부터 제공받은 메모리
명령문 -> (code segment)
데이터를보관 -> (data segment)


<strong>JVM과 메모리</strong>


java.exe(JVM) -> 사용

OS가 승인한 메모리에

method Area
- 클래스 코드를 둔다
- static 변수를 둔다

Heap
-new명령으로 준비한 변수를 둔다

constant Pool
-상수값을 둔다

stack
-스레드(thread)별로 stack 영역을 관리 
-> 1thread = 1stack


<strong>배열 메모리에 접근</strong>


int[] arr = new int[4];

arr[0] = 100;
arr[1] = 200;
arr[2] = 300;
arr[3] = 400;
arr[4] = 500;  // 실행오류 (runtime exception = Array )

예)
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 5 out of bounds for length 5
	at com.eomcs.lang.ex04.Exam0520.main(Exam0520.java:28)



<strong>배열 reference 변수</strong>

배열 인스턴스의 주소를 담는 변수


int[] arr = new int[4];

arr = 0;   // (X)
arr = null // (O)  레퍼런스 주소를 초기화시킨다


int a;

로컬변수는 자동으로 초기화 되지않는다
반드시 직접초기화 해야한다


<strong>배열 인스턴스와 가비지(garbage)</strong>

인스턴스의 주소를 잃어버려 사용할 수 없는 상태의 인스턴스

int[] arr = new int[4];

arr[0] = 300;
arr[2] = 400;


arr = new int[3];

arr[0] = 70;

위에있는 int[0] = 300; 은 주소를 잃어버려 접근 불가
이것을 farbage라고하며 메모리 부족시
garbage collector 가

1. 메모리가 부족할 때 
2. CPU 한가할 때 

자동으로 지워서 메모리를 제공해준다
 
 
<strong>가비지와 레퍼런스 카운트</strong>


JVM


int[] arr1 = new int[3]; (200)  X

int[] arr2 = arr1; (200)

int[] arr3 = new int[2]; (300)

arr1 = new int[4]; (400)

arr2 = arr3; (300)

JVM Cnt 
200 0
300 2
400 1



1) 배열 선언 + 초기화

  데이터타입[] 변수명 = new 데이터타입[]{값, 값, 값};
  - 배열 메모리를 초기화시킬 때는 배열 개수를 지정해서는 안된다.
  - 배열을 초기화시키는 값의 개수 만큼 메모리가 만들어진다.
  - 즉 다음은 값 개수만큼 int 메모리가 3개가 생성된다.
   ex) int[] arr = new int[]{10, 20, 30};
  - 다음과 같이 new 명령을 생략할 수 있다.
    데이터타입[] 변수명 = {값, 값, 값};
    ex) int[] arr = {10, 20, 30};


 2) 배열 선언 후 따로 배열 초기화 문장 실행

   데이터타입[] 변수명;
   변수명 = new 데이터타입[]{값, 값, 값};
   ex)
   int[] arr1;
   arr1 = new int[]{10, 20, 30};
  - 변수를 선언한 후 따로 배열을 초기화시킬 때는
    new 명령을 생략할 수 없다.


<strong>상수 - 변수의 값을 고정하는 방법</strong>

public class Exam0610 {
  public static void main(String[] args) {
    // 변수
    // => 언제든지 값을 변경할 수 있다.
    int a; //static type binding
    a = 10;
    a = 100;
    a = -300;

    // 상수
    // => 값을 오직 한 번만 저장할 수 있다.
    // => 변수 앞에 final을 붙여라!
    final int b;
    b = 100;

    // 만약 final로 선언된 변수의 값을 두 번째로 바꾸려 한다면?
    //    b = 200; // 컴파일 오류!

    // 변수와 상수를 구분하기 위해서
    // => 상수인 경우 이름을 보통 모두 대문자로 작성한다.
    // => 그리고 변수를 선언하는 문장에서 바로 값을 초기화시킨다.
    final float PI = 3.14159f;
    final float MILE = 0.621371f;


<strong>변수의 종류</strong>


public class Exam0710 {

  int a; // 인스턴스 변수

  static int b; // 클래스 변수 == 스태틱 변수


  public static void main(String[] args/*로컬변수=파라미터*/) {

    int c; // 로컬 변수

  }
}

// 인스턴스 변수(instance variable)
// - new 명령을 사용하여 인스턴스를 생성할 때 준비되는 변수
//
// 클래스 변수(class variable = static variable)
// - 클래스가 로딩될 때 준비되는 변수
//
// 로컬 변수(local variable)
// - 블록을 실행할 때 준비되는 변수
//
// 파라미터(parameter)
// - 메서드의 아규먼트를 받는 로컬 변수이다.
//   예) 위의 코드에서 main()의 args 로컬 변수
//


1. 값.println(값)
2. 



system.out.println()

system
도구함(class)

out
변수(field)

println
작업자=연산자(method=function)

()
파라미터



system.out.println("번호: " + no)
=>

과정 (Optimizing)
"번호: " + "1"

결과
번호: 1


System.out.printf("번호: %d\n", no);

printf
문자열과 

String levelTitle;
switch (level) {
  case 0: levelTitle = "비전공자"; break;
  case 1: levelTitle = "준전공자"; break;
  default : levelTitle = "전공자";
}

System.out.printf("전공: %s\n" , levelTitle);


<strong>키보드 입력</strong>


Scanner KeyScanner = new Scanner(System.in);

new Scanner
-파라미터로 주어진 입력장치에서 데이터를 읽는 일을 하는 객체
-> 키보드에서 읽은 바이트를 가공한 문자데이터(UTF-16)

(System.in)
-키보드정보 :
사용자가 키보드의 키를 눌렀을때 어떤 키를 눌렀고 이때
caps lock의 상태가 무엇이며, shift키의 상태는 무엇인지

keyScanner.nextLine()
-keyScanner(값) 의 문자정보를 받아서 사용자가
enter를칠때 까지 한줄의 문자열을 만든후 리턴
한다

keyScanner (맨앞 소문자)
-값

nextLine()
-값을 사용해서 작업수행


Integer.parseInt (문자열값)

Integer (맨앞 대문자)
-도구함


**** 객체 = 데이터(값) 이  저장된 메모리****

외부 호출자에게 작업결과 리턴 <= 객체.매서드(파라미터,파라미터)

객체에 값을 사용,저장할 수 있고 파라미터의 값을 사용하여
외부 호출자에게 작업 결과를 리턴할 수 있다

</pre>
<br>
<hr>
<br>
<h1>2022-12-30</h1>
<br>
<br>
<pre>
<strong>Date 클래스</strong>


1.
java.sql.Date today = new java.sql.Date(System.currentTimeMillis());
String createdDate = today.toString();

-toString 가 사용하는 도구함은  java.sql.Date 이다


currentTimeMillis
- OS의 시간 데이터를 읽어서 long타입의 정수값(1970년1월1일 0시 0분 0초 이후 경과된 시간)
으로 today = new Date()에게 리턴한다

-> 년,월,일, 데이터 생성 

=> today.toString() yyyy-MM-dd 로 리턴


2.

Date today = Date(System.currentTimeMillis());
String createdDate = today.toString();

에서 Date를 사용하고 싶다면 eclipse에서 해당 코드에
커서를 두고 ctrl + shift + O 를 하면 

java.sql.Date
java.util.Date

어떤것을 사용할것인가 나온다 해당 도구함을 선택하면
자동으로 import 로 추가해 준다

import java.sql.Date;


<strong>배열의 사용법</strong>


if (str.equals("Y")) {
  break;
}

비교할때
자바에서는 = 은 불가능
equals를 써줘야한다


Scanner keyScanner = new Scanner(System.in);{
  .
  .
}
keyScanner.close();

위와 같이 열고닫아야하는 메서드가 있다

<strong>메서드 사용법</strong>

method 
-기능단위로 코드로 묶는 문법
-재사용이쉽다
-코드가 블록 단위로 정리되어 유지보수가 쉽다
-

다른 메서드에서 선언한 변수는 접근불가

static을 이용하면 접근가능


<strong>클래스 사용법</strong>


1.메서드 분류하기 -> class 문법

class App {
  main(){}
  InputMembers(){}
  promptMember(){}
  promptString(){}
  promptInt(){}
}


<strong>클래스 사용법 II</strong>


int no;
String name;
String tel;
String postNo;

=> 
회원 정보를 담을 새 데이터 
타입을 정의 

class Member {
  
int no;
String name;
String tel;
String postNo;

}


<strong>클래스로 정의한 새타입의 메모리 준비하기</strong>


Member m(레퍼런스변수) = new Member();

- new 명령으로 준비하는 배열은 자동으로 초기화 된다
- m의 주소에 있는 값들을 instance라고 한다
- 주소를 저장한 변수에 0을 넣고 싶다면 null키워드를 사용한다
- null 은 문자열이 아니다 

값을 넣을때는 

m.no = 100;
m.name = "홍길동";


Member m2 = new Member();
m2에 맞는 메모리에 주소와 instance가 준비

=> 

Member 의 인스턴스 
Member의 객체 


<strong>키보드 입력, 변수, 조건문 ,반복문</strong>

main 

-int,byte,boolean,String
-Scanner,System
-

4. 배열
배열
for(),반복문,break

5. 메서드 사용법

main()

inputMembers(){}
  promptString
  promptInt
promptMembers(){}

클래스 사용법

main()

MemberHeandler
inputMembers(){}
  promptString    
  promptInt


promptMembers(){}
  inputString
  inputInt


<strong>GRASP 패턴</strong>
OOP의 일반적인 설계지침

1. Information Expert
2. Low Coupling
3. High cohesion


<strong>자습하기</strong>

1. git\bitcamp-ncp-teacher\myapp\app-04 

- myapp 
- gradle eclipse
- eclipse에서 f5번

클래스 나누기 연습

ex07,09 보기


</pre>
<br>
<hr>
<br>
<h1>2023-01-02</h1>
<br>
<br>
<pre>
<strong>메소드 활용</strong>
1. 주석이 필요없이 메소드 네임을 보면 직관적으로 내용을 알수있다
2. 관리하기 쉽고 재사용하기 편하게 묶는 문법


<strong>파라미터와 아규먼트</strong>


int plus(int a, int b) <- 파라미터 {
  return atb;
}

int plus(int a, int b) 
-메서드 시그너처


{
  return atb;
}
-메서드 바디


int result = plus(100, 200) <- 아규먼트;


파라미터가 없을경우 아규먼트도 넘길수 없다 
컴파일 오류!!


static String hello() {
  return "안녕하세요";
}

리턴값이 있을경우 return은 맨 아래로해야한다 
return까지만 실행하기 때문


static void hello(String... names) {
  for (int i = 0; i < names.length; i++) {
    System.out.printf("%s 님 반갑습니다.\n", names[i]);
  }
}

가변 파라미터는 각각의 파라미터로 받아도되고 
배열로 받아도 된다 

배열로 넘길 경우 배열의 주소를 넘기기 때문에 
내용을 바꾸면 바뀐다   

->
hello("홍길동", "임꺽정", "유관순");
//String[] temp = {"홍길동", "임꺽정", "유관순"};
// hello(temp);

-위처럼 넘길경우 주석에있는 과정을 거쳐 넘긴다


static void m2(int a, String... names) {} // OK!
// - 메서드에 가변 파라미터는 한 개만 사용할 수 있다.
// - 가변 파라미터는 반드시 맨 뒤에 와야 한다.


*블루스크린이 발생하는 이유* 
device driver 가 하드웨어에 직접 접근하려 햇을때 발생한다


<strong>call by value</strong>

static void swap(int a, int b) {
  System.out.printf("swap(): a=%d, b=%d\n", a, b);
  int temp = a;
  a = b;
  b = temp;
  System.out.printf("swap(): a=%d, b=%d\n", a, b);
}

a와 b의 위치를 바꿔줌

<strong>call by value 와 메모리 상태</strong>


method Area
실행할 클래스 코드가 놓인다
자바의 모든 byte코드를 이곳에 구조화 시켜 보관한다


stack
스텍프레임 안에 호출메소드의 로컬변수를 놓인다
메소드 호출이 끝나면 제거된다
-> 호출이 끝나지 않고 계속 쌓이면 stackoverflow가 발생

Heap
new 명령으로 만든 인스턴스 변수가 놓인다


-> jvm이 종료되면 메모리를 회수한다


<strong>call by reference 와 객체</strong>


1. 클래스 로딩

2. main()호출 (stack)
-args
-ref

3.new MyObject(); 메모리 설계도,fata type,class 
- myobject 클래스 로딩
- myobject 설계도에 따라 변수 준비

4.인스턴스변수에 값저장

5. swap() 호출

6. main()에 return과 호출 끝

7. JVM종료


<strong>reference 리턴하기</strong>


public class Exam0340 {

  // swap()에서 만든 int a와 int b의 값을 main()에서 사용하기
  // primitive data type 값을 객체에 담아 넘겨라!

  static class MyObject {
    int a;
    int b;
  }

  static MyObject swap(int a, int b) {
    MyObject ref = new MyObject();  // Heap에 인스턴스 변수를 생성한다 swap메소드가 
    ref.a = b;                      // 종료하더라도 인스턴스 변수는 남아있다, stack은 사라진다
    ref.b = a;
    return ref;
  }

  public static void main(String[] args) {
    int a = 100;
    int b = 200;

    MyObject ref = swap(a, b);

    System.out.printf("main(): ref.a=%d, ref.b=%d\n", ref.a, ref.b);
  }
}


<strong>스텍 메모리 응용 재귀호출</strong>

static int sum(int value) { 
  if (value == 1)
    return 1;

  return value + sum(value - 1);
}
main() -> args 

sum(18289)

// JVM Stack 메모리의 사용
// 0) 시작
// 1) main()
// 2) main() => sum(5)
//           => 5 + sum(4)
//                  => 4 + sum(3)
//                         => 3 + sum(2)
//                                => 2 + sum(1)
//                                       => 1
// 3) main()
// 4) 종료!


public static void main(String[] args) {
  // 호출하는 메서드의 로컬 변수 메모리가 많을 때는 스택 메모리가 빨리 찬다.
  // => 즉 스택 오버플로우는 메서드 호출 회수에 영향을 받는 것이 아니라,
  //    메서드에서 생성하는 로컬 변수의 크기에 영향을 받는다.
  System.out.println(sum(9000, 0, 0, 0, 0, 0));
}
}


<strong>main() 메서드</strong>

java Exam0520 aaa-bbb-ccc


// # 프로그램 아규먼트(arguments)
// - 프로그램을 실행할 때 넘겨주는 값.
// - 어떻게 아규먼트를 넘기는가?
//
// $ java 클래스명 값1 값2 값3
//
// - 아규먼트는 공백으로 구분한다.
// - JVM은 아규먼트의 개수만큼 문자열 배열을 만들어 저장한다.
// - 아규먼트가 없으면 빈 배열을 만든다.
// - 그런후 main()을 호출할 때 그 배열의 주소를 넘겨준다.

java -cp ./bin/main -D이름=값 -D이름=값 -D이름=값 com.eomcs.basic.ex07.Exam0610

앞에 넣으면 JVM아규먼트 
-Da=ok 


<strong>변수</strong>


class A {
  static int v1;      <- 클래스(변수,필드) = 스테틱(변수)
  int v2;             <- 인스턴스 필드 = 논스테틱필드
  void m(int v3) {    <- 로컬변수 = 파라미터     
    int v4;           <- 로컬변수
  }
}


-클래스변수는 클래스 로딩시 Method Area 영역에 생성된다

-인스턴스필드는 new명령 실행시 Heap 영역에 생성된다

-로컬변수는 메서드 호출시 JVM stack 영역에 생성된다

</pre>
<br>
<hr>
<br>
<h1>2023-01-03</h1>
<pre>
<strong>클래스 사용법</strong>

// 1) 클래스 문법으로 성적 데이터를 저장할 메모리 구조를 설계한다.
// [클래스]
// - 다양한 타입의 메모리를 묶어서
//   새로운 형태의 메모리를 설계하는 문법이다.
// - 개발자가 새롭게 정의한 데이터 타입이다.
// - 그래서 "사용자 정의 데이터 타입" 이라 부른다.
// - 문법:
//      class 새_데이터_타입_이름 {
//        변수 선언;
//        ...
//      }

// [새_데이터_타입의_이름]
// - 대문자로 시작한다.
// - 여러 단어가 결합된 이름인 경우 각 단어의 시작도 대문자로 작성한다.
// - 보통 명사형으로 짓는다.


<strong>클래스 문법의 용도</strong>

1. 메서드를 분류
: MemberHeandler
prompt

2. 새 데이터 타입을 정의
class Score {
  String name;
  int kor;
  int eng;
  int math;
  int sum;
  float aver;
}

Score obj;
-> score의 인스턴스 주소를 저장(reperence)

obj = new Score();
-> 설계도에 따라 변수를 Heap 영역에 만든다

String name;
int kor;
int eng;
int math;
int sum;
float aver;
->
Score의 인스턴스(instance) = 인스턴스 변수 (instance field)

인스턴스에 값 저장
obj.name = "홍길동";

obj는 객체의 주소를 가리킨다


클래스 정의의 위치 

1. 클레스가 동동한 위치에 있다면 접근가능 (package 맴버)

2. test 만 쓸 class를 내부에 만들어 사용 다른곳에서 접근 불가 (중첩 클래스)
(이렇게 내부에 사용할 클래스를 지정하면 유지보수가 좋다
혼자사용하는 클래스를 밖에 두면 어디 사용하는 건지 직관성이 좋지 않음)

class Test {
  class Score{}
  void m1(){}
  void m2(){}
}
class Test2{}
class Test3{}


3. m1 메소드만 사용할 클래스 (지역 클래스)

class Test{
  void m1() {
    class Score{}
  }
  void m2(){}
}
class Test2{}
class Test3{}


<strong>메서드에서 인스턴스 생성 후 리턴</strong>


createScore(string name, int kor, int eng, int math) {
  Score S = new Score();
  s.name = name;
  s.kor = kor;
  s.eng = eng;
  s.math = math;
  return s;
}

Score s = createScore("홍길동",100,100,100);


<strong>레퍼런스 배열 사용 전</strong>


Score s1,s2,s3;

s1 = new Score();
s2 = //
s3 = //

// 수 십 개의 인스턴스를 저장한다면
// 레퍼런스도 그 개수에 맞춰 선언해야 한다.
// 코딩하기가 매우 불편하다.
// 만약 수 백 개라면 더더욱 불편할 것이다.
// 해결책?
// - 레퍼런스를 배열로 만드는 것이다.

Score[] scores = new Score[1000];
score[0] = new Score(); // 객체를 한번에 만들려면 반복문을 사용해야한다


<strong>레퍼런스 배열 사용 후</strong>

Score[] scores = new Score[3];

// 배열 레퍼런스에 레퍼런스 배열을 담는다 
// 이렇게 사용할경우 레퍼런스들을 하나하나 생성할 필요가 없다


public class Exam0240 {

  // 여러 메서드에서 공유하려면 클래스를 메서드 밖에 선언해야 한다.
  // => static 메서드들이 사용할 수 있게 클래스도 static으로 선언한다.
  // => static에 대한 의미는 나중에 설명한다.
  //
  static class Score {
    String name;
    int kor;
    int eng;
    int math;
    int sum;
    float aver;
  }

  public static void main(String[] args) {

    Score[] arr = new Score[3];

    // 메서드에서 생성한 Score 객체를 레퍼런스 배열의 각 항목에 저장한다.
    arr[0] = createScore("홍길동", 100, 100, 100);
    arr[1] = createScore("임꺽정", 90, 90, 90);
    arr[2] = createScore("유관순", 80, 80, 80);

    // 메서드에 배열을 통째로 넘길 수 있다.
    // => 정확하게 표현하면, arr 변수에 저장된 레퍼런스 배열의 주소를 넘긴다.
    printScoreList(arr);

  }

  // 클래스를 이용하면 성적 정보를 하나로 묶어 리턴할 수 있다.
  // 참고!
  // - 다음과 같이 메서드를 통해 인스턴스를 생성하는 코딩 기법을 
  //   "팩토리 메서드(factory method)" 패턴이라 부른다.
  static Score createScore(String name, int kor, int eng, int math) {
    Score s = new Score();

    s.name = name;
    s.kor = kor;
    s.eng = eng;
    s.math = math;
    s.sum = s.kor + s.eng + s.math;
    s.aver = s.sum / 3f;

    return s;
  }

  static void printScoreList(Score[] arr) {
    // main()에서 넘겨준 레퍼런스 배열의 주소를 arr 변수에 받는다.
    // 결국 main()에서 만든 레퍼런스 배열을 사용하는 것이다.
    //
    for (int i = 0; i < arr.length; i++) {
      System.out.printf("%s: %d, %d, %d, %d, %.1f\n",
          arr[i].name, arr[i].kor, arr[i].eng, arr[i].math, arr[i].sum, arr[i].aver);
    }
  }
}


<strong>garbage(가비지)</strong>


//# 레퍼런스와 인스턴스 - 가비지
//
public class Exam0320 {
  public static void main(String[] args) {
    class Score {
      String name;
      int kor;
      int eng;
      int math;
      int sum;
      float aver;
    }

    // Score 레퍼런스 선언
    Score s1;

    // 인스턴스를 만들어 그 주소를 레퍼런스에 저장한다.
    s1 = new Score();
    s1.name = "홍";
    System.out.println(s1.name); // "홍"

    // 새 인스턴스를 만들어 s1에 주소를 저장한다.
    s1 = new Score();
    System.out.println(s1.name); // null

    // 그러면 기존에 들어 있던 주소는 잃어 버린다.
    // 주소를 잃어버려 사용할 수 없는 메모리를
    // "가비지(garbage)"라 부른다.

    // 가비지는 가비지 컬렉터에 의해 메모리에서 해제된다.
    // 가비지 컬렉터(garbage collector)의 실행
    // - 메모리 부족할 때
    // - CPU가 한가할 때
    // - System.gc()를 호출하여 가비지 실행을 요청할 때
    //   물론 이 경우에 바로 실행하는 것이 아니라
    //   빠른 시간 내에 실행할 것을 종용하는 것이다.
    //   아무래도 원래의 시간보다는 앞 당겨 청소를 하게 될 것이다.

  }
}

// ## 가비지 컬렉터(garbage collector)
// - 힙 메모리에 존재하는 가비지를 찾아 제거(?)하는 일을 한다.
// - 다른 용도로 사용할 수 있도록 메모리를 해제하는 일을 한다.
//
// ## 언제 작업하는가?
// - JVM이 관리하는 메모리가 부족할 때
// - CPU가 한가할 때


<strong>인스턴스와 레퍼런스 카운트</strong>


Score s1 = new Score();
Score s2 = new Score();

s2 = s1;
// s1의 주소는 s2에도 저장되었다.
// 즉 s1이 가리키는 객체는 s2도 가리키게 되었다.
// JVM은 객체의 참조 상태를 관리하기 위해 "레퍼런스 카운트(reference count)"를 이용한다.
// s1이 가리키는 객체처럼 주소를 알고 있는 변수가 늘어나면 레퍼런스 카운트를 증가시키고
// s2이 이전에 가리켰던 객체처럼 주소를 알고 있는 변수가 줄어들면 레퍼런스 카운트를 감소시킨다.
// 레퍼런스 카운트가 0인 상태가 "가비지(garbage)"이다.


//# 패키지 클래스 
// - 다른 클래스 안에 선언되지 않고 별도로 선언된 클래스를 "패키지 클래스"라 부른다.
// - 한 소스 파일에 여러 개의 클래스를 정의할 수 있지만,
//   유지보수를 쉽게 하기 위해 보통 한 소스 파일에 한 클래스를 정의한다.
// - 패키지 클래스란? 패키지에 직접 소속된 클래스라는 의미다.
// - 이전에 만든 Score 클래스는 main() {} 블록 안에 정의하였다.
//   main() {} 블록 안에 정의한 클래스는 
//   main() {} 블록 안에서만 사용할 수 있다.
//

// 패키지 멤버 클래스
// - 단독으로 선언하는 클래스이다.
// - "패키지 멤버 클래스"라 부른다.
// - 물론 이 예제처럼 한 파일에 여러 개의 클래스를 선언할 수 있지만,
//   보통은 한 파일에 한 클래스를 선언한다.
// - 패키지 멤버 클래스는 접근 권한이 있다면 누구든 사용할 수 있다.
//


<strong>public클래스와 default 클래스 </strong>

public은 다른 패키지에서 접근가능 default는 (package private class)
다른 패키지에서 접근불가  


<strong>import 사용전</strong>


package com.eomcs.oop.ex01;

// # import : 사용 전
//
public class Exam0710 {
  public static void main(String[] args) {

    // 다른 패키지의 클래스 사용
    // => 패키지 이름을 항상 붙여야 한다.
    //    그래야만 컴파일러가 해당 클래스를 찾을 수 있다.
    // => 패키지 전체 이름을 붙여야 한다.
    // => 현재 패키지를 기준으로 상대 경로를 사용할 수 없다.
    //    예) sub.Y2 obj = new sub.Y2(); // 컴파일 오류!
    //
    com.eomcs.oop.ex01.sub.Y2 obj;
    obj = new com.eomcs.oop.ex01.sub.Y2();

  }
}


package com.eomcs.oop.ex01;

// # import : 사용 후
//
// - import 명령은 package 명령 다음에 와야 한다.
// - 클래스 선언 전에 와야 한다.
import com.eomcs.oop.ex01.sub.Y2;

public class Exam0720 {
  public static void main(String[] args) {

    // 다른 패키지의 클래스를 사용할 때 마다
    // 패키지명을 적는다면 코드가 너무 길어진다.
    //
    // 이를 해결하기 위해 자바는 import 라는 명령을 제공한다.
    // 클래스를 사용하기 전에 미리 해당 클래스가 어느 패키지에 있는지 지정하는 것이다.
    // 문법:
    //      import 패키지명.클래스명;
    //
    Y2 obj;
    obj = new Y2();
  }
}


package com.eomcs.oop.ex01;

// # import - 사용 후 II
//
import com.eomcs.oop.ex01.sub.*;
import java.util.*; 
import java.net.*;
import java.io.*;

public class Exam0730 {
  public static void main(String[] args) {

    // 특정 패키지에 소속된 여러 클래스를 사용한다면 
    // 다음과 같이 패키지명 다음에 wildcard(*)를 지정하면 편리하다.
    // 문법:
    //      import 패키지명.*;
    //
    // - 이 경우 사용하는 클래스 마다 import를 따로 지정할 필요가 없다.
    // - (주의!) 서브 패키지는 해당이 안된다.
    // - 단 소스 코드를 읽을 때 어떤 클래스가 어떤 패키지 있는지 바로 확인할 수 없는 불편함이 있다.
    //   그래서 대부분의 자바 개발자들은 널리 알려진 클래스가 아닌 경우
    //   가능한 wildcard(*)를 사용하지 않고 패키지명과 클래스명을 정확하게 명시한다.
    //
    Y2 obj;
    obj = new Y2();

    Z2 obj2;
    obj2 = new Z2();
  }
}
// 결론!
// - 가능한 import 문을 선언할 때 * 대신 구체적인 클래스명을 적어라!
// - 같은 패키지의 여러 클래스를 사용하더라도 귀찮지만 클래스명을 적어라!
// - 왜?
//   소스 코드를 읽을 때 어떤 클래스가 어떤 패키지에 있는지 빠르게 파악할 수 있기 때문이다.
//   wildcard(*) 를 사용하게 되면 어떤 패키지인지 바로 확인할 수 없다.
//


java.lang.Integer obj1; // OK!
java.lang.System obj2; // OK!
java.lang.reflect.Array obj3;
java.io.File obj4; // OK!

Integer obj5; // OK!
System obj6; // OK!
//    Array obj7; // 컴파일 오류!
//    File obj8; // 컴파일 오류!

// java.lang 패키지에 있는 클래스는 패키지를 지정하지 않아도 된다.
// 즉 패키지명을 명시하지 않아도 컴파일 오류가 발생하지 않는다.
// 그 외 다른 모든 패키지의 클래스는 패키지명을 명시하지 않으면
// 컴파일 오류가 발생한다.
}
}

// 결론!
// - java.lang 패키지에 소속된 클래스를 사용할 때는
//   패키지 이름을 명시하지 않아도 된다.
// - 주의!
//   - java.lang 패키지의 하위 패키지는 해당되지 않는다.
//   - 예) java.lang.annotation, java.lang.invoke 등
// - java.lang 패키지의 클래스들은 가장 많이 사용하는
//   기본 클래스이기 때문에 자바 컴파일러는 해당 클래스를 자동으로 찾는다.
// - 그 외의 모든 패키지 클래스들은 반드시 패키지명을 지정해야 한다.
// - 지정하기 싫으면 클래스 선언 전에 import 명령으로 패키지를 지정해야 한다.



package com.eomcs.oop.ex02;

//0) 낱개 변수 사용
//1) 성적 데이터를 저장할 사용자 정의 데이터 타입을 만든다.
//2) 리팩토링: 메서드 추출(extract method), static nested class
//3) 리팩토링: 메서드 추출(extract method) = 한 개의 메서드는 한 개의 기능을 수행해야 한다.
//4) GRASP(General Responsibility Assignment Software Patterns) 패턴 
//     => Information Expert: 데이터를 다룰 때는 그 데이터를 갖고 있는 객체에게 묻는다.
//   리팩토링: 메서드 이동(Move Method)
//     => 메서드를 관련된 클래스로 이동시킨다. => 코드의 이해가 쉽다.
// 
public class Exam0140 {

  static class Score {
    String name; 
    int kor;
    int eng;
    int math;
    int sum;
    float aver;

    // 메서드를 이용하여 이 타입의 데이터를 다룰 수 있는 연산자를 정의한다.
    // - 사용자 정의 데이터 타입 입장에서는 메서드가 연산자 역할을 한다.
    // - 즉 사용자 정의 데이터 타입에 메서드를 정의하는 것은
    //   그 데이터를 다룰 연산자를 정의하는 것이다.

    // Score 데이터 값을 다룰 수 있는 새 연산자를 정의해 보자.
    // - 다음 메서드는 Score 객체의 국,영,수 값의 합계와 평균을 계산하는 연산자이다.
    static void compute(Score s) {
      s.sum = s.kor + s.eng + s.math;
      s.aver = (float) s.sum / 3;
    }
    // 클래스 메서드
    // - static이 붙은 메서드이다.
    // - 특정 인스턴스에 대해 사용하는 것이 아니라, 모든 인스턴스에 대해 사용할 수 있다.
    // - 특정 인스턴스의 값을 다루고 싶다면 파라미터로 그 인스턴스의 주소를 받아야 한다.
  }

  public static void main(String[] args) {

    Score s1 = new Score();

    s1.name = "홍길동";
    s1.kor = 100;
    s1.eng = 90;
    s1.math = 85;

    // 다음은 Score의 값을 다루는 연산자가 없을 때의 예이다.
    // core.sum = score.kor + score.eng + score.math; 
    // score.average = score.sum / 3f;

    // 사용자 정의 데이터 타입의 값을 연산자를 사용하여 다뤄보자!
    Score.compute(s1);

    printScore(s1);

    Score s2 = new Score();
    s2.name = "임꺽정";
    s2.kor = 90;
    s2.eng = 80;
    s2.math = 75;
    Score.compute(s2);
    printScore(s2);

    Score s3 = new Score();
    s3.name = "유관순";
    s3.kor = 80;
    s3.eng = 70;
    s3.math = 65;
    Score.compute(s3);
    printScore(s3);
  }

  static void printScore(Score s) {
    System.out.printf("%s: %d, %d, %d, %d, %.1f\n", 
        s.name, s.kor, s.eng, s.math, s.sum, s.aver);
  }


}
</pre>
<br>
<hr>
<br>
<h1>2023-01-04</h1>
<br>
<br>
<pre>

  //0) 낱개 변수 사용
  //1) 성적 데이터를 저장할 사용자 정의 데이터 타입을 만든다.
  //2) 리팩토링: 메서드 추출(extract method), static nested class
  //3) 리팩토링: 메서드 추출(extract method) = 한 개의 메서드는 한 개의 기능을 수행해야 한다.
  //4) GRASP(General Responsibility Assignment Software Patterns) 패턴
  //5) 인스턴스 메서드: 인스턴스 주소를 받는 더 쉬운 문법
  //6) 패키지 멤버 클래스
  //7) 클래스를 역할에 따라 패키지로 분류
  //8) 생성자 도입: 인스턴스를 생성할 때 값을 초기화시키는 특별한 메서드

<strong>래퍼런스와 인스턴스</strong>

레퍼런스
-> 각 메모리 영역을 참고
-> 인스턴스의 주소


인스턴스
-> new
-> Heap
-> garbage
-> garbage collector
-메모리가 부족할때 , 한가할때


<strong>리팩토링</strong>

GRASP의 information Expert

1메소드 1기능
->
static void printScore(Score s) {
  
}

->
클레스에 관련있는 메소드를 넣어서 직관적으로 관리한다

->
인스턴스에 더 쉽게 접근하는 법


<strong>인스턴스에 더 쉽게 접근하는 법</strong>

1. static 메서드 =  클래스 메서드

Score.compute(s1);

Score: 메서드가 소속된 클래스 

(s1): 파라미터 값


2. 인스턴스(non-static) 메서드

-인스턴스 주소를 앞,뒤 에 받을 것인가 차이
-사용시 반드시 앞에 데이터를 줘야한다
-해당 메소드가 소속한 class의 정보만줄 수 있다

예)
Score.compute(s1); X
보다는
s1.compute(); O
가 직관적


<strong>인스턴스 메서드와 this</strong>


s1.compute();

/*(static)*/ void vompute() {
  this.sum = this.kor......
}

this
-메소드를 호출할 때 앞쪽에서 넘겨준 인스턴스
주소를 받는 built-in 로컬 변수 
=> non-static 메서드에만 존재한다

-인스턴스 주소는 this 내장변수에 자동 저장된다
=> 인스턴스 주로를 받기 위해 따로 변수를 선언할 필요가 없다


<strong>패키지 멤버 클래스</strong>
클래스는 public 또는 default(안붙이는것) 두가지 형태 뿐이다 

1. 같은패키지에 있다면 public으로 공개하지 않아도 된다

2. 다른 패키지의 메소드,클래스,를 사용 하려면 public으로 공개해야 한다 

domain (VO = dto) 데이터타입
- ex02의 하위패키지 


<strong>객체 초기화 문법</strong>

Exam0180
main
printScore()

Score2
name
kor,eng,math,sum,aver
compute()
Score2() <- 생성자(constructor)


생성자

public Score {
  리턴값이 없다 Score 반드시 클래스이름과 같아야한다 (파라미터,...) {

  }
}


사용전

Score s = new Score();
s.name = ""
s.kor = 100;


사용후

Score s = new Score("",100);
=> 인스턴스 생성후 즉시 생성자 자동호출
Score(String n, int k,int e, math m){
  this.name = n;
  this.kor = k;

  this.compute(); // 클래스 문법으로 data(name,kor,eng,math,sum,aver)를 정의하고
                  // 해당 데이터를 다루는 전용 operator 
}

Score 설계도에 따라 인스턴스 생성
=> 생성자 호출

Score s1 = new Score("이순신", 100, 100, 100);
  printScore(s1);

</pre>
<br>
<hr>
<br>
<h1>2023-01-05</h1>
<pre>
<strong>스태틱 필드 -> 인스턴스 필드</strong>


1. 메소드 분류전 Exam 0210




// # 관련된 기능(메서드)을 묶어 분류하기
// 1) 분류 전
//

public class Exam0210 {

  public static void main(String[] args) {
    // 다음 식을 연산자 우선 순위를 고려하지 않고 순서대로 계산하라!
    // 2 + 3 - 1 * 7 / 3 = ?

    // 계산 결과를 담을 변수를 준비한다.
    int result = 0;

    // 메서드를 호출하여 작업을 수행하고,
    // 리턴 결과는 로컬 변수에 저장한다.
    result = Exam0210.plus(2, 3);             
    result = minus(result, 1);                
    result = multiple(result, 7);
    result = divide(result, 3);

    System.out.printf("result = %d\n", result);
  }

  static int plus(int a, int b) { 
                                  
    return a + b;
  }

  static int minus(int a, int b) {
    return a - b;
  }

  static int multiple(int a, int b) {
    return a * b;
  }

  static int divide(int a, int b) {
    return a / b;
  }
}

// 클래스 문법의 용도? 
// 1) 사용자 정의 데이터 타입 만들 때
// - 즉 새로운 구조의 메모리를 설계할 때 사용한다.
// 2) 메서드를 묶을 때
// - 서로 관련된 기능을 관리하기 쉽게 묶고 싶을 때 사용한다.


1. 데이터타입정의
name
kor
eng
math


2. 메서드를 묶을 때
calculator {
  plus()
  minus()
  multiple()
  divice()
}


/////////////////////////////


static int abs(int a) {  // 절대값을 리턴해주는 메소드
  //
  // if (a >= 0)
  //   return a;
  // else
  //   return a * -1;
  //
  return a >= 0 ? a : a * -1;
}

public static void main(String[] args) {
  // 다음 식을 연산자 우선 순위를 고려하지 않고 순서대로 계산하라!
  // 2 + 3 - 1 * 7 / 3 = ?

  // 계산 결과를 담을 변수를 준비한다.
  int result = 0;

  // 클래스 메서드를 호출하여 작업을 수행하고,
  // 리턴 결과는 로컬 변수에 저장한다.
  result = Calculator.plus(2, 3);
  result = Calculator.minus(result, 1);
  result = Calculator.multiple(result, 7);
  result = Calculator.divide(result, 3);

  // 스테틱 메소드는 앞에 class이름을 붙여야한다
  // 하지만 같은 클레스에 소속 하고 있다면 생략 가능

  System.out.printf("result = %d\n", result);
}

GRASP 패턴 - information Export
계산을 수행하는 클래스에서 결과를 관리하는 것이 옳다
->
main메소드에 소속해있던 result를 calculator로 이동


<strong>클래스 변수의 한계</strong>


calculator
result

static 변수로 클래스 당 한개만 존재


해결
->

// 인스턴스 변수(= non-static 변수)
// - 작업 결과를 개별적으로 관리하고 싶을 때 인스턴스 변수로 선언한다.
// - 인스턴스 변수는 클래스가 로딩 될 때 만들어지지 않는다.
// - new 명령을 사용해서 만들어야 한다.
// - 변수 선언 앞에 static이 붙지 않는다.
int result = 0;


// 두 개의 식을 동시에 계산하고 싶은가?
// 그럴려면 계산 결과를 개별적으로 관리할 수 있어야 한다.
// 다음과 같이 각 식의 계산 결과를 보관할 메모리를 준비한다.
Calculator c1 = new Calculator(); // 식1의 계산 결과를 보관할 메모리 준비
Calculator c2 = new Calculator(); // 식2의 계산 결과를 보관할 메모리 준비


// 계산을 수행할 때 계산 결과를 보관할 메모리를 전달한다.
Calculator.plus(c1, 2); // + 2
Calculator.plus(c2, 3); // + 3


인스턴스 변수를 사용하는경우 메소드도 인스턴스로 바꾸면
this로 접근이 가능하다 하지만 인스턴스 변수를 사용하지 
않을 경우 static으로 두면 된다

void divide(int value) {
  this.result /= value;
}

// 인스턴스를 사용하지 않는 메서드라면 그냥 클래스 메서드로 두어라.
static int abs(int a) {
  return a >= 0 ? a : a * -1;
}

그리고 main메소드에서 사용하기위해 서는 앞쪽에 주소를 
받고 값을 넘긴다

// 계산을 수행할 때 계산 결과를 보관할 메모리를 메서드 호출 앞에서 전달하라!
// - 인스턴스 메서드를 사용하면 파라미터로 메모리 주소를 전달할 필요가 없다.
c1.plus(2); // + 2
c2.plus(3); // + 3


<strong>Nested 클래스 -> packageMember 클래스 -> 패키지 분류</strong>

중첩클래스 (Nested)
->
class{
  class{
    main{

    }
  }
}

동일한 패키지 안에서 사용 (packageMember)
->
ex02{
  class{

  }
  class{

  }
}

패키지 분류
->
ex02{
  class{

  }
}
ex03
{
  class{

  }
}


<strong>JVM 메모리 영역과 변수, 메서드</strong>


void main() {
  Calculator c1 = new Calculator();
  .
  .
}



*Method Area*

Ex0280{
  bytecode
    클래스 정의
    메소드 정의
    변수 정의
}

Calculator.class{
  result 변수 선언문
  plus(){} 인스턴스 메소드
  minus(){} 인스턴스 메소드
  ads(){} 클래스 메서드
}


*JVM Stack*

main(){
  args
  c1
}

plus(){
  value: 2
  this: 인스턴스 주소
}

*Heap*


<strong>스태틱변수, 인스터스변수 ,로컬변수</strong>

class Exam0100{
  static int a;   <- 스테틱필드 = 클래스가 로딩될 때 생성 
  int b;          <- 인스턴스필드 = new 명령 실행할 때 생성
  vois main(){
    int c;        <- 로컬 변수 = 메서드가 호출될 때 생성 
    .
    .
    Exam0100 obj;
    obj = new Exam0100(); 
  }
}


</pre>
<br>
<hr>
<br>
<h1>2023-01-06</h1>
<pre>

<strong>스태틱 메서드 vs 인스턴스 메서드</strong>


스태틱 메서드

-문자열을 다루는 일반적인 기능을 수행
-값을 파라미터로 받는 형식

String.format("%s님 환영", "홍길동");
=> 클래스.메서드(값,값...)


인스턴스 메서드

-특정 객체에 대해 작업을 수행
-메모리에 저정된값을 사용하여 작업을 수행

String str = "abcde"
str.charAt(3);
=>메모리.메서드(값,값....)


<strong>클래스를 복제하는 방식으로 메뉴 추가하기</strong>


MemberHandler
Member2Handler
Member3Handler


온프레미스
-기업의 서버를 자체적으로 서버를두고 데이터를 운영하는 방식

문제점
-기능을 추가할때 모든 클래스에 변경해야한다
-버그 발생 시 복제한 모든 클래스에 대해 변경해야한다
=> 유지보수가 힘들다


<strong>스태틱 멤버 -> 인스턴스 멤버, 생성자 도입</strong>


생성자 
-인스턴스 생성에 필요한 값을 받는다
-인스턴스 사용전 유효값을 로 채운다

인스턴스 필드 
-개별적으로 다뤄야할때

인스턴스 메서드
-인스턴스 멤버 사용(필드,메서드)

생성자
-인스턴스 필드에 필수 값 받을 때 유용



과제 - 일요일 저녁 9시 공부내용 ex 03,04,  05(x뺴고) 
 - 게시글 관리 기능을 추가하라!
 - BoardHandler 클래스 정의
 - Board 

1. 입력

번호? 1
제목? 
내용?
암호?


2. 목록

번호 제목 작성일 조회수
1    --    2022  0

3. 조회

번호? 1
제목:
내용:
작성일:
조회수:

4. 변경
5. 삭제


** 조회 수
조회 메소드에서 

if 조회할 게시글이 존재하면 b.viewno 에 +1을 하도록 설정 
그러면 2번 목록을 조회할 경우에도 조회수가 적용된다

문제점 4. 내용을 변경하면 해당 게시글의 조회수까지 초기화 된다
->해결 : 그전에 사용하던 데이터(this.findByNo(memberNo))를 백업(Board old)
  new Board에 b.viewno = old.viewno 로 다시 저장해 준다


** 암호 설정
게시물을 변경할때와 같은 방식으로 암호를 입력 받아 암호가 같지 않으면 접근 불가능

문제점 모든 게시물들의 암호와 한번 지정했던 암호가 남아 있어서 모든 암호가 공유
-> 1차 해결 : 해당 게시물 번호에 저장된 암호가 일치하면 접근할수 있게 변경
--> 2차 해결 : 암호를 다시 설정할 수 없게 변경 



/*
# 기능 추가하기
1) 기존 클래스 파일에 추가하는 방법
  - 기존 코드를 변경하게 되면 원래 되던 기능도 오류가 발생할 수 있는 위험이 있다.
  - 그래서 원래 코드를 손대는 것은 매우 위험한 일이다.
  - 기존에 잘 되던 기능까지 동작이 안되는 문제가 발생할 수 있기 때문이다.

2) 기존 코드를 복사하여 새 클래스를 만드는 방법
  - 장점
    - 기존 코드를 손대지 않기 때문에 문제가 발생할 가능성은 줄인다.
  - 단점
    - 기존 코드의 크기가 큰 경우에는 복사 붙여넣기가 어렵다.
    - 기존 클래스의 소스가 없는 경우에는 이 방법이 불가능하다.
      엥? 다른 개발자가 배포한 라이브러리만 있는 경우를 말한다.
      소스가 없는 다른 개발자가 만든 클래스에 기능을 덧 붙일 때는 이 방법이 불가능하다.
    - 기존 코드에 버그가 있을 때 복사 붙여넣기 해서 만든 클래스도 영향을 받는다.
    - 기존 코드를 변경했을 때 복사 붙여넣기 한 모든 클래스를 찾아 변경해야 한다.
3) 기존 코드를 상속 받아 기능을 추가하는 방법
  - 장점
    - 기존 클래스의 소스 코드가 필요 없다.
    - 간단한 선언으로 상속 받겠다고 표시한 후 새 기능만 추가하면 된다.
  - 단점
    - 일부 기능만 상속 받을 수 없다.
    - 쓰든 안쓰든 모든 기능을 상속 받는다.
 */


// 상속의 실제적인 의미
package com.eomcs.oop.ex05.e;

public class Exam01 {

  public static void main(String[] args) {
    B obj = new B();

    // B 인스턴스를 이용하여 B가 사용권을 획득한 A 클래스의 메서드를 호출할 수 있다.
    obj.m1(); // A 클래스의 m1() 호출

    obj.m2(); // B 클래스의 m2() 호출

    // 실험:
    // bin/main/.../A.class 파일을 제거한 후 다시 실행하라!
    // => 결과는?
    //    A 클래스가 없다고 예외가 발생한다.
    // => 의미?
    //    상속 받는다는 것은 수퍼 클래스의 코드를 그대로 복제해 온다는 것이 아니다.
    //    그냥 수퍼 클래스의 코드를 사용할 수 있는 권한을 획득한다는 것이다.
    //    그래서 서브 클래스를 사용하려면
    //    반드시 서브 클래스가 상속 받는 모든 조상 클래스가 있어야 한다.
    //

  }

}



// 상속과 메서드 호출
package com.eomcs.oop.ex05.e;

public class Exam02 {

  public static void main(String[] args) {
    D obj = new D();

    obj.m4(); // obj 레퍼런스의 클래스에서 m4()를 찾아 호출한다.
    obj.m3(); // obj 레퍼런스의 클래스(D)에서 m3()를 찾아보고 없다면 수퍼 클래스에서 찾는다.
    obj.m2(); // 만약 D의 수퍼 클래스에서도 못찾는다면 그 위의 클래스에서 찾아본다.
    obj.m1(); // 그 위에 클래스에서도 없다면 더 위에 클래스에서 찾아본다.
    //    obj.m0(); // 더 위에 있는 클래스에서도 찾을 수 없다면 컴파일 오류이다!

    // 즉 메서드를 호출할 때는 클래스 상속 관계에 따라
    // 레퍼런스의 클래스에서 시작하여 상위 클래스로 찾아간다.
    // 그래서 클래스를 사용하려면
    // 그 클래스가 상속 받는 상위 클래스들이 모두 있어야 한다.

  }

}



// 상속 - 클래스 로딩과 인스턴스 생성 과정
package com.eomcs.oop.ex05.f;

public class Exam01 {
  public static void main(String[] args) {
    // B 클래스의 설계도에 따라 Heap 영역에 변수를 준비한다.
    // - B 클래스는 A 클래스에 기능을 덧붙인 것이라 선언했기 때문에
    //   A 클래스의 설계도에 따라 A 클래스에 선언된 인스턴스 변수도 함께 생성된다.
    B obj = new B();

    obj.v2 = 200; // B 클래스 설계도에 따라 만든 변수
    obj.v1 = 100; // A 클래스 설계도에 따라 만든 변수

    System.out.printf("v2=%d, v1=%d\n", obj.v2, obj.v1);
    System.out.println("---------------------------------");

    // 클래스는 오직 한 번만 로딩된다.
    // - 그래서 static 블록도 위에서 한 번 실행되면 다시 실행하지 않는다.
    //
    B obj2 = new B();
    obj2.v2 = 2000;
    obj2.v1 = 1000;
    System.out.printf("v2=%d, v1=%d\n", obj2.v2, obj2.v1);

    // B 클래스의 인스턴스 생성 과정
    // 1) B의 수퍼 클래스가 로딩되어 있지 않다면, 수퍼 클래스(A 클래스)를 먼저 로딩한다.
    //    - 스태틱 필드 생성한 후
    //    - 스태틱 블록 실행한다.
    // 2) 그런 후 B 클래스를 로딩한다.
    //    - 스태틱 필드 생성한 후
    //    - 스태틱 블록 실행한다.
    // 3) 인스턴스 필드 생성
    //    - 수퍼 클래스의 인스턴스 필드부터 생성한다.
    //    v1   |    v2    : A의 v1 필드 생성, B의 v2 필드 생성
    //    0    |    0     : 각 필드를 기본 값으로 설정한다.
    //    100  |    0     : A 클래스의 생성자 수행
    //    100  |    200   : B 클래스의 생성자 수행
    //
    // - B 클래스의 인스턴스는 수퍼 클래스의 인스턴스 필드도 포함한다.
    //

    // 인스턴스 생성 절차 정리!
    // 1) 상속 받은 수퍼 클래스를 먼저 메모리에 로딩한다.
    //    이미 로딩되어 있다면 다시 로딩하지는 않는다.
    // 2) 그런 후 해당 클래스를 메모리에 로딩한다.
    //    마찬가지로 이미 로딩되어 있다면 다시 로딩하지는 않는다.
    // 3) 수퍼 클래스에 선언된 대로 인스턴스 변수를 Heap에 만든다.
    // 4) 해당 클래스에 선언된 대로 인스턴스 변수를 Heap에 만든다.
    // 5) 수퍼 클래스부터 생성자를 실행하며 해당 클래스까지 내려온다.

    // 그래서 인스턴스를 생성할 때는 항상 상속 받아야 하는 클래스 파일이 모두 있어야 한다.
    // 테스트 하는 방법?
    // => A.class 파일을 제거하고 실행해 보라!

  }
}

// 용어 정리!
// 상속(inheritance)
// - 기존에 만든 클래스를 자신의 코드처럼 사용하는 기법이다.
// - 보통 기존 코드를 손대지 않고 새 코드를 덧붙일 때 많이 사용한다.
//
// 수퍼클래스(super class) = 부모클래스(parents class)
// - B 클래스 입장에서, B 클래스에게 상속 해주는 A 클래스를 말한다.
//
// 서브클래스(sub class) = 자식클래스(child class)
// - A 클래스 입장에서, A 클래스가 상속해주는 B 클래스를 말한다.
//
// 즉 수퍼 클래스나 서브 클래스는 상대적인 개념이다.




// 상속 - 다중 상속
package com.eomcs.oop.ex05.i;

public class Exam01 {

  public static void main(String[] args) {
    // 만약 C 클래스가 A와 B를 모두 상속 받을 수 있다면,
    // C 클래스의 인스턴스를 만들 때 
    // v2 변수는 A 설계도에 따라 float 메모리를 만들어야 하는가?
    // 아니면 B 설계도에 따라 int 메모리를 만들어야 하는가?
    // 메서드의 경우도 마찬가지이다.
    // 다중 상속이 가능하다고 가정하자.
    // 두 개의 수퍼 클래스에 같은 이름의 메서드가 있을 때,
    // 어떤 메서드를 호출해야 하는가?
    //
    C obj = new C(); // ?

    // 그래서 자바는 클래스의 다중 상속을 지원하지 않는다.

  }

}



// 상속 - Generalization 수행 전
package com.eomcs.oop.ex05.k;

import com.eomcs.oop.ex05.j.Sedan;
import com.eomcs.oop.ex05.j.Truck;

// 상속의 종류
// 1) specialization
//    => 가장 많이 사용하는 방법으로 수퍼 클래스를 상속 받아 서브 클래스를 만드는 것이다.
//    => 수퍼클래스에 새 특징을 추가하거나 새 기능을 추가하여 더 특별한 일을 수행하는 서브클래스를 만든다.
//       그래서 이런 상속을 "특수화/전문화(specialization)"이라 부른다.
// 2) generalization
//    => 리팩토링 과정에 수행하는 방법이다.
//    => 서브클래스들의 공통 분모를 추출하여 수퍼클래스를 정의하는 방법을 말한다.
//    => 그래서 이런 상속을 "일반화/표준화(generalization)"이라 부른다.
//
// Sedan 클래스와 Truck 클래스의 공통 분모를 추출하여 
// Car라는 클래스를 정의하고,
// 두 클래스는 이렇게 새로 만든 Car 클래스를 상속 받도록 한다.
public class Exam01 {

  public static void main(String[] args) {
    // 이렇게 Sedan과 Truck 클래스를 만들어 쓰다가 보니
    // 두 클래스 사이에 공통 코드가 발견되었다.
    // => 유지보수를 쉽게하기 위해 공통 코드를 추출하여 중복 코드를 없앨 필요가 있었다.
    // => 다음 예제를 보라!
    Sedan s = new Sedan();
    Truck t = new Truck();

    s.doSunroof(true);
    t.dump();
  }

}



// 상속 - Generalization 수행 후
package com.eomcs.oop.ex05.l;

// 여러 클래스에 공통으로 들어 가는 기능이나 필드가 있다면
// 유지보수가 쉽도록 별도의 클래스로 추출한다.
// 그리고 상속 관계를 맺는다.
// - Sedan과 Truck 사이에 공통 필드와 메서드가 있다.
//   공통 기능을 추출하여 별도의 클래스를 정의하는 것을 "일반화(generalization)"라 한다.
//
// Sedan과 Truck의 공통 기능인
// start(), shutdown(), run() 메서드를 추출하여
// Car 클래스를 만들고
// Sedan과 Truck은 이 클래스의 서브클래스가 된다.
//
// start()와 shutdown() 은
// Sedan이나 Truck 모두 같은 작업을 수행하기 때문에 상속 받은 것을 그대로 사용하며 되지만,
// run()은 Sedan과 Truck이 서로 다르게 작업하기 때문에 재정의(오버라이딩) 해야 한다.
public class Exam01 {

  public static void main(String[] args) {
    // Sedan과 Truck 두 클래스의 공통점을 추출하여 수퍼 클래스를 정의한 후에
    // 두 클래스의 사용법이 크게 바뀌는 것은 아니다.
    // 단지 유지보수가 좋아질 뿐이다.
    Sedan s = new Sedan();
    s.run();

    Truck t = new Truck();
    t.run();


    // 이렇게 Car 클래스가 존재하면 
    // 어떤 개발자는 Car 클래스를 사용하려고 시도할 것이다.
    // 문제는, Car 클래스의 목적이 소스 코드를 보다 쉽게 관리하기 위해 만든 클래스이지,
    // 직접 사용하려고 만든 클래스가 아니다.
    // 그럼에도 불구하고 다른 개발자가 다음과 같이 Car 클래스를 사용한다면
    // 이를 막을 수 없다.
    Car c = new Car();
    // 사실 Car 클래스는 Sedan과 Truck에 공통으로 들어가는 코드를 
    // 좀 더 쉽게 관리하기 위해 추출하여 클래스로 만든 것이다.
    // 이렇게 직접 사용하려고 만든 클래스가 아니다.
    // 그럼에도 불구하고 위의 코드처럼 
    // Car 클래스의 인스턴스를 만드는 것을 막을 수가 없다.
    // 이것을 막는 문법이 "추상클래스" 이다.
    // 다음 패키지의 예제를 확인하라!
  }

}



package com.eomcs.oop.ex05.n;

// 추상 클래스
// => 서브클래스에게 공통 기능을 상속해주는 목적으로 만든 클래스이다.
// => 직접 사용하지 않는 클래스이다.
// => 즉 개발자에게 이 클래스를 상속 받아 새 클래스를 만들어 쓰라는 의미다!
public abstract class Car {

  public Car() {
    super();
  }

  public void start() {
    System.out.println("시동 건다!");
  }

  public void shutdown() {
    System.out.println("시동 끈다!");
  }

  // 추상 메서드
  // => 서브 클래스에서 재정의할 메서드라면 굳이 수퍼 클래스에서 구현하지 말라!
  // => 또는 서브 클래스에서 반드시 구현하도록 강제하고 싶다면 추상 메서드로 선언한다.
  // => 추상 메서드를 상속 받는 서브클래스는 반드시 구현해야 한다.
  //    만약 구현하지 않으면 추상 메서드인채로 남아 있기 때문에 
  //    서브클래스도 추상클래스가 되어야 한다.
  //    일반 클래스는 인스턴스를 생성하여 메서드를 호출하기 때문에 
  //    구현되지 않은 메서드를 갖는 것은 오류이다.
  //    그래서 일반 클래스는 추상 메서드를 가질 수 없다.
  // => 왜? 추상 메서드가 있다는 것은 해당 메서드를 실행할 수 없다는 것이고
  //       실행할 수 없는 메서드를 갖는 클래스는 
  //       인스턴스를 생성해서는 안되기 때문에
  //       추상메서드를 갖는 클래스는 반드시 추상클래스여야 한다.
  //       일반 클래스는 추상메서드를 가질 수 없다.
  // 
  public abstract void run();

}

</pre>
<br>
<hr>
<br>
<h1>2023-01-09</h1>
<br>
<pre>
<strong>멤버에 대한 접근제어: (default)</strong>
  class Score {
  String name;
  int kor;
  int eng;
  int math;
  int sum;
  float aver;
  compute{-}
}

Score compute(){} 는 같은 멤버라서 다른변수에 접근가능
Exam0110 main(){} 


멤버 접근 제어


<strong>private: 같은 멤버만</strong>


public int getKor() {
  return this.kor;
}

// sum과 aver의 값을 직접 변경하지 못하게 접근을 막았으면,
// 외부에서 이 값들을 조회할 수 있는 방법/수단(method)은 제공해야 한다.
// => 보통 이렇게 필드의 값을 조회하는 용도로 사용하기 위해 메서드를 만들 경우
//    메서드의 용도를 이해하기 쉽도록 getXxx() 형태로 이름을 짓는다.
//       get필드명() {...}
// => 메서드의 이름이 get 으로 시작한다고 해서 "게터(getter)"라고 부른다.
// => 그리고 이런 getter는 공개 모드로 설정한다.

// => 자바 는 필드나 메서드의 외부접근 범위를 조정하는 문법을 제공하는데
// 이 문법을 캡슐화(encapsulation) 라 부른다.
// 실무에서는 셋터에서 유효 값을 검증하는 코드를 잘 넣지 않는다.
// 따로 인스턴스 변수의 값을 검증하는 메서드를 추가하여 처리한다.
// 그래서 실무에서 셋터 메서드는 인스턴스 변수에 그냥 값을 넣는 경우가 많다.
// 즉 인스턴스 변수에 직접 값을 넣는 것과 동일하게 동작한다.
// 이런 상황 때문에 셋터, 겟터의 무용론을 주장하는 개발자들이 있다.
// 그들은 그냥 인스턴스 변수의 접근 범위를 public으로 공개하여 사용할 것을 주장한다.
// 그러나 대부분의 개발자들은 셋터의 무용함을 떠나,
// 메서드를 통해 변수의 값을 설정하는 방법을 선호한다.
// 혹 나중에 메서드에 기타 코드를 추가할 경우를 대비하기 위함이다.
// 변수를 직접 사용하면 변수를 제어하는 코드를 삽입하기 어렵기 때문이다.



public void setKor(int kor) {
  this.kor = kor;
  this.compute();
}

// 대신 메서드를 통해 값을 설정하게 하라!
// 보통 필드의 값을 설정하는 메서드는 'set필드명()'으로 이름을 짓는다.
// - 이런 메서드를 "세터(setter)"라 부른다.
// - 외부에서 호출할 수 있도록 공개 모드로 설정한다.
// - 필드를 비공개로 막으면 값을 조회할 수 없기 때문에
//   getter도 추가해야 한다.

// 세터를 통해서 국, 영, 수 값을 설정할 때마다
// 합계와 평균을 자동으로 계산하기 때문에 직접 compute()를 호출할 필요가 없다.

// 값들의 유효범위를 설정해 추상화가 무너지지 않도록 해야한다

public void setAge(int age) {
  if (age > 0 && age < 150)
    this.age = age;
  else
    throw new RuntimeException("나이가 유효하지 않습니다!");
}


생성자를 private 으로 막기

// 생성자를 private으로 선언하면 외부에서 이 클래스의 인스턴스를 생성하는 것을 막을 수 있다.
private Car() {}


Car c1 = new Car(); // 컴파일 오류!
// 생성자가 private이기 때문에 다른 클래스에서 호출할 수 없다.
// 따라서 인스턴스를 생성할 수 없다.
//
// 그럼 왜 생성자를 private으로 만들었는가?
// => 개발자가 직접 인스턴스를 생성하면 너무 복잡하니,
//    다른 메서드를 통해 인스턴스를 생성하라는 의미다!

// 팩토리 일을 하는 메서드를 통해 인스턴스를 생성한다
// static 메소드로 사용

java.util.Calendar cal = Calendar.getInstance();


<strong>protected: 같은멤버 + 같은 패키지 + 서브클래스의 멤버</strong> 


같은 패키지 이지만 접근 불가할때 super클래스의 설계도로 만들었다면 접근불가
: 서브클래스 설계도에 따라 만든 변수일경우에만 접근가능
=> sub클래스는 Y클래스의 설계도를 사용할수 있기 때문에 sub클래스에 설계도가
없어도 Y에 있으면 사용가능하다 이렇게 만든 다면 접근가능


deault: 같은멤머 + 같은 패키지


public: 모두 가능


<strong>springBoot 프로젝트 준비</strong>

02. 게시글 관리 REST API 추가

web Browser -> SpringBoot -> App

backend-app

import 아래

//다음 클래스가 클라이언트 요청을 처리하는 일을 한다는 것을 SpringBoot 에게 알리는 표시
// => springBoot는  다음 클래스의 인스턴스를 생성해서 보관해 둔다
// => "/hello" 라는 클라이언트 요청 이 URL로 들어오면 해당 메서드를 호출한다

@RestController // 클래스에적용
public class HelloController {

  @GetMapping("/hello") // 메소드에 적용
  public String hello() {
    return "Hello, world!";
  }
}

<strong>GRASP: high cohetion(응집력을 높혀라)-> 1클래스 = 1책임</strong>

BoardHandler
CLI I/O
String title = Prompt.inputString("제목? ");
System.out.println("입력 했습니다");

=> 처음부터 역할을 더 잘게 쪼갯더라면 일부코드만 뜯어서
붙일 필요가 없었다
-> 재활용성이 떨어진다 


BoardController
HTTP I/O
http://localhost:8080/boards/27

@GetMapping("/boards/{boardNo}")
String getboard(@Pathvariable int boardNo) {
  return "게시글 상세 내용";
}

12. GRASP의 High cohesion 적용: Data 처리 역할 분리

설계는 트레이드오프 활동이다. 동일한 기능을 구현할 수 있는 무수한 많은 설계가 존재한다.
따라서 실제로 설계를 진행하다 보면 몇 가지 설계 중에서 한 가지를 선택해야 하는 경우가 빈번하게 발생한다.
이 경우에는 올바른 책임 할당을 위해 INFORMATION EXPERT 패턴 이외의 다른 책임 할당 패턴들을 함께 고려해야 한다.

높은 응집도와 낮은 결합도는 객체에 책임을 할당할 때 항상 고려해야하는 기본 원리다.
책임을 할당할 수 있는 다양한 대안들이 존재한담녀 응집도와 결합도의 측면에서 더 나은 대안을 선택하는 것이 좋다.
즉, 두 협력 패턴 중에서 높은 응집도와 낮은 결합도를 얻을 수 있는 설계가 있다면 그 설계를 선택해야 한다.
응집도는 모듈 내부의 기능적인 응집 정도를 나타낸다.
결합도는 모듈과 모듈간의 상호 결합 정도를 나타낸다.

낮은 결합도과 높은 응집도의 관점에서 매순간마다 전체적인 설계 품질을 검토하면 단순하면서도 재사용 가능하고 유연한 설계를 얻을 수 있다.

출처
조용호, 『[eBook] 오브젝트』, 위키북스(2019), p143~144.

</pre>
<br>
<hr>
<br>
<h1>2023-01-10</h1>
<pre>
<strong>System Architecture 와 Layer</strong>

Use-case 주도 객체 지향 설계패턴 (by Ivar jacodison)


user -> boundry(ui담당) -> control(boundry와 Entity를 제어) -> Entity(데이터담당)

1. CLI
myapp -> boardHandler(boundry와 control역할) -> boardDao

2. MVC web
//  ->  board_list.jsp(boundry) -> boardServlet(control) -> BoardDao(Entity)

하나로 본다면?

3. backend-app (Entity)
boardHandler(boundry와 control) -> BoardDao(Entity)

4. frontend-app (boundry,control)
.html(boundry) -> .js(control) -> JSON


1클래스-1역할과 클래스 의존도를 낮춘다


<strong>REST API 와 HTTP method</strong>

1. create  post -> 요청할 때마다 데이터가 추가된다 
-> http://localhost:8080/boards

2. retrieve(read) get -> 요청 처리후 데이터 변경은 없다
-> http://localhost:8080/boards <- 목록조회 복수형
-> http://localhost:8080/boards/112 <- 상세조회 /112 는 데이터를 특정하는 아이디

3. updatd  put -> 요청 처리후 추가되는 데이터는 없다 **멱등성!!!!**
->  http://localhost:8080/boards/112

4. delete  delete -> 요청 처리후 데이터 삭제
->  http://localhost:8080/boards/112


<strong>요청과 응답 과정</strong>


web browser

POST /voards HTTP/1.1
HOST:localhost:8080
Content-Type: application/x-www-form-urlencoded

title=${title}&content=${content}&password=${password}

getBoards(){
  String title,
  String content,
  String password

  return contentMap;
}

값이 넘어가지 않을때 값이 넘어갔는지 개발자 도구에서 확인


<strong>AJAX 와 CORS</strong>


서버 1 localhost:5500
-> HTML 요청,응답

서버 2 localhost:8080
-> AJAX 요청,응답

@CrossOrigin("http://localhost:5500")
이서버에서 다운로드 받은 HTML 페이지에서 AJAX 요청을 한다면 허락한다


과제

백엔드 프로젝트 
0.2 회원관리 REST API 추가

프론트엔드 프로젝트
0.2 회원 관리 UI 추가


</pre>
<br>
<hr>
<br>
<h1>2023-01-11</h1>
<pre>
1. query string 방식으로 데이터 보내기
-> 브라우저가 URL을 cache에 보관하여 보안에 취약

DELETE / boards/1?password=1111    // ?password=1111   <- query String 방식
host: localhost:8080
.
.


2. message-body 방식으로 데이터 보내기
-> 브라우저 cache에 보관하지 않아 직접적인 외부노출 방지

DELETE / boards/1    
host: localhost:8080
content-length: 13
content-Type: application/x-www-form-urlencoded
password = 1111    // message-body 방식


password=1111&name=홍길동&

Member obj = new Member();
obj.setNo(1);

class Member {
  int no;            // field
  String name;
  Sting tel;
  String postNo;



  getNo(){}          // property
  setNo(){}
  getTel(){}      // read only
  setpostnumber(){}      // write only

  // springBoot는 프로퍼티를 사용해서 값을 적용한다
  // 
}


03. 강사관리 추가하기

강사 입력
이름:
전화:
이메일:
최종학력:
대학교:
전공:
강사료:
번호:
등록일:


<strong>보충내용</strong>


var name = encodeURIComponent(document.querySelector('#f-name').value);  
-> encodeURIComponent 한글입력받은 값을 json으로 인코딩해줌

var tel = document.querySelector('#f-tel').value;   
-> 해당 value 값을 name에 저장  


fetch(`http://localhost:8080/teachers/${no}`, {
  method: 'PUT',            // put  업데이트 해주는 용도 
  headers: {
    'Content-type': 'application/x-www-form-urlencoded'  // 아래 body의 내용을 인코딩하여 숨겨준다
  },                                                     // 주소창에 ?name="홍길동" 과 같은 정보를 숨겨줌 
  body: `name=${name}&tel=${tel}&eMail=${eMail}&eduCation=${eduCation}&uniVerSity=${uniVerSity}&marJoIn=${marJoIn}&pay=${pay}`
})
.then((response) => response.json()) // 요청한 데이터가 없다면 변경오류
.then((obj) => {
  if (obj.status == "failure") {
    alert("강사정보 변경 오류!\n" + obj.data);
    return;
  }

  location.href = "list.html";
})
.catch((err) => {
  alert("서버 요청 오류!");
  console.log(err);
});


};


var values = location.href.split('?');    // split() 파라미터를 기준으로 앞,뒤에있는 값을 배열로 만들어 0번,1번에 저장 
if (values.length != 2) {
  alert("옳바른 페이지 주소가 아닙니다.");
  throw "no 파라미터 값이 누락되었습니다.";
} 
var values2 = values[1].split("=");
if (values2.length != 2 || values2[0] != "no") {
  alert("옳바른 페이지 주소가 아닙니다.");
  throw "no 파라미터 값이 누락되었습니다.";
}

var no = parseInt(values2[1]);
if (isNaN(no)) {
  alert("강사가 옳지 않습니다.");
  throw "no 파라미터 값이 숫자가 아닙니다.";
}

fetch(`http://localhost:8080/teachers/${no}`)
  .then((response) => response.json())
  .then((obj) => {
    if (obj.status == "failure") {
      alert("서버 요청 오류!");
      console.log(obj.data);
      return;
    }

    document.querySelector('#delete-btn').onclick = (e) => {

      fetch(`http://localhost:8080/teachers/${no}`, {
        method: 'DELETE'  -> delete는 body와 header가 없다
      })


document.querySelector("#f-pay").value = obj.data.pay; 
-> 입력받은값을 왼쪽에 넣어줘서 출력

document.querySelector("#f-createdDate").innerHTML = obj.data.createdDate;
-> 날짜 값을 innerHTML로 넣어줌


</pre>
<br>
<hr>
<br>
<h1>2023-01-12</h1>
<pre>


<strong>의존객체 생성 및 주입 자동화</strong>


의존객체(dependency)
-> 작업을 수행할때 사용하는 객체

Teachercontroller  (사용) ->  TeacherDao => @Conponent 를 붙이면 Spring IoC 컨테이너가 자동으로 생성한다

IoC inversion of control

1. 의존객체 주입(Dependency injection(DI))

위에 둘다 의존 -> Teacher(Data Transfer Object(DTO)=value Object(VO) = Domain Object)

2. 이벤트 리스너
프로그램이 실행중 외부에서 클릭으로 요청을 하기 때문에
역행하는것으로 본다


<strong>SpringBoot 핵심 부품</strong>

Application server

-web server
-> HTTP server HTTP 요청과응답을 한다

-servlet container
-> servlet/jsp 관리및 실행


Spring framework

-webMVCframework
-> Controller 등을 실행

-IoC Container
-> 스프링 컴포넌트 생성 및 관리 = Bean Container
@component,@Controller... 으로 표시된 클래스
스프링 IOC Conatiner가 관리하는 클래스


App
-> 개발자가 만든 controller,Dao,service

위 모든 것은 

JVM

위에서 작동


<strong>component 와 class의 관계</strong>


Component
-> 1개 이상의 클래스로 구성된 부품


-class = 1component
-class
-class

예) 회원관리

-Member
-MemberDao = 데이터를 처리하는 component
-MmeberController = 요청처리 component


<strong>class 와 Bean</strong>

자바가 자바산 커피를 의미하고 bean(property를 가진 클래스를 의미)은 
커피콩을 의미한다 즉 자바에 생성된 클래스다


<strong>@Component 와 아이들</strong>

스프링 컴포넌트= IoC컨테이너가 자동 생성하는 객체

@Controller
@RestController
@Service

역할에 따라 분류
- 제어가 용이 조회,생성,제외

예)

TeacherDao

@Repository  // DAO 역할을 수행하는 객체에 붙인다
public class TeacherDao {}


TeacherController

@RestController  // 데이터들을 json으로 변환
public class TeacherController {

  방법 1
  @Autowired TeacherDao teacherDao; // TeacherDao 클래스를 Ioc로 만든 클래스정보를 불러와줌

  방법 2
  MemberDao memberDao;
  // Spring Ioc 컨테이너가 이 클래스의 인스턴스를 만들기 위해
  // 생성자를 호출할때 파라미터로 선언된 memberDao 객체를 주입할 것이다
  public MemberController(MemberDao memberDao) {
    this.memberDao = memberDao;
  }

}


<strong>SpringBoot 설정</strong>

MemberController

@CrossOrigin
addMember
@CrossOrigin
getMember

// 메서드 마다 세밀하게 @CrossOrigin을 제어할 수 있다

->

@CrossOrigin
MemberController

addMember
getMember

// @CrossOrigin이 같다면 간결하게 class에 사용가능 


->

MemverController
BoardController
TeacherController

// @CrossOrigin 설정이 다 같으면 한곳에서 설정 가능

webConfig


@Configuration
// 설정에 관련된 일을 하는 클래스로 선언
// 즉 스프링 컴포넌트로 표시하는 것
//  Spring ioC컨테이너는 이 클래스의 인스턴스를 자동생성

//@EnableWebMvc
// Spring 프레임 워크에서 webMVC 기능을 사용할 수 있게 관련객체를 준비하게 선언
// 웹 애플리케이션을 제작할 때 사용할 도구를 완전하게 구비되는 것이다
// SpringBoot의 경우 이 애노테이션을 생략 가능

public class webConfig
implements WebMvcConfigurer{ // implements 약속등을 이행하다 = 약속을 이행하는 클래스를 정의
  
  // 이클래스는 WebMvcConfigurer 규칙에 따라 메서드를 만들었음을 선언
  // 단 모든 메서드를 정의할 필요는 없다
  // WebMvcConfigurer 를 Ctrl + 클릭 으로 기본 설정된 메서드들을 확인할수 있다
  // 프로젝트에 맞는 부분만 설정하면 된다 (customizing; 고객화)
  // Spring WebMVC 프레임 워크는 이 클래스의 메서드를 참고하여 설정을 완성한다
  public webConfig() {
    System.out.println("WebConfig 생성됨");
  }

  // Cross-Origin 관련 해서 추가로 설정할게 있다면 이 메서드를 정의한다
  // 스프링 부트가 시작되면 이 메서드를 호출하여 CrossOrigin을 설정할 것이다
  @Override
  public void addCorsMappings(CorsRegistry registry) {  // registry 저저ㅏㅇ고
    registry.addMapping("/**")
    .allowedOrigins("http://localhost:5500", "http://127.0.0.1:5500");
  }
}

이렇게 webConfig 클래스에 spring IoC 컨테이너 설정들을 
한번에 설정하고 필요한 설정은 각자 설정할 수 있다


<strong>상속 활용</strong>


Member

private int no;
private String name;
private String tel;
private String postNo;
private String basicAddress;
private String detailAddress;
private boolean working;
private  char gender;
private byte level;
private String createdDate;


Teacher

private int no;
private String name;
private String tel;
private String email;
private int degree;
private String school;
private String major;
private int wage;
private String createdDate;


// 각 클래스 필드가 공통으로 사용할 것을 상속받는다


Membe

public class Member {
  private int no;
  private String name;
  private String tel;
  private String createdDate;


// 이제 각 클래스의 필드와 property를 지워준후 상속 받는다

public class Teacher extends Member {
  
  private String email;
  private int degree;
  private String school;
  private String major;
  private int wage;


//  extends 상속할 클래스 를 지정


<strong>상속 기법</strong>


specialization (전문화)
-> 기능의 확장, 더 특별한 기능을 추가한다
부모에서 자식

super클래스 
car

sub클래스
Truck


generalization (일반화)
-> 공통기능을 추출해서 정의 
자식에서 부모

super클래스=parent클래스
car

sub클래스=child
Truck,Forklift


<strong>static 필드, instance필드, local변수</strong>

1. static 필드
- 클래스가 로딩될때 생성 (Method Area)

2. instance 필드
- new 연산자로 인스턴스 생성할 때 만든다 (Heap)

3. local변수
- 메서드가 호출 될때 (JVM stack)


<strong>생성자</strong>

class Score{
  Score(){
    --
    --
  }
  Score(String name){
    --
    --
  }
}

호출 

new Score(); <- default constructor

파라미터의 값에 따라서 호출할 생성자가 결정

new Score("홍길동");

기본생성자는 생성자가 없을때 자동으로 생성된다(일관성때문)


public static class A {
  static int a = 100;

// 변수 초기화 문장을 컴파일 할 때,
// - 스태틱 초기화 블록이 없으면 컴파일러가 자동으로 삽입한다.
// - 스태틱 초기화 블록에 a 에 100을 할당하는 문장을 삽입한다.
// - 위의 문장은 다음 문장으로 바뀐다.
//
//    static int a;
//    static {
//      a = 100;
//    }
// - 바이트 코드(Exam067

}


static class A {
  int a;
  int b;
  int c;

  // 여러 개의 인스턴스 초기화 블록이 있을 때,
  // - 선언된 순서대로 생성자의 앞 부분에 삽입된다.
  // - 바이트코드(Exam0740$A.class)를 확인해 보라!
  {
    this.a = 101;
    System.out.println("첫 번째 인스턴스 초기화 블록");
  }

  {
    this.a = 102;
    System.out.println("두 번째 인스턴스 초기화 블록");
  }

  {
    this.a = 103;
    System.out.println("세 번째 인스턴스 초기화 블록");
  }

  A() {
    // 인스턴스 초기화 블록은 선언된 순서대로 삽입한다.
    // 즉 다음과 같다.
    // this.a = 101;
    // System.out.println("첫 번째 인스턴스 초기화 블록");
    // this.a = 102;
    // System.out.println("두 번째 인스턴스 초기화 블록");
    // this.a = 103;
    // System.out.println("세 번째 인스턴스 초기화 블록");

    System.out.println("A()");
    b = 200;
    c = 300;




    static class A {

      int b = 200;
      int c;
  
      A() {
        // 자바 컴파일러는
        // 인스턴스 초기화 블록이나 필드 초기화 문장이 있다면,
        // 종류에 구분없이 선언된 순서 그대로 모든 생성자의 처음 부분에 복사한다.
        // 즉 다음과 같다.
        //
        // b = 200;
        // a = 100;
        // a = 111;
        // System.out.println("초기화 블록 실행");     // 결과
  
        System.out.println("A()");
      }
  
      // 필드 초기화 문장(variable initializer)
      int a = 100;
  
      // 인스턴스 초기화 블록(initializer block)
      {
        a = 111;
        System.out.println("초기화 블록 실행");
      }
    }
  
    public static void main(String[] args) {
      A obj1 = new A();
      System.out.printf("a = %d, b = %d, c = %d\n", obj1.a, obj1.b, obj1.c);
    }

</pre>
<br>
<hr>
<h1>2023-01-13</h1>
<pre>

<strong>기능 확장 - 1 기존 클래스를 변경</strong>

1. 고객사 A

App -> 기존클래스 사용 

Car

model
maker
capacity
run()


2. 고객사 B


App -> 기존클래스에 코트 추가

Car

model
maker
capacity
run()
+ sunroof
+ auto

기존코드를 변경,추가하는 과정에서 기존 코드를 사용하여 만든
프로그램에 영향이 간다 


<strong>기능 확장 -2 기존 코드를 복제한 후 기능 추가(on-premise)</strong>

기존코드

Car

model
maker
capacity
run()


복제코드

Car

model
maker
capacity
run()      <- 변경
+ sunroof
+ auto


- 기존 코드를 손대지 않기 때문에 아무런 영향을 받지않는다

- 기존 코드가 버그가 있다면 복제한 파일들을 모두 수정해
줘야 한다 


<strong>기능 확장 - 3 상속을 이용한 기능 확장</strong>

Car

model
maker
capacity
run()


extends Sedan



- 기존 코드 변경 없이 기능 화장

- 기존코드의 소스가 없어도 된다
=>bytecode(.class)파일만 있으면 된다
=>다른개발자가 만든 코드는 재사용하기 쉽다


<strong>상속의 의미</strong>


A -> B -> C -> D

B obj = newD();

->
obj.m4(); // obj 레퍼런스의 클래스에서 m4()를 찾아 호출한다.
obj.m3(); // obj 레퍼런스의 클래스(D)에서 m3()를 찾아보고 없다면 수퍼 클래스에서 찾는다.
obj.m2(); // 만약 D의 수퍼 클래스에서도 못찾는다면 그 위의 클래스에서 찾아본다.
obj.m1(); // 그 위에 클래스에서도 없다면 더 위에 클래스에서 찾아본다.

- 컴파일러로 변수 (레퍼런스)의 차입에서 메서드를 찾아올라간다
레퍼런스가 실제 어떤 클래스의 인스턴스를 가지는 것인지 따지지
않는다


<strong>상속과 클래스 로딩</strong>


자식클래스가 쓰인다면 부모클래스를 먼저 로딩한다


C obj = new C();

1.인스턴스필드 생성
v1(A),v2(B),v3(C)

2.생성자 호출
-> 수퍼클래스의 어떤 생성자를 호출할지 지정하지 않으면 
자동으로 기본 생성자를 호출한다
실행은 수퍼클래스 부터한다
super();


수퍼 클래스에 기본생성자가 없고 다른 생성자가 있다면
그 생성자를 호출 해야한다 (파라미터 알맞게 입력)


<strong>specialization</strong>

Car
run()

-Sedan
sunroof()
-Truck
dump()

기존 클래스에 기능을 추가해서 전문화 시킨것


<strong>Generalization</strong>


Sedan

strart()
shutdown()
run()
sunroof()

Truck

launch()
stop()
go()
dump()


메서드는 다르지만 기능이 똑같은것을 뽑아서 부모 클래스를 만든다


Car

run()
strart()
shutdown()

Overriding
그리고 부모클래스에서 다시 상속받아 
서브 클래스의 맞게 재정의 하여 사용

Sedan

run()
sunroof()

Truck

run()
dump()


<strong>추상클래스</strong>


일반화과정시 만들어지는 부모클래스를 일반용으로 
사용하지 못하게 하는것이 관리에 좋다 

=>

public abstract class Car {} 

인스턴스로 사용할 수 없게 만든다  

abstract
- 여러 가지 측면 가운데서 특정한 측면만을 가려내어 포착하는 것이다
  어떤 일면만을 추상하는 것은 다른 측면을 버린다는 것과 같다


<strong>추상 메서드</strong>


Car

public abstract void run()
strart()
shutdown()

서브 클래스마다 다르게 정의해야하는 메서드라면
수퍼클래스에서 정의하지 않고 강제적으로 서브
클래스가 재정의할 수 있게 하는 문법

(abstract class(추상클래스) != concrete class(구현클래스))
- 일반 클래스는 추상 메서드를 가질수없다
-> 즉 재정의를 하거나 추상 클래스로 만들어야한다

Sedan

run()
sunroof()

Truck

run()
dump()


과제


과제 목표
내용:

- 자유 주제로 CRUD 기능이 구현된 관리 시스템을 만든다.

- 백엔드는 스프링부트 기반으로 구현한다.

- 프론트엔드는 HTML, CSS, JavaScript, AJAX, JSON 기술을 활용하여 구현한다.

- 백엔드 또는 프론트엔드를 구현할 때 외부 라이브러리를 이용할 수 있다.

- 최종적으로 프로젝트를 구현한 과정 및 결과를 발표한다.

- 팀 프로젝트를 관리를 위해 git 저장소를 이용해야 한다.

 

과제 제출 조건:

- zip 압축파일로 제출할 것.

- 백엔드, 프론트엔드 소스를 별도의 디렉토리로 분류할 것.

- 압축 파일을 풀었을 때 디렉토리 구조는 다음과 같아야 한다.

hackathon2-backend/

hackathon2-frontend/

- 팀원 각자가 팀 프로젝트 파일을 제출할 것

- 제출 내용에 다음과 같이 팀명 및 팀원을 명시할 것

   예) 1팀: 홍길동, 임꺽정, 유관순, 안중근, 윤봉길

 

제출 마감일:

- 개발 기간: 2023-01-13 16:00 ~ 2023-01-16 16:00 (토,일 포함)

- 발표: 2023-01-16 16:00 ~ 2023-01-16 18:00

- 제출: 2023-01-16 18:00




오류 문제 

400 오류는 서버 요청을 이상한 방식으로 하여서 오류가나는 경우이다
fetch 에서 확인하여 body들등을 확인하여야한다

postman을 이용하여 서버를 테스트한후 frontend를 작업하면 좀더 수월하다


이클립스 문제


1. 이클립스가 안열릴경우 workspace 알맞은 경로를 지정해줘야한다

2. import가 안된다면 app이름이 겹치는지 확인

3. 서버 문제시
 - 스프링 부트는 help-> market에서 다운로드 
 - 해당 class파일에서 실행이 잘되는지 확인 



</pre>
<br>
<hr>
<br>
<h1>2023-01-17</h1>
<pre>

<strong>클래스 간의 관계와 UML</strong>


1. 상속(inheritance)

class Truck extends Car {}


2. 연관(association)

MemberController -> MemberDao
사람 -> 휴대폰
지속적인 사용관계


3. 집합(aggregation)
약결합

computer <> -> keyboard

class Computer {
  keyboard keyboard;
}

- class를 지울때 따로 사용이 가능할때
예) 컴퓨터와 마우스


4. 합성(composition)
강결합

Car <> -> engine

class computer {
  mainboard;
}

- class를 지울때 따로 같이 쓰레기가 될때
예) 컴퓨터와 메인보드


5. 의존 (dependency)
특정 작업에서 일시적으로 사용

Car -> GasStation

class Car {
  void oil(GasStation){

  }
}


<strong>다형성(polymorphism)</strong>

vehicle v;

v = new vehicle();
v = new Bike();
v = new Car();
v = new Sedan();
v = new Truck();


13. 패키지 활용

패키지를 사용하여 역할에 따라 클래스 분류

=>클래스를 찾고 관리가 쉽다 


14. 상속활용

상속을 받아 기존코드를 생성하지 않고 사용할수 있다


15. 다형적 변수 활용

상속의 일반화 과정중 추상클래스의 추상메소드를 sub클래스 @Override 할때

1. 추상클래스에 추상메소드가 protected로 공개되어야하고
2. sub클래스는 추상메소드의 형식을 그대로 사용하고 사용
   @Override 로 검사를 하고 목적을 알맞게 바꾼다  
3. 해당 메서드를 사용하는 인스턴스필드가 있다면 protected로 바꾸거나
  공개용 메서드를 만들어서 인스턴스 필드를 생성하여 공유한다


<strong>다형적변수와 형변환</strong>

Vehicle obj;

obj = new Car();
Car c = (Car) obj;
obj = new Vehicle();
Car c = (Car) obj; // 컴파일러가 개발자를 신뢰하여 승인
                   // 하지만 JVM에서 실행할때 예외 발생

  private void searchBoard() {
    Board[] boards = (Board[]) this.boardDao.findAll();   <- 이렇게 배열로 받으면 오류는 사라지지만 실행시 애러가 난다
    String keyword = Prompt.inputString("검색어? ");
    System.out.println("번호\t제목\t작성일\t조회수");
    for (Board b : boards) {
      if (b.getTitle().indexOf(keyword) != -1 ||
          b.getContent().indexOf(keyword) != -1) {
        System.out.printf("%d\t%s\t%s\t%d\n",
            b.getNo(), b.getTitle(), b.getCreatedDate(), b.getViewCount());
      }
    }
  }


  Exception in thread "main" java.lang.ClassCastException: class [Ljava.lang.Object; cannot be cast to class [Lbitcamp.myapp.vo.Student; ([Ljava.lang.Object; is in module java.base of loader 'bootstrap'; [Lbitcamp.myapp.vo.Student; is in unnamed module of loader 'app')
	at bitcamp.myapp.handler.StudentHandler.printMembers(StudentHandler.java:35)
	at bitcamp.myapp.handler.StudentHandler.service(StudentHandler.java:172)
	at bitcamp.myapp.App.goMainMenu(App.java:31)
	at bitcamp.myapp.App.main(App.java:11)


=>


private void printBoards() {
  System.out.println("번호\t제목\t작성일\t조회수");

  Object[] boards = this.boardDao.findAll();

  for (Object obj : boards) {
    Board b = (Board) obj;
    System.out.printf("%d\t%s\t%s\t%d\n",
        b.getNo(), b.getTitle(), b.getCreatedDate(), b.getViewCount());
  }
}

객체를 사용하려면 알맞는 타입(Object)으로 바꿔줘야한다 


<strong>오버라이딩(overriding)</strong>

ObjectDao

boardDao

-> sub클래스에서 필요한 기능이 super클래스에 없다면 
super 클래스에서 재정의하여 상속받고 Overriding하여 
사용한다 이 과정에서 Object로 타입이 받아왔기 때문에
받은 타입에 맞게 타입을 변환하여야한다



// 상위 클래스의 레퍼런스로 하위 클래스의 인스턴스를 가리킬 때


Car c = new Sedan();

c.model = "티코"; // Vehicle의 인스턴스 변수
c.capacity = 5;  // Vehicle의 인스턴스 변수
c.cc = 890;      // Car의 인스턴스 변수
c.valve = 16;    // Car의 인스턴스 변수

// 레퍼런스가 실제 하위 인스턴스를 가리키고 있다 하더라도,
// 레퍼런스 타입의 범위를 벗어나서 사용할 수 없다.
//    c.sunroof = true; // 컴파일 오류!
//    c.auto = true;    // 컴파일 오류!



// 해결책?
// => 레퍼런스 변수가 실제 가리키는 것이 무엇인지 알려줘야 한다.
// => ((실제 레퍼런스가 가리키는 인스턴스의 타입) 레퍼런스).멤버
((Sedan)c).sunroof = true; // OK!
((Sedan)c).auto = true;    // OK!

// => 또는 인스턴스의 원래 클래스 레퍼런스에 저장한 다음에 사용.
Sedan s = (Sedan)c;
s.sunroof = true;
s.auto = true;


<strong>instanceof 연산자</strong>

Vehicle v = new Sedan();

// instanceof 연산자?
// => 레퍼런스에 들어있는 주소가 특정 클래스의 인스턴스인지 검사한다.
// => 또는 그 상위/하위 클래스의 인스턴스인지 검사한다.
//
System.out.println(v instanceof Sedan);  
System.out.println(v instanceof Car);
System.out.println(v instanceof Vehicle);
System.out.println(v instanceof Object);
// true
System.out.println(v instanceof Truck);
System.out.println(v instanceof Bike);
// false


<strong> getClass()</strong>


Vehicle v = new Sedan();

// getClass() ?
// => 레퍼런스가 가리키는 인스턴스의 실제 클래스 정보를 리턴한다.
// => == 연산자를 사용하여 특정 클래스의 인스턴스인지 좁혀서 검사할 수 있다.
//
// 클래스명.class
// => 클래스 정보를 갖고 있는 스태틱 변수이다.
//
System.out.println(v.getClass() == Sedan.class);
System.out.println(v.getClass() == Car.class);
System.out.println(v.getClass() == Vehicle.class);
System.out.println(v.getClass() == Truck.class);
System.out.println(v.getClass() == Bike.class);
}


<strong>overloading</strong>

// 오버로딩(overloading)
// => 파라미터 타입이나 개수, 순서는 다르지만 
//    이름이 같은 메서드를 여러 개 만들 수 있는 문법
//
// 왜 이런 문법이 등장했는가?
// => 파라미터의 형식은 다르지만 같은 기능을 수행하는 메서드에 대해 
//    같은 이름을 부여함으로써 프로그래밍의 일관성을 제공하기 위함.  


static int plus(int a, int b) {
  return a + b;
}

static int plus(int a) {
  return a + a;
}

static float plus(float a, float b) {
  return a + b;
  }
}

오버로딩 할때는 파라미터 명은 달라도 상관없다
메서드 명과 타입,순서로 구분할수있다 


</pre>
<br>
<hr>
<br>
<h1>2023-01-18</h1>
<pre>

<strong>오버라이딩</strong>


Score {
  name
  kor
  eng
  math
  sum
  aver
}

Score2 {
  music
  art
}

super클래스의 메소드가 sub클래스의 용도에 맞지 않는다면
알맞게 재정의 한다

<strong>필드 오버라이딩</strong>

A{
  name: String
  tel: String
  working: boolean
  print(){}
}

A4{
  working: string
}


public static void main(String[] args) {
  A4 obj = new A4();
  obj.name = "홍길동"; // A의 name
  obj.tel = "1111-1111"; // A의 tel
  //    obj.working = true; // A4의 working : obj의 클래스에서 먼저 필드를 찾기 때문이다.
  obj.working = "취업";

  obj.print();
  // A의 print() 호출 
  // - A4 가 오버라이딩 한 필드를 사용하지 않는다.
  // - 필드 오버라이딩은 그냥 새 필드를 추가한 것과 같다.
  /

메소드가 있는 클래스의 필드를 먼저 찾는다 


void print() {
  System.out.println("A4.print():");
  System.out.printf("  => this.name(%s)\n", this.name);
  System.out.printf("  => this.tel(%s)\n", this.tel);
  System.out.printf("  => this.working(%s)\n", this.working);
  System.out.printf("  => super.working(%b)\n", super.working);
  }
}

super클래스의 필드를 사용하고 싶다면 super.working
지정해주면 된다


<strong>Method Signature = 'function Prototype'</strong>

void m() <- methos signature {
  method body
}


static class C {
  private void m1() {}
  void m2() {}
  protected void m3() {}
  public void m4() {}
}


<strong>오버라이딩할 때 접근 범위</strong>

static class C4 extends C {

  // 오버라이딩 할 때(메서드를 재정의 할 때)
  // => 원본 보다 접근 범위를 좁힐 수는 없다.
  //
  //    @Override private void m2() {} // (default) ==> private : 컴파일 오류!
  //    @Override void m3() {} // protected ==> (default) : 컴파일 오류!
  //    @Override protected void m4() {} // public ==> protected : 컴파일 오류!

  // 결론!
  // 수퍼 클래스의 메서드를 자식 클래스가 재정의할 때
  // 접근 범위를 확대할 순 있지만, 좁힐 수는 없다!



  void test() {
    // this 레퍼런스로 메서드를 호출하면,
    // => 현재 클래스(this의 실제 클래스, 예: A3)에서 메서드를 찾아 호출한다.
    // => 현재 클래스에 메서드가 없으면 수퍼 클래스에서 메서드를 찾는다.
    // => 메서드를 찾을 때까지 최상위 클래스까지 따라 올라간다.
    this.m();

    // super 레퍼런스로 메서드를 호출하면,
    // => 수퍼 클래스(메서드가 소속된 클래스의 수퍼 클래스, 예: A)에서 메서드를 찾아 호출한다.
    // => 수퍼 클래스에 없으면 그 상위 클래스로 따라 올라간다.
    // => 오버라이딩 하기 전의 메서드를 호출하고 싶을 때 유용하다.
    super.m();
  }
}

  static class A3 extends A2 {
    @Override
    void m() {
      System.out.println("A3의 m()");
    }
  }

  public static void main(String[] args) {
    A3 obj = new A3();
    obj.test();  // A2의 test() 호출
  }
}
// 결과 
// A3.m()
// A.m()


- this.는 사용한 인스턴스가 있는 클래스부터 찾아올라감
- super.는 해당 메소드의 위치에서부터 찾아올라간다


- 인스턴스 필드를 찾는 때:
- this => 메서드가 소쇡된 클래스의 필드부터 찾아 올라간다.
- super => 메서드가 소속된 클래스의 수퍼 클래스 필드부터 찾아 올라간다.


**간단 정리**

인스턴스 필드

this.
- 메소드가 소속된 클래스의 필드
super.
- 메소드가 소속된 클래스의 수퍼 클래스 의 필드


메소드 

this.
- 레퍼런스가 가리키는 인스턴스가 속한 클래스의 필드 
super.
- 메소드가 소속된 클래스의 수퍼클래스의 필드  

- 형변환을 하면 변환한 타입부터 찾아 올라가며
  검사를 하고 없다면 컴파일 오류


<strong>오버라이딩(overriding) - 리턴 타입</strong>

public class Exam0610 {

static class Car {}
static class Sedan extends Car {}
static class Truck extends Car {}
static class Tico extends Sedan {}

static class CarFactory {
  Car create() {
    return new Car();
  }
}

static class SedanFactory extends CarFactory {
  // 오버라이딩 메서드의 리턴 타입은 
  // 서브 클래스도 가능하다.
  @Override
  Sedan create() {
    return new Sedan();
  }
}

- super클래스에게 상속받은 메서드의 리턴타입은 sub클래스도 가능하다
- 메서드를 오버라이딩 할 때 리턴 타입으로 수퍼 클래스는 불가능하다.



클래스에 final을 사용하면 클래스를 상속받을수 없다
필드에 final을 사용하면 상수 필드가 된다 생성자에서 초기화해야한다


 // 상수 필드는 인스턴스 마다 개별적으로 관리하지 않기 때문에
  // 보통 스태틱 필드(클래스 필드)로 만든다.
  // 공개할 경우 public 으로 선언한다.
  //
  public static final int v1 = 100;


  class G {

    public void m1(final int a) {
      // 파라미터는 메서드가 호출될 때 외부의 값을 받는 용도의 변수다.
      // 메서드 안에서 파라미터 값을 임의로 변경하게 되면
      // 처음 받은 파라미터 값을 사용하지 못하는 상황이 발생한다.
      // 그래서 이런 상황을 피하고자,
      // 보통 실무에서 파라미터를 final로 선언한다.
      //
      //    a = 200; // 컴파일 오류!
  
      System.out.println(a);
    }
  }
  
  public final class Exam0510 {
    public static void main(String[] args) {
      G g = new G();
      g.m1(100);
    }
  }


<strong>Object 클래스 - 자바 최상위 클래스</strong>


// Object 클래스의 주요 메서드
// 1) toString() 
//    => 클래스이름과 해시코드를 리턴한다.
      Qname = FQname (Fally-QualifiedName@해시번호)
// 2) equals()
//    => 같은 인스턴스인지 검사한다.
      인스턴스 주소가 같은지 비교
// 3) hashCode()
//    => 인스턴스를 식별하는 값을 리턴한다.
      해시번호(int)
// 4) getClass()
//    => 인스턴스의 클래스 정보를 리턴한다.
      class 객체: 클래스 정보를 담은 객체
// 5) clone()
//    => 인스턴스를 복제한 후 그 복제 인스턴스를 리턴한다.
// 6) finalize()
//    => 가비지 컬렉터에 의해 메모리에서 해제되기 직전에 호출된다.


<strong>Object 클래스 - equals() 오버라이딩</strong>


public static void main(String[] args) {
  My obj1 = new My();
  obj1.name = "홍길동";
  obj1.age = 20;
  obj1.tel = "1111-1111";
  obj1.email = "hong@test.com";
  obj1.gender = 1;
  obj1.working = false;

  My obj2 = new My();
  obj2.name = "홍길동";
  obj2.age = 20;
  obj2.tel = "1111-1111";
  obj2.email = "hong@test.com";
  obj2.gender = 1;
  obj2.working = false;

  System.out.println(obj1 == obj2);
  System.out.println(obj1.equals(obj2));

  // 결론!
  // => Object에서 상속 받은 것을 그대로 사용하면 equals()는 인스턴스가 같은지 비교한다.
  // => 인스턴스의 내용물이 같은지 비교하도록 만들고 싶다면 equals()을 오버라이딩 하라!
  // => String와 wrapper 클래스는 equals() 오버라이딩 하였다.
  // => StringBuffer 클래스는 equals()를 오버라이딩 하지 않았다.
  // => eclipse에 소스에 가보면 자동으로 생성해준다
}


<strong>Hashset 과 hashCode() 와 equals() 의 관계</strong>

인스턴스의 hashcode가 빠른 순서대로 꺼낸다

해쉬코드의 저장 라인이 존재한다 라인에 값을 저장할때는 
해쉬코드를 일정 값으로 나눈 나머지값으로 저장을하기 때
문에 그값에 의해서 출력 순서가 바뀐다


Hasgset 동작원리
- 저장은 가능하지만 원하는 값을 꺼낼수는 없다
  hashCode의 값을 나눈 나머지값으로 위치를 지
  정하기 때문이다

Hash 
-값을 보관할 위치를 계산할 때 사용

set
-집합: 중복저장 불가!

->
아래와 같이 HashCode()와 equals()를 동일하게 오버라이딩
해주면 같은 값으로 간주한다

@Override
public int hashCode() {
  return 100;
}

@Override
public boolean equals(Object obj) {
  return true;
}


// 집합?
// => 중복 값을 저장할 수 없다.
//
// HashSet
// => 값을 저장할때 해쉬 값을 계산하여 저장 위치를 알아낸다
// => 집합방식으로 목록을 다룬다. 즉 중복 값을 저장하지 않는다.
// => 저장 과정 :
//    1) equals()와 hashCode를 호출하여 중복 여부를 검사한다.
//    2) equals()의 리턴값도 true이고 hashCode()의 리턴값도 같을 경우,
//     같은 객체로 판단하여 저장하지 않는다.
//    3) 저장할때 저장 위치는 hashCode()의 리턴값을 사용하여 계산한다




<strong>Object 클래스 - getClass() : 해당 클래스의 정보를 리턴한다.</strong>


// 레퍼런스를 통해서 인스턴스의 클래스 정보를 알아낼 수 있다.
Class classInfo = obj1.getClass();

// 클래스 정보로부터 다양한 값을 꺼낼 수 있다.
System.out.println(classInfo.getName()); // 패키지명 + 바깥 클래스명 + 클래스명
System.out.println(classInfo.getSimpleName()); // 클래스명


<strong>Object 클래스 - getClass() 와 배열</strong>


String obj1 = new String();
Class classInfo = obj1.getClass();
System.out.println(classInfo.getName()); // java.lang.String

// 배열의 클래스 정보
String[] obj2 = new String[10];
classInfo = obj2.getClass();
System.out.println(classInfo.getName()); //[Ljava.lang.String;

//    int i = 100;
//    classInfo = i.getClass(); // primitive type은 Object의 서브 클래스가 아니다.

int[] obj3 = new int[10];
classInfo = obj3.getClass();
System.out.println(classInfo.getName()); //[I

float[] obj4 = new float[10];
classInfo = obj4.getClass();
System.out.println(classInfo.getName()); //[F

double[] obj5 = new double[10];
classInfo = obj5.getClass();
System.out.println(classInfo.getName()); //[D

System.out.println(new byte[10].getClass().getName()); //[B
System.out.println(new short[10].getClass().getName()); //[S
System.out.println(new long[10].getClass().getName()); //[J
System.out.println(new char[10].getClass().getName()); //[C
System.out.println(new boolean[10].getClass().getName()); //[Z


<strong>Object 클래스 - clone() 사용법</strong>


// 인스턴스 복제 기능을 활성화하려면 Cloneable 인터페이스를 구현해야 한다.
// => 이 인터페이스에는 메서드가 선언되어 있지 않다.
// => 따라서 클래스는 따로 메서드를 구현할 필요가 없다.
// => Cloneable을 구현하는 이유는 
//    JVM에게 이 클래스의 인스턴스를 복제할 수 있음을 표시하기 위함이다.
//    이 표시가 안된 클래스는 JVM이 인스턴스를 복제해 주지 않는다. 즉 clone()을 호출할 수 없다.
static class Score implements Cloneable {
  String name;
  int kor;
  int eng;
  int math;
  int sum;
  float aver;

  public Score() {}

  public Score(String name, int kor, int eng, int math) {
    this.name = name;
    this.kor = kor;
    this.eng = eng;
    this.math = math;
    this.sum = this.kor + this.eng + this.math;
    this.aver = this.sum / 3f;
  }

  @Override
  public String toString() {
    return "Score [name=" + name + ", kor=" + kor + ", eng=" + eng + ", math=" + math + ", sum="
        + sum + ", aver=" + aver + "]";
  }

  @Override
  public Score clone() throws CloneNotSupportedException {
    // Object의 clone() 메서드는 Heap의 존재하는 인스턴스 변수들을 그대로 복제한다.
    return (Score) super.clone();
  }
}

public static void main(String[] args) throws Exception {

  Score s1 = new Score("홍길동", 100, 100, 100);
  Score s2 = s1.clone(); // 이제 예외가 발생하지 않는다!
  // 복제 실행 오류가 발생하지 않는 이유?
  // => Score 클래스의 복제 기능을 활성화시켰기 때문이다.
  //    class Score implements Cloneable {...}
  //
  System.out.println(s1 == s2);
  System.out.println(s1);
  System.out.println(s2);
 }
}


<strong>Object 클래스 - clone() : shallow copy</strong>
- 얕은 복제 껍데기를 복제한다 클론한 인스턴스에 레퍼런스가 
있다면 레퍼런스를 복제한다 
즉, 그 레퍼런스의 인스턴스는 하나이고 사용하는 객체는 클론한
객체까지 추가하는것이다  


static class Engine {
  int cc;
  int valve;
  
  public Engine(int cc, int valve) {
    this.cc = cc;
    this.valve = valve;
  }
  
  @Override
  public String toString() {
    return "Engine [cc=" + cc + ", valve=" + valve + "]";
  }
}

static class Car implements Cloneable {
  String maker;
  String name;
  Engine engine;
  
  public Car(String maker, String name, Engine engine) {
    this.maker = maker;
    this.name = name;
    this.engine = engine;
  }

  @Override
  public String toString() {
    return "Car [maker=" + maker + ", name=" + name + ", engine=" + engine + "]";
  }

  @Override
  public Car clone() throws CloneNotSupportedException {
    return (Car) super.clone();
  }
}

public static void main(String[] args) throws Exception {
  Engine engine = new Engine(3000, 16);
  Car car = new Car("비트자동차", "비트비트", engine);
  
  // 자동차 복제
  Car car2 = car.clone();
  
  System.out.println(car == car2); // false
  System.out.println(car);
  System.out.println(car2);
  System.out.println(car.engine == car2.engine); // true
  
  // car와 car2의 엔진이 같다는 것은,
  // 같은 engine의 객체 주소라는 뜻이다.
  car.engine.cc = 2000;
  System.out.println(car2.engine.cc);
  
  // 
  // Object의 clone()은 해당 객체의 필드 값만 복제한다.
  // 그 인스턴스 변수가 가리키고 있는 객체는 복제하지 않는다.
  // 이런 방식의 복제를 "shallow copy(얕은 복제)"라 부른다.
  //
  // 그 객체의 인스턴스 변수가 가리키고 있는 객체까지 복제하는 것을 
  // "deep copy(깊은 복제)"라 부른다.
  // deep copy는 개발자가 직접 clone() 메서드 안에 
  // deep copy를 수행하는 코드를 작성해야 한다.


<strong>Object 클래스 - clone() : deep copy</strong>
- 인스턴스와 레퍼런스가 가리키는 super 클래스의 인스턴스까지
  복제 하여 사용하는것 


public class Exam0174 {

  static class Engine implements Cloneable {
    int cc;
    int valve;

    public Engine(int cc, int valve) {
      this.cc = cc;
      this.valve = valve;
    }

    @Override
    public String toString() {
      return "Engine [cc=" + cc + ", valve=" + valve + "]";
    }

    @Override
    public Engine clone() throws CloneNotSupportedException {
      return (Engine) super.clone();
    }
  }

  static class Car implements Cloneable {
    String maker;
    String name;
    Engine engine;

    public Car(String maker, String name, Engine engine) {
      this.maker = maker;
      this.name = name;
      this.engine = engine;
    }

    @Override
    public String toString() {
      return "Car [maker=" + maker + ", name=" + name + ", engine=" + engine + "]";
    }

    @Override
    public Car clone() throws CloneNotSupportedException {
      // deep copy
      // => 포함하고 있는 객체에 대한 복제를 수행하려면 다음과 같이 
      //    개발자가 직접 포함하는 객체를 복제하는 코드를 작성해야 한다.
      // 
      Car copy = (Car) super.clone();
      copy.engine = this.engine.clone();
      return copy;
    }
  }

  public static void main(String[] args) throws Exception {
    Engine engine = new Engine(3000, 16);
    Car car = new Car("비트자동차", "비트비트", engine);

    // 자동차 복제 
    // => Car의 clone()에서 Engine 객체도 복제할 것이다.
    Car car2 = car.clone();

    System.out.println(car == car2);
    System.out.println(car);
    System.out.println(car2);
    System.out.println(car.engine == car2.engine);

    // car의 엔진과 car2의 엔진이 다른 엔진인지 확인해보자!
    car.engine.cc = 2000;
    System.out.println(car2.engine.cc);


<strong>문자열 리터럴과 String 인스턴스</strong>


String x1 = "Hello";
String x2 = "Hello";

- 상수메모리 영역에 같은 문자열이 존재한다면
  기존 문자열의 주소를 리턴, 새로 생성하지 않
  는다 


<strong>String 인스턴스를 상수풀에 생성하기: intern()</strong>


  public static void main(String[] args) {

    String s1 = new String("Hello");  // Heap 영역에 String 인스턴스를 생성한다.

    // intern()
    // - String 객체에 들어 있는 문자열과 동일한 문자열을 갖고 있는 String 객체를 상수풀에서 찾는다.
    // - 있으면 그 String 객체의 주소를 리턴한다.
    // - 없으면 상수풀에 String 객체를 생성한 후 그 주소를 리턴한다.
    String s2 = s1.intern();

    String s3 = "Hello";  // 해당 문자열을 가진 String 객체를 String Pool에서 찾는다. 
    // 있으면 그 객체를 리턴한다. 없으면 새 객체를 만들고 리턴한다.

    System.out.println(s1 == s2);
    System.out.println(s2 == s3);


    <strong>String - mutable vs immutable 객체</strong>
    -immutable

    public class Exam0160 {
      public static void main(String[] args) {
        // String 객체는 immutable 객체이다.
        // 즉 한 번 객체에 값을 담으면 변경할 수 없다.
    
        String s1 = new String("Hello");
    
        // String 클래스의 메서드는 원본 인스턴스의 데이터를 변경하지 않는다. 
        // 다만 새로 String 객체를 만들 뿐이다.
        String s2 = s1.replace('l', 'x');
        System.out.println(s1 == s2);
        System.out.printf("%s : %s\n", s1, s2); // 원본은 바뀌지 않는다.
    
        String s3 = s1.concat(", world!");
        System.out.printf("%s : %s\n", s1, s3); // 원본은 바뀌지 않는다.
      }
    }


    -mutable

    public class Exam0161 {
      public static void main(String[] args) {
        // StringBuffer 객체는 mutable 객체이다.
        // 인스턴스의 데이터를 변경할 수 있다.
        // 원래의 문자열을 변경하고 싶을 때 사용하는 클래스이다.
        //
        StringBuffer buf = new StringBuffer("Hello");
        System.out.println(buf);
    
        buf.replace(2, 4, "xxxx");// 원본을 바꾼다.
        System.out.println(buf);
    
        // println() 메서드에 넘겨주는 파라미터 값이 String 타입이 아닐 경우,
        // println() 메서드 내부에서 해당 값에 대해 toString() 호출하여
        // 그 리턴 값(String)을 출력한다.
        // 만약에 해당 클래스에 toString() 메서드가 없으면 어떡하나요?
        // => 자바의 모든 클래스는 toString()이 있다.
        // => 왜? 자바의 모든 클래스는 Object 클래스를 상속 받는다.
        // => Object 클래스에 toString()이 정의되어 있다.
      }
    }


<strong>Wrapper 클래스 - 종류</strong>


// Wrapper 클래스의 인스턴스를 생성할 때는 생성자 대신 클래스 메서드를 사용하라.
Byte b2 = Byte.valueOf((byte)100);
Short s2 = Short.valueOf((short)20000);
Integer i2 = Integer.valueOf(3000000);
Long l2 = Long.valueOf(60000000000L);
Float f2 = Float.valueOf(3.14f);
Double d2 = Double.valueOf(3.14159);
Boolean bool2 = Boolean.valueOf(true);
Character c2 = Character.valueOf((char)0x41);


<strong>Wrapper 클래스 - primitive type 을 객체로 다루기</strong>


public class Exam0211 {
  public static void main(String[] args) {

    // Wrapper 클래스의 가장 큰 목적!
    // => primitive 값을 포함하여 모든 값을 쉽게 주고 받기 위함이다.

    // wapper 클래스가 없다면,
    // 다음과 같이 각 타입에 대한 메서드가 따로 있어야 한다.
    long l = 100L;
    double d = 3.14;
    boolean bool = true;

    m(l);
    m(d);
    m(bool);

    // 이렇게 wrapper 클래스를 사용하면
    // 객체로 다룰 수 있다.
    Long obj1 = Long.valueOf(l);
    Double obj2 = Double.valueOf(d);
    Boolean obj3 = Boolean.valueOf(bool);

    m(obj1);
    m(obj2);
    m(obj3);
  }

  // 만약에 Wrapper 클래스가 없다면 다음과 같이
  // 정수를 받는 메서드와 부동소수점을 받는 메서드,
  // 논리값을 받는 메서드를 따로따로 정의해야 한다.
  // => 이런 불편함을 없애기 위해 Wrapper 클래스를 만든 것이다.
  // => 즉 primitive type을 객체처럼 다룰 수 있도록 만든 문법이다.
  static void m(long value) { // byte, short, int, long, char
    System.out.printf("long value=%s\n", value);
  }
  static void m(double value) {// float, double
    System.out.printf("double value=%s\n", value);
  }
  static void m(boolean value) {// boolean
    System.out.printf("boolean value=%s\n", value);
  }

  // wapper 클래스는 primitive type의 값을 객체로 다룰 수 있게 해준다.
  // primitive type에 상관없이 Object 타입의 파라미터로 값을 받을 수 있다.
  static void m(Object value) { // 모든 객체를 받을 수 있다.
    System.out.printf("wrapper value=%s\n", value);
  }
}


</pre>
<br>
<hr>
<br>
<h1>2023-01-19</h1>
<pre>


<strong> Wrapper 클래스 - 오토박싱(auto-boxing)/오토언박싱(auto-unboxing)</strong>


public class Exam0220 {
  public static void main(String[] args) {

    // 다음과 같이 프로그래밍 중에
    // primitive type의 값을 인스턴스에 담고("박싱(boxing)"이라 부른다)
    // 인스턴스의 담긴 primitive 값을 다시 꺼내는 일("언박싱(unboxing)"이라 부른다)은
    // 매우 불편한다.

    // int ==> Integer
    int i1 = 100;
    Integer obj1 = Integer.valueOf(i1);

    // Integer ==> int
    Integer obj2 = Integer.valueOf(200);
    int i2 = obj2.intValue();

  }
}


Integer obj7 = 128;
Integer obj8 = 128;
Integer obj9 = 128;
System.out.println(obj7 == obj8); // false
System.out.println(obj7 == obj9); // false
System.out.println(obj8 == obj9); // false

// 결론!
// - wrapper 객체의 값을 비교할 때 == 연산자를 사용하지 말라!
// - -128 ~ 127 범위 내(상수풀)의 값이라면 == 연산자를 사용하여 비교할 수도 있지만,
//   매번 비교할 때 마다 범위의 유효성을 생각하는 것이 번거롭다.
// - 그외의 값은 Heap에 생성하여
// - equals() 메서드 재정의하여 값을 비교하라!
// - 더 좋은 방법은 auto-unboxing 하여 primitive type 의 값으로 바꾼후에 == 연산자로 비교하라.


<strong>java.util.Calendar 클래스 - 생성자 활용</strong>


public class Exam0410 {
  public static void main(String[] args) {

    Calendar c1;

    // 생성자가 있다하더라도 접근 권한이 없으면 호출할 수 없다.
    //    c1 = new Calendar(); // 컴파일 오류!

    // Calendar는 인스턴스 생성을 도와주는 별도의 클래스 메서드(스태틱 메서드)를 제공한다.
    c1 = Calendar.getInstance();
    System.out.println(c1.get(Calendar.YEAR));

  }
}

// 객체 생성 디자인 패턴 중 일부 소개
//
// 1) 팩토리 메서드(factory method)
// - GoF(Gang of Four)의 23가지 디자인 패턴(design pattern) 중 하나이다.
// - 인스턴스를 생성해주는 메서드이다.
// - 인스턴스 생성 과정이 복잡할 경우에 인스턴스를 생성해주는 메서드를 미리 정의해 둔다.
// - 그래서 인스턴스가 필요할 때 마다 메서드를 호출하여 인스턴스를 리턴 받는다.
//
// 2) 싱글톤(singleton)
// - GoF(Gang of Four)의 23가지 디자인 패턴(design pattern) 중 하나이다.
// - 인스턴스를 한 개만 생성하도록 제한할 때 사용한다.
// - 생성자를 private으로 처리하여 직접 인스턴스를 생성하지 못하도록 만든다.
// - 메서드를 통해 인스턴스를 생성하도록 유도한다.


- 캡슐화   
  복잡한 기능을 function(method)로 감싸는 것 
  위에 상황처럼 calender를 사용하는 경우 new로 생성하면
  지정해야할 기능들이 많아서 캡슐화를 한다
  

<strong>예외 처리발생과 catch</strong>

JVM 
-> 
APP.main() 
-> 
goMainMenu() 
-> 
print.inpuInt() 예외 발생

catch 사용전이라면 보고를 JVM 까지 전달하여 시스템을 종료시킨다


JVM 
-> 
APP.main() 
-> 
goMainMenu() catch 
-> 
print.inpuInt() 예외 발생

사용하면 사용지점 이후에 보고를 하지 않아 시스템이 종료되지 않음


JVM 
-> 
APP.main() 
-> 
goMainMenu() catch 
-> 
- BoardHandler.service() 예외 발생, 
- TeacherHandler.service() 예외 발생, 
- StudentHandler.service() 예외 발생, catch

  예외가 발생하면 catch한곳으로 이동 어디에서
  catch 를 하는가는 상황에 따라 달라진다 


try {
  예외가 발생하는 코드
} catch (Throwable e) {
  예외 처리코드
} finally {
  예외가 발생하든 정상적으로 수행하든 상관없이
  반드시 실행할 코드
}


<strong>예외 상황을 알리는 고전적인 방법</strong>

Calculator.compute()

1. call
2. 계산수행
3. 결과리턴
 오류상황을 리턴값으로 알린다
 => 정상적인 리턴값과의 혼동을 피하기 위해서 
    일반적으로 리턴하지 않는 값을 리턴하여
    오류 상황을 알린다


public class Exam0130 {
  public static void main(String[] args) {

    int result = Calculator2.compute("#", 100, 200);

    // 예전에는 작업 실행중에 오류가 발생하면 희귀한 값을 리턴하여 알려줬다.
    if (result == -1212121212) {
      System.out.println("유효하지 않은 연산자입니다!");
    } else {
      System.out.println(result);
    }

    // 일반적인 결과는 정상적으로 수행된다.
    result = Calculator2.compute("-", 6, 7);
    if (result == -1212121212) {
      System.out.println("유효하지 않은 연산자입니다!");
    } else {
      System.out.println(result);
    }
  }
}
 

// 아무리 희귀한 값을 리턴한다 하더라도 결국에는 그 희귀한 값 또한
// 정상 값일 수 있다.
// 이것은 해결할 수 없다.


<strong>예외를 알리는 다른 방법</strong>


Throw 예외 정보를 담은 객체;
반드시 throwable에 객체여야한다

예) Throw new Throwable("예외 내용");


예외를 던지는 메서드를 선언부에 표시해야한다

예) int compute(String op, int a,int b ) {}


예외처리 문법을 사용하는 이유


1.예외상황을 알리는 문법

2.조치를통해 시스템을 멈추지 않고 실행하는 문법


<strong>Throwable 계층도</strong> 

1. Error (시스템 오류)

- JVM 이 발생시키는 예외
- 정상적인 실행상태로 복귀 불가 -> 예외 처리(현재까지 작업한내용 임시 저장후 사용자에게 안내메세지 출력과 오류기록을 남긴다)
  후 즉시 종료해야한다
- App 에서 던지면 안된다.


2. Exception (애플리케이션 오류)

- App 에서 발생시키는 예외
- 적절한 조치를 취한후 정상적인 실행상태로 복귀할 수 있다
- 개발자가 던지는 예외
- 호출하는 쪽에서 반드시 try,catch로 받아야 한다

  1) RuntimeException (unchecked Exception)
  - try,catch 로 받지 않아도 된다
  - 그러면 상위 호출자에게 전달
  - 예외처리 편이성



  // 오류를 던진다면 반드시 메서드 선언부에 어떤 오류를 던지는지 선언해야 한다.
  // => 메서드 호출자에게 알려주는 것이다.
  static void m1() throws Throwable {
    throw new Throwable(); // OK!
    // 예외를 던질 때 Throwable 클래스를 직접 사용하지 말라!
    // 그 하위 클래스를 사용하라.
    // 특히 애플리케이션 오류를 의미하는 Exception 클래스를 사용하라.
  }

  // 여러 개의 오류를 던지는 경우 메서드 선언부에 그대로 나열하라.
  static void m2() throws FileNotFoundException, RuntimeException {
    int a = 100;
    if (a < 0)
      throw new FileNotFoundException(); // OK!
    else
      throw new RuntimeException(); // OK!
  }

  public static void main(String[] args) {}

}


System.out.println("try");
m(0);
System.out.println("try 블록 실행");
// m()에서 발생된 예외는
// try 블록에서 받지 않는다.
// 따라서 main() 호출자에게 위임한다.
// => 물론 main() 메서드 선언부에 위임할 예외의 종류를 표시해야 한다.
//
} finally {
// try 블록을 나가기 전에 무조건 실행해야 할 작업이 있다면
// catch 블록이 없어도 finally 블록만 사용할 수 있다.
System.out.println("마무리 작업 실행!");
}

// 이렇게 catch 블록이 없는 try ~ finally ~ 블록을 작성하는 상황:
// - 예외가 발생하면 그 처리는 호출자에게 맡긴다.
// - 그러나 이 메서드를 호출하는 동안 사용한 자원은 이 메서드를 종료하기 전에 해제시킨다.
//
}


<strong>Fineally</strong>


try (Scanner)


<strong>예외 던지고 받기</strong>


static void m1() throws Exception {
  // m2()와 같다.
  m2();
}

static void m2() throws Exception {
  // m3()에서 발생된 예외를 상위 호출자에게 던지려면
  // m2() 메서드에서도 선언부에 예외를 기술해야 한다.
  // => m2() 안에서 Exception 예외가 발생합니다" 라고!
  m3();
}

static void m3() throws Exception {
  // m4()에서 발생된 예외를 상위 호출자에게 던지려면
  // m3() 또한 메서드 선언부에 해당 예외를 기술해야 한다.
  // => "m3() 안에서 Exception 예외가 발생합니다" 라고!
  m4();
}

static void m4() throws Exception {
  // 이 메서드에서 발생된 예외를 main()에 전달하는 방법
  // => 상위 호출자에게 전달하려면 여기서 try ~ catch ~ 해서는 안된다.
  // => 여기서 예외를 처리하지 않으면 
  //    메서드 선언부에 어떤 예외가 발생하는 지 선언해줘야 한다.
  throw new Exception("m4()에서 예외 발생!");
}

public static void mein(String[] args) {
  try{
    m1();
  } catch (Exception e) {
    e.printStackTrace();
  }
}
// Exception 계열의 예외를 상위 호출자에게 전달하려면,
// 그 호출 경로에 있는 모든 메서드에
// throws 문장을 선언해야 하는 버거로움이 있다.
// 어쩔 수 없다!
// 무조건 선언해야 한다.


<strong>RuntimeException 예외 던지고 받기</strong>


static void m1() {
  // RuntimeException 예외를 받을 경우
  // try ~ catch ~ 예외를 처리하지 않으면
  // 자동으로 상위 호출자에게 던진다.
  m2();
}

static void m2() {
  // RuntimeException 예외를 받을 경우
  // try ~ catch ~ 예외를 처리하지 않으면
  // 자동으로 상위 호출자에게 던진다.
  m3();
}

static void m3() {
  // m4()에서 어떤 예외가 발생하는지 구체적으로 선언되어 있지 않기 때문에
  // m4()를 호출할 때는 예외처리를 고민할 필요가 없다.
  // 그냥 예외를 던지지 않는 메서드인 것 처럼 사용하면 된다.
  // => 그러나 명심하라!
  // m4() 예외가 발생되면 상위 호출자에게 예외를 던질 것이다.
  m4();
}

static void m4() /*throws RuntimeException*/ {
  // RuntimeException을 상위 호출자에게 전달할 때는
  // Error 예외의 경우처럼 
  // 굳이 메서드 선언부에 지정하지 않아도 된다.
  throw new RuntimeException("m4()에서 예외 발생!");
}

public static void main(String[] args) {
  try {
    m1();
  } catch (RuntimeException e) {
    // m4() 에서 발생된 예외가 여기까지 도달한다.
    System.out.println(e.getMessage());
  }

  // RuntimeException 계열의 예외를 던지는 메서드를 사용할 때는
  // 그 호출 경로에 있는 모든 메서드에 굳이 throws 문장을 선언할 필요가 없다.
  // 예외를 처리하고 싶은 곳에서
  // catch 블록으로 받아 처리하면 된다.
  // 즉 중간에 끼어 있는 메서드를 만들 때
  // throws 문장을 선언하지 않아도 되기 때문에 편하다!
  // => 스텔스처럼 조용히 예외를 전달한다.


<strong>배열 늘리기</strong> 
비트 연산자를 통해 배열의 길이를 복제하여 늘린다 

- 단점 기존에 있던 배열은 garbage로 변한다

public void insert(Object object) {
  if (count == objects.length) {
    objects = Arrays.copyOf(objects, objects.length + (objects.length >> 1));
  }
  this.objects[this.count++] = object;
}


<strong>Linkedlist 알고리즘으로 데이터 </strong>
200
data: aaa
next: 300

300
data: bbb
next: 500

400 => gargage
data: ccc
next: null

500
data: ddd
next: null


배열을 링크로 즉 주소로 관리하게 만드는 방법

- garbage 로 변하는 인스턴스를 정확하게 지우는 방법을 알아야한다
예) 현재 사용하는 방법은 이전 주소를 알아내서 다음 객체를 지정,삭제
하는 방식이다 garbage가 가리키는 객체가 삭제 혹은 이동 하였을때
기존에 있는 곳을 garbage가 가리켜 레퍼런스 카운트가 존재하므로
문제가 발생한다 


</pre>
<br>
<hr>
<br>
<h1>2023-01-20</h1>
<pre>
<strong>연관을 이용한 기존코드 재사용</strong>

상속(강연결)을 이용한 기존 코드 사용의 문제점

부모클래스를 변경하면 자식클래스도 자동으로 변경된다
-> 이때 자식클래스의 메서드를 다른클래스에서 사용하
고있다면 메서드 명을 다시 바꿔줘야 한다


Object {
  insert() -> add()
}

BoardDao extends Object {
  자동 변경
}

BoardHandler {
  insert() -> add()
  수동변경
}




ObjectDao{
  insert()
  findAll()
  get()
}

클래스 생성의 이유는?
Dao의 공통점을 추출하여 사용하는 클래스

-> 기존 클래스 변경

Linkedlist {
  add()
  toArray()
  get()
}

범용성을 높여 많은 프로젝트에서 사용할 수 있게 만든다 
즉 LinkedList를 만들어 Dao가 사용(상속X)해서 연결성을 낮춰준다


<strong>배열을 이용한 목록 다루기</strong>


배열
- 조회를 많이하는 프로젝트에 적합

입력: index로 위치지정 = 빠르다
조회: // = 빠르다
변경: 빠르다
삭제: 배열의 항목을 앞으로 당겨야한다 = 느리다
크기변경: garbage가 많이생기고 느리다 = 고정크기방식 -> 불필요한 메모리 점유하여 메모리 낭비가 심하다



연결리스트
- 삽입,삭제가 많은 프로젝트에 적합

입력: 마지막 노드에 덧붙인다 = 빠르다
조회: head노드부터 링크를 따라가야한다 = 느리다
변경: 조회후 수정가능 = 느리다
삭제: 연결하면 끝 = 빠르다 
크기변경: 값을 추가할 때 자동증가 = 메모리 낭비가 적고 메모리크기를 고정하지 않는다


각 클래스를 만들때 메소드명을 다르게 만들면 유지보수할 때 번거롭다
하지만 구현 규칙을 정하면 유지보수가 쉽다  


<strong>인터페이스 문법을 이용하여 목록을 다루는 객체의 기능을 정의</strong>

- 일관성있는 프로그래밍 가능
- 교체가 쉽다
- 느슨한 연결을 지원 (loose coupling)
-> 클래스간 종속성을 제거하여 변경,교체가 쉽다(유지보수가 쉽다)


List

add()
toArray()
get()
set()
remove()
indexOf()

기능 규격정의


사용법

우클릭 -> interface 클릭 -> 이름 정의

package bitcamp.util;

// 객체 목록을 다루는 기능을 규정한다
// 기본이 public abstract (생략가능)

public interface List {
  void add(Object value);
  Object[] toArray();
  Object get(int index);
  Object set(int index, Object value);
  boolean remove(Object value);
  int indexOf(Object value);

}


public class ArrayList implements List {}

-> 정의한규격을 클래스에 적용 이때 규격으로
 정한것은 무조건 정의 해야한다


<strong>인터페이스를 이용한 loos coupling 실현</strong>

 List{
  ArrayList{
    BoardDao{}
  }
  LinkedList{
    TeacherDao{}
    StudentDao{}
  }
 } 


메소드를 규격화 시켜 ArrayList와 LinkedList를 쉽게
바꿀수 있다 즉 연결성이 낮다




</pre>
<br>
<hr>
<br>
<h1>2023-01-25</h1>
<pre>
<strong>데이터 조회 기능을 규격화 -> 구현 방식에 상관없이 일관된 조회가능</strong>


ArrayList 
-배열을 이용하여 목록을 다룬다
-index 이용하여 데이터를 조회
-add(인덱스,값)
 get(값)

LinkedList
-노드간의 연결을 이용해 목록을 다룬다
-index 이용하여 데이터를 조회
-add(인덱스,값)
 get(값)

Stack
-lAST in First Out(LIFO)
-First in Last Out(FILO)
-push(값)
 pop()

Queue
-First in First Out(FIFO)
-offer(값)
 poll()


데이터 저장 방식(mechanism)에 따라 데이터를 꺼내는 방법이다르다
데이터 조회기법에 일관성이 없다

->

client - call(메서드 signature가 같아야한다 = 인터페이스) > 데이터 조회객체 - get() -> ArrayList
client - call > 데이터 조회객체 - get() -> LinkedList
client - call > 데이터 조회객체 - pop() -> Stack
client - call > 데이터 조회객체 - poll() -> Queue


규칙에 따라 호출 일관성 확보
Iterator


<strong>list와 Iterator 인터페이스</strong>

Dao가 iterator() 를 사용하기위해 List를 Iterable을 상속받게 만든다

-여러 인터페이스 (예) List 와 Queue)에 공통으로 적용되는 규칙(메서드)이 있다면,
슈퍼 인터페이스를 만들어 공통 규칙을 정의한 후, 상속받는 것이 인터페이스
유지 보수에 좋다
 
즉 인터페이스상속(generalization)을 활용


<strong>인터페이스 사용 전</strong>


AWorker -> doA
BWorker -> doB
CWorker -> doC

처럼 객체마다 사용방법이 다르다 즉 일관성이 없다 
이렇게 되면 각각 기억해야한다

-> 개선 인터페이스 사용

interface worker -> execute()

로 호출 규칙을 통일시켜 일관성을 가춘다

implements Aworker -> execute()
implements Bworker -> execute()
implements Cworker -> execute()

이렇게 인터페이스에서 정한 규칙을 모두 구현한다면 이것이 
구현체라고 부른다 일반클래스(concrete class)이다 
하나라도 구현하지 않았다면 추상메서드가 남아있는것이기 때문에
이것은 일반클래스가 아니라 추상클래스이다


caller(사용하는 클래스) -> 인터페이스 -> callee(사용당하는 클래스)


<strong>인터페이스의 구현</strong>

MyInterface{
  m1()
  m2()
  m3()
}

class MyObject {
  m1(){}
  m2(){}
  m3(){}
}

abstract MyObject2 {
  m1(){}
  m2(){}
}

인터페이스를 모두 구현했다면 일반클래스가 되며 public,abstract를 생략가능하지만
MyObject2처럼 모두 구현하지 않았다면 추상클래스가 되며 생략 불가능하다


<strong>인터페이스 필드</strong>


// 인터페이스 필드 선언
interface MyInterface2 {
  // 인터페이스 필드는 public static final 이다.
  // - 인스턴스를 생성할 수 없기 때문에 인스턴스 필드를 선언할 수 없다.
  // - 규칙이기 때문에 무조건 public 이다.
  // - 인스턴스 필드가 아니기 때문에 값을 변경할 수 없다.
  public static final int v1 = 100;

  // public, static, final 을 생략할 수 있다.
  static final int v2 = 200;
  public final int v3 = 300;
  public static int v4 = 400;

  int v5 = 500; // 모두 생략된 상태!
}


<strong>default method</strong>


인터페이스에 추가된 새로운 규칙이 추가 되면 기존에 사용하던 클래스들이
오류가 발생한다 이러한 상황을 발생시키지 않게 하기위해 default 메소드를
사용한다

default autoPilot(){}

Car에 추가된 새로운 규칙은 구현된 메소드이기 때문에 기존클래스에
아무런 영향이 없다 단 강제할 수 없다는 단점이 있다 


<strong>인터페이스 상속과 구현</strong>


public class Exam0110 {

  interface ProtocolA {
    void rule1();
  }

  // 인터페이스도 다른 인터페이스를 상속 받을 수 있다.
  // - ProtocolB 는 ProtocolA의 입장에서 서브 인터페이스이다.
  // - ProtocolA 는 ProtocolB의 입장에서 수퍼 인터페이스이다.
  interface ProtocolB extends ProtocolA {
    void rule2();
  }

  // 인터페이스를 구현할 때는
  // 수퍼 인터페이스의 메서드까지 모두 구현해야 한다.
  class ProtocolImpl implements ProtocolB {
    // ProtocolA 규칙 준수!
    @Override
    public void rule1() {System.out.println("rule1()");}

    // ProtocolB 규칙 준수!
    @Override
    public void rule2() {System.out.println("rule2()");}

    // 인터페이스와 상관 없이 메서드 추가
    public void m1() {System.out.println("m1()");}
  }

  void test() {

    ProtocolImpl obj = new ProtocolImpl();

    // 1) 클래스의 레퍼런스 사용,
    // - 그 클래스에 정의된 메서드 호출 가능
    // - 그 클래스의 상위 클래스에 정의된 메서드 호출 가능
    obj.rule1(); // OK
    obj.rule2(); // OK
    obj.m1(); // OK

    System.out.println("------------------------------------");

    // 2) 인터페이스의 레퍼런스 사용
    // - 인터페이스에 정의된 메서드 호출 가능 
    // - 상위 인터페이스에 정의된 메서드 호출 가능
    ProtocolB b = obj;
    b.rule2(); // OK --> ProtocolB.rule2() 
    b.rule1(); // OK --> ProtocolA.rule1()
    //    b.m1(); // 컴파일 오류 --> ProtocolImpl.m1() 

    System.out.println("-------------------------------");

    // 3) 수퍼 인터페이스의 레퍼런스 사용
    // - 인터페이스에 정의된 메서드 호출 가능 
    // - 상위 인터페이스에 정의된 메서드 호출 가능
    // - ProtocolImpl 클래스가 ProtocolB 의 규칙에 따라 제작되었다면
    //   결국 그 수퍼 인터페이스의 규칙도 준수하는 것이 된다.
    // - 따라서 수퍼 인터페이스 레퍼런스에 객체를 담을 수 있다.
    //   즉 수퍼 인터페이스 레퍼런스로 객체를 가리킬 수 있다.
    //
    ProtocolA a = obj;
    a.rule1(); // OK --> ProtocolA.rule1()
    //    a.rule2(); // 컴파일 오류 --> ProtocolB.rule2() 
    //    a.m1(); // 컴파일 오류 --> ProtocolImpl.m1() 
  }

  public static void main(String[] args) {
    new Exam0110().test();
  }
}


<strong>인터페이스 다중 상속</strong>


interface ProtocolA{
  rule0()
  rule1()
}

interface ProtocolB{
  rule0()
  rule2()
}


interface ProtocolC extends ProtocolA,ProtocolB {
  rule3()
}

class ProtocolImpl {
  rule0()
  rule1()
  rule2()
  rule3()
}


인터페이스는 다중상속이 가능하다 구현이 안되었기 때문이다 
콘크리트 클래스로 구현하기 위해서는 상속 받은 모든 인터페이
스의 추상 메소드를 구현해야한다 


</pre>
<br>
<hr>
<br>
<h1>2023-01-26</h1>
<pre>
<strong>인터페이스 다중 상속 불가능한 경우</strong>


interface ProtocolA {
  void rule0()
  void rule1()
}

interface ProtocolB {
  int rule0()
  void rule2()
}

메소드의 리턴타입이 다른경우 다중상속이 불가능하다
즉 어떤 메소드를 상속받는지에 따라서 구현이 달라진다


<strong>인터페이스와 추상클래스</strong>


interface ProtocolA{
  rule1()
  rule2()
  rule3()
  rule4()
}

abstract ProtocolA {
  rule2()
  rule3()
  rule4()
}

class ProtocolImpl {
  rule1()  // 강제적으로 구현
  rule3()  // 선택적으로 구현 
}

추상클레스가 인터페이스를 직접 받고 그 추상클래스를
받아서 사용하면 인터페이스를 간접적으로 사용하기 때
문에 선택적으로 사용가능하다 

** 이때 추상클래스에서 일부러 구현하지 추상 메서드가 있을경우
모든 상속받은 클래스들은 추상클래스를 강제적으로 구현해야한다 


<strong>인터페이스 default 메서드</strong>


interface computer {
  on()
  off()
  default touch() // default로 추가
  touch() // public abstract 로 추가하면 컴파일 오류
}

class Computer1 {
  on()
  off()
}

class Computer2 {
  on()
  off()
  touch() 
}


기존에 사용하던 프로젝트에서 새로운 메소드를 추가하고 싶다면
default 메소드로 추가하라 이미 구현된 메소드이기 때문에 컴파
일 오류가 발생하지 않는다 단 강제성이 없어진다


또다른 방식은 기존 인터페이스를 상속받아 ComputerB를 만들어 
새로운 메소드를 추가하면 가능하다 하지만 이런경우 또다른 클
래스가 만들어 지기 때문에 기존 프로젝트와 연결성이 없어진다 

즉 computer를 가지고 활용하는 메소드가 있을경우 ComputerB 로
바꿔줘야한다 


<strong>중첩클래스 활용</strong>


LinkedList {
  add(){}
  toArray(){}
  set(){}
  remove(){}
  indexOf(){}
  get(){}

  static class Node {
    Object value;
    Node next;
  
    public Node() {}
  
    public Node(Object value) {
      this.value = value;
    }
  }
}


LinkedList에 있는 모든 메소드는 Node를 사용하고 이 클래스만 사용한다
Node는 인스턴스 사용을 하지 않는다 그래서  static nested class로 만들
어 관리하는것이 유지보수에 좋다 


class AbstractList {
  iterator() {
    class ListIterator (){
      ListIterator(List list){}
    }
  }
  return new ListIterator();
}


해당 클래스가 하나의 클래스의 하나의 메소드에서만 사용한다면
로컬 클래스로 만든다 


class AbstractList {
  iterator() {
    Iterator obj = new Iterator() {
      ListIterator(List list){}
    }
  };
  return obj;
}


인스턴스를 하나만 사용하면서 크기도 작다면 익명 클래스로 바꾼다


class AbstractList {
  iterator() {
  return new Iterator() {
    ListIterator(List list){}
  }
 };
}


return 문 + anonymous class 사용


<strong>nested class 종류</strong>


class 01{
  static class A{} // static nested class
  class B{} // non-static nested class = inner class

  public static void main(String[] args) {
    class C{}  // local class
    Object obj = new Object() { // 익명클래스 (anonymous class)
      public void m1() {}
    }
  }
}


<strong>inner class 클래스 정의와 인스턴스 생성</strong>


class A {
  class B{
    인스턴스 중첩 클래스는 바깥클래스의 인스턴스 주소를 저장할
    필드를 컴파일러가 자동으로 추가하고 파라미터로 받는 생성자
    를 만든다 
  }
  static class {}  스태틱 중첩클래스는 내부에서 사용하기 때문에 생성하지 않는다
}


<strong>바깥 클래스 인스턴스 멤버 접근하기</strong>


class B3 {

  // 인스턴스 멤버
  int v1 = 10;

  class X {
    int v1 = 100;

    void test() {
      int v1 = 1000;

      System.out.printf("v1 = %d\n", v1); // 로컬 변수 
      System.out.printf("this.v1 = %d\n", this.v1); // 인스턴스 변수 
      System.out.printf("B3.this.v1 = %d\n", B3.this.v1); // 바깥 객체의 인스턴스 변수 
    }
  }
}

public class Exam0230 {

  public static void main(String[] args) {
    B3 outer = new B3();
    outer.v1 = 11;

    B3.X x1 = outer.new X();
    x1.test();
    System.out.println("--------------------");

    B3.X x2 = outer.new X();
    x2.test();
    System.out.println("--------------------");

    B3 outer2 = new B3();
    outer2.v1 = 22;

    B3.X x3 = outer2.new X();
    x3.test();
    System.out.println("--------------------");
  }




</pre>
<br>
<hr>
<br>
<h1>2023-01-27</h1>
<pre>
<strong>중첩클래스와 .class 파일</strong>

class A {
  
  static class B {}   -> A$B.class
  
  class C {}    -> A$C.class

  void Method {
    class D {}    -> A$1D.class

    Object object = new Object(){};   -> A$1.class
  }
}   -> A.class


<strong>static nested class 와 non-static nested class 차이</strong>


class A {
  static class X{} // X (){} 컴파일러가 기본생성자를 추가해준다 

  class Y{} // A this$0; Y(A arg) {this$0 = arg;}
            // 컴파일러가 바깥클래스의 객체 주소를 담을 레퍼런스와 파라미터를 추가
            // Y obj = new Y() ->  Y obj = new Y(this)
            // 컴파일러가 자동으로 변경해준다
}


<strong>local class : .class 파일명</strong>


class B2 {
  void m1() {
    class X {
      // 로컬 클래스의 .class 파일명
      // => [바깥클래스명]$[정의된순서][로컬클래스명].class
      // => 예) B2$1X.class
    }
    class Y {
      // 로컬 클래스의 .class 파일명
      // => [바깥클래스명]$[정의된순서][로컬클래스명].class
      // => 예) B2$1Y.class
    }
  }

  static void m2() {
    class Y {
      // 로컬 클래스의 .class 파일명
      // => [바깥클래스명]$[정의된순서][로컬클래스명].class
      // => 예) B2$2Y.class
    }
    class X {
      // 로컬 클래스의 .class 파일명
      // => [바깥클래스명]$[정의된순서][로컬클래스명].class
      // => 예) B2$2X.class
    }
    class Z {
      // 로컬 클래스의 .class 파일명
      // => [바깥클래스명]$[정의된순서][로컬클래스명].class
      // => 예) B2$1Z.class
    }
  }
}

public class Exam0130 {

  public static void main(String[] args) {
  }

}


<strong>local class에서 바깥 메서드의 로컬 변수 접근</strong>


// 계산기 사용법을 정의한다.
interface Calculator {
  double compute(int money);
}

class CalculatorFactory {

  static Calculator create(float interest) {

    class CalculatorImpl implements Calculator {

      @Override
      public double compute(int money) {
        return money + (money * interest);
        // interest는 create() 함수의 로컬 변수이다.
        // CalculatorImpl 객체를 생성하여 리턴한 후에는 interest 로컬 변수는 스택에서 사라진 상태일 것이다.
        // 나중에 compute()를 호출할 때 interest 변수는 없을텐데, 어떻게 된 것인가?
        // => 로컬 클래스에서 메서드의 로컬 변수를 사용한다면
        //    컴파일러는 로컬 클래스에 바깥 메서드의 로컬 변수 값을 저장할 필드를 추가한다.
        //    또한 로컬 클래스의 객체를 생성할 때 생성자에 로컬 변수의 값을 넘겨 줄 것이다.
      }
    }

    return new CalculatorImpl();
  }
}

public class Exam0310 {

  public static void main(String[] args) {
    Calculator c1 = CalculatorFactory.create(0.02f);
    Calculator c2 = CalculatorFactory.create(0.08f);

    System.out.printf("%.2f\n", c1.compute(1235_0000));
    System.out.printf("%.2f\n", c2.compute(1235_0000));
  }

}


<strong>anonymous class : 클래스를 상속 받은 익명 클래스 정의</strong>


public class Exam0121 {

  // 클래스는 static과 non-static이 구분된다.
  static abstract class A {
    abstract void print();
  }

  public static void main(final String[] args) {
    // 2) 익명 클래스로 서브 클래스 만들기
    // => 인스턴스를 한 번 만 생성할 것이라면,
    //    로컬 클래스로 정의하는 것 보다 익명 클래스로 정의하는 것이 더 낫다.
    // => 특히 객체를 사용하려는 곳에 바로 익명 클래스를 정의하면
    //    읽기 쉽기 때문에 소스 코드를 유지보수에 더 좋다.
    //
    // 익명 클래스로 인터페이스 구현하기
    // 문법:
    // => 수퍼클래스 레퍼런스 = new 수퍼클래스() {};
    //  
    //    - 호출하는 생성자는 수퍼 클래스의 생성자이다.
    //
    A obj2 = new A() {
      @Override
      void print() {
        System.out.println("Hello!");
      }
    };
    obj2.print();
  }
}


<strong>anonymous class - 익명 클래스가 놓이는 장소: 리턴</strong>


class My {
  static void m1() {
    System.out.println("오호라!!!!");
  }

  void m2() {
    System.out.println("와우~~~~!");
  }
}

public class Exam0450 {
  // 인터페이스의 경우 static으로 선언하지 않아도 스태틱 멤버에서 사용할 수 있다.
  interface A {
    void print();
  }

  static A create0() {
    class X implements A {
      @Override
      public void print() {
        System.out.println("Hello!0");
      }
    }
    return new X();
  }

  static A create1() {
    A a = new A() {
      @Override
      public void print() {
        System.out.println("Hello!1");
      }
    };
    return a;
  }

  static A create2() {
    return new A() {
      @Override
      public void print() {
        System.out.println("Hello2!");
      }
    };
  }

  static A create3() {
    return () -> System.out.println("Hello3!");
  }

  static A create4() {
    return My::m1;
  }

  static A create5() {
    return new My()::m2;
  }

  public static void main(String[] args) {
    A obj0 = create0();
    obj0.print();


    A obj1 = create1();
    obj1.print();

    A obj2 = create2();
    obj2.print();

    A obj3 = create3();
    obj3.print();

    A obj4 = create4();
    obj4.print();

    A obj5 = create5();
    obj5.print();
  }
}


<strong>Lambda 문법 - 익명 클래스 vs 람다</strong>


public class Exam0110 {

  // 다음과 같이 추상 메서드가 한 개 있는 인터페이스를 "functional interface"라고 부른다.
  // => 이런 경우에 람다 문법을 사용할 수 있다.
  // => 인터페이스는 static 을 붙이지 않아도 static 멤버가 사용할 수 있다.
  interface Player {
    void play();
  }

  public static void main(String[] args) {

    // 익명 클래스로 인터페이스 구현하기
    Player p1 = new Player() {
      @Override
      public void play() {
        System.out.println("익명 클래스");
      }
    };
    p1.play();

    // 람다 문법으로 인터페이스 구현하기
    // => 메서드 한 개짜리 인터페이스를 좀 더 간결하게 구현하기 위해 만든 문법이다.
    // => 뻔한 코드 생략!
    Player p2 = () -> System.out.println("익명 클래스");
    p2.play();

  }
}

// 익명 클래스와 .class 파일 
// => 자바의 nested class 는 모두 별도의 .class 파일을 갖는다.
// => 위의 main()에 정의된 로컬 익명 클래스는 다음과 같은 이름의 .class 파일로 컴파일 된다.
//      Exam0110$1.class
//
// 람다와 .class 파일 
// => 람다는 별도의 .class 파일을 생성하지 않는다.
// => 컴파일러는 람다 코드를 해당 클래스의 스태틱 메서드로 정의한다.
// => 그리고 리플렉션 API를 사용하여 이 메서드를 호출하도록 변경한다. 
// => 람다 문법이 초기에 등장했을 때는 익명 클래스로 변환되었다.
// => 그러나 최근에는 메서드로 변환한 후 호출하는 방식으로 바뀌었다.
// => 예) 
// 원래의 자바코드:
//    Player p2 = () -> {
//      System.out.println("람다");
//    };
//
// 컴파일러가 변환한 코드:
//    private static synthetic void lambda$0();
//    0  getstatic java.lang.System.out : java.io.PrintStream [33]
//    3  ldc <String "람다"> [39]
//    5  invokevirtual java.io.PrintStream.println(java.lang.String) : void [41]
//    8  return
//      Line numbers:
//        [pc: 0, line: 27]
//        [pc: 8, line: 28]
//
// => 람다를 호출하는 코드는 자동 생성된 메서드를 호출하는 코드로 변환된다.


파라미터가 하나일때 타입,괄호 생략가능



public class Exam0130 {

  interface Player {
    void play(String name);
  }

  public static void main(String[] args) {
    // 1) 파라미터는 괄호() 안에 선언한다.
    Player p1 = (String name) -> System.out.println(name + " 님 환영합니다.");
    p1.play("홍길동");

    // 2) 파라미터 타입을 생략할 수 있다.
    Player p2 = (name) -> System.out.println(name + " 님 환영합니다.");
    p2.play("홍길동");

    // 3) 파라미터가 한 개일 때는 괄호도 생략할 수 있다.
    Player p3 = name -> System.out.println(name + " 님 환영합니다.");
    p3.play("홍길동");
  }
}



파라미터가 여러개 일때 도 똑같이 생략가능



public class Exam0140 {

  interface Player {
    void play(String name, int age);
  }

  public static void main(String[] args) {
    // 1) 파라미터는 괄호() 안에 선언한다.
    Player p1 = (String name, int age) -> System.out.printf("%s(%d)님 환영합니다.\n", name, age);
    p1.play("홍길동", 20);

    // 2) 파라미터 타입을 생략할 수 있다.
    Player p2 = (name, age) -> System.out.printf("%s(%d)님 환영합니다.\n", name, age);
    p2.play("임꺽정", 30);

    // 3) 파라미터가 여러 개일 때는 괄호를 생략할 수 없다.
    //    Player p3 = name, age -> System.out.printf("%s(%d)님 환영합니다.\n", name, age);
    //    p3.play("임꺽정", 30);
  }
}


<strong>functional interface의 자격</strong>


public class Exam0230 {

  // 여러 개의 메서드가 있다 하더라도 추상 메서드가 한 개이면 된다.
  interface Player {

    static String info() {
      return "Player입니다.";
    }

    default void stop() {}

    void play();
  }

  public static void main(String[] args) {
    // static 메서드나 default 메서드가 몇개이든 그 개수는 중요하지 않다.
    // 추상 메서드가 한 개이면 람다 문법을 사용할 수 있다.
    Player p = () -> System.out.println("Player...");
    p.play();
    System.out.println(Player.info());
  }


<strong>메서드 레퍼런스 - 스태틱 메서드 레퍼런스</strong>



public class Exam0510 {

  static class MyCalculator {
    public static int plus(int a, int b) {return a + b;}
    public static int minus(int a, int b) {return a - b;}
    public static int multiple(int a, int b) {return a * b;}
    public static int divide(int a, int b) {return a / b;}
  }

  interface Calculator {
    int compute(int x, int y);
  }

  public static void main(String[] args) {
    // 메서드 한 개짜리 인터페이스의 구현체를 만들 때,

    // 1) 익명 클래스 활용
    Calculator obj1 = new Calculator() {
      @Override
      public int compute(int x, int y) {
        return x * y;
      }
    };

    // 2) 람바 문법 활용
    Calculator obj2 = (x, y) -> x * y;

    // 3) 기존에 작성한 클래스의 스태틱 메서드를 재활용하기
    // => 인터페이스의 메서드 규격과 일치하는 메서드가 있다면,
    //    그 메서드를 람다 구현체로 대체할 수 있다.
    // => 새로 코드를 작성할 필요가 없어 매우 편리하다.
    // => 규격? 메서드의 파라미터 타입/개수/순서, 리턴 타입
    // => 문법:
    //    클래스명::메서드명
    Calculator c1 = MyCalculator::plus;  // MyCalculator의 스태틱 메서드인 plus() 를 가지고 구현체를 자동생성
    Calculator c2 = MyCalculator::minus;
    Calculator c3 = MyCalculator::multiple;
    Calculator c4 = MyCalculator::divide;

    System.out.println(c1.compute(200, 17)); // compute() ==> plus()
    System.out.println(c2.compute(200, 17)); // compute() ==> minus()
    System.out.println(c3.compute(200, 17)); // compute() ==> multiple()
    System.out.println(c4.compute(200, 17)); // compute() ==> divide()
  }
}


인스턴스 메서드 또한 같은 형식이지만 인스턴스는 앞에 주소를 넘겨주는 방식으로 사용


<strong>메서드 레퍼런스 - 생성자 레퍼런스</strong>


public class Exam0710 {

  interface ListFactory {
    List create();
  }

  public static void main(String[] args) {

    // 인터페이스에 정의된 메서드가
    // 생성자의 형식과 일치하다면
    // 메서드 레퍼런스로 생성자를 지정할 수 있다.
    //
    // 1) 익명 클래스로 인터페이스 구현
    //    ListFactory f1 = new ListFactory() {
    //      public List create() {
    //        return new ArrayList();
    //      }
    //    };

    // 2) 람다 문법으로 인터페이스 구현
    //    ListFactory f1 = () -> new ArrayList();

    // 3) 메서드 레퍼런스로 인터페이스 구현 
    ListFactory f1 = ArrayList::new;

    // 인터페이스의 메서드를 호출하면
    // 지정된 클래스의 인스턴스를 만든 후 생성자를 호출한다.
    List list = f1.create(); // new ArrayList();

    System.out.println(list instanceof ArrayList);
    System.out.println(list.getClass().getName());
  }
}


사용 법은 동일하다


<strong>List 와 forEach() - forEach() 사용 후</strong>


public class Exam0920 {

  public static void main(String[] args) {
    ArrayList<String> names = new ArrayList<>(); // <> 제너릭문법
    names.add("홍길동");
    names.add("임꺽정");
    names.add("유관순");
    names.add("김구");
    names.add("안중근");

    class MyConsumer<T> implements Consumer<T> {
      @Override
      public void accept(T item) {
        System.out.println(item);
      }
    }
    names.forEach(new MyConsumer<String>());
  }
}


제너릭 문법은 클래스,인터페이스 를 선언할때 사용할 데이터 타입을 
지정해 재사용할 수 있게 하는 문법이다 



</pre>
<br>
<hr>
<br>
<h1>2023-01-30</h1>
<pre>


map 의 값을 꺼낼때


static void print(Map<String,Member> map) {
  Set<Entry<String,Member>> entrySet = map.entrySet(); // set 안에는 Entry가 있고 그안에 키로 String,과 Member가 있다

  for (Entry<String,Member> entry : entrySet) {
    System.out.printf("%s ==> %s\n" , entry.getKey(), entry.getValue());
  }
  System.out.println("_____________________________");
}
}


<strong>FileOutputStream/FileInputStream</strong>


파일에 FileOutputStream ->  
파일에 fileInputStream -> 


<strong>myapp 의 게시판 데이터 포맷을 추출하는법</strong>


1. BoardDao 에 save 메소드를 만든다

public void save(String filename) {
  try (FileOutputStream out = new FileOutputStream(filename)){

    // 바이너리 데이터(바이트배열)를 출력할 도구를 준비한다 .

    //목록에서board객체를 꺼내 바이트 배열로 만든후 출력
    //      for (Borad b : list) {
    //        byte[] bytes = b.toBytes();
    // out.write(bytes);
    //}

    if (list.size() > 0) {
      Board b = list.get(0);
      out.write(ByteArrayGenerator.write(b.getNo()));       // 0x348a3b10 = 0x348a3b10
      out.write(ByteArrayGenerator.write(b.getTitle()));
      out.write(ByteArrayGenerator.write(b.getContent()));
      out.write(ByteArrayGenerator.write(b.getPassword()));
      out.write(ByteArrayGenerator.write(b.getViewCount()));
      out.write(ByteArrayGenerator.write(b.getCreatedDate()));

    }
  }catch (Exception e) {
    e.printStackTrace();
  }
}


2. util에 ByteArrayGenerator를 만든다 

데이터를 저장할 방식을 지정

public class ByteArrayGenerator {
  public static byte[] write(int value) {
    byte[] bytes = new byte[4];
    bytes[0] = (byte)(value >> 24);
    bytes[1] = (byte)(value >> 16);
    bytes[2] = (byte)(value >> 8);
    bytes[3] = (byte)value;
    return bytes;

  }

  public static byte[] write(String value) {
    // [2byte: 문자열의 바이트 배열길이[n바이트 : 문자열의 바이트배열]
    byte[] strBytes = value.getBytes();
    byte[] bytes = new byte[strBytes.length + 2];

    System.arraycopy(strBytes, 0, bytes, 2, strBytes.length);
    bytes[0] = (byte)(strBytes.length >> 8);
    bytes[1] = (byte)(strBytes.length);

    return bytes;
  }
  public static void main(String[] args) {
    //    int value = 0xabcdef31;
    //    byte[] bytes = ByteArrayGenerator.write(value);
    byte[] bytes = ByteArrayGenerator.write("ABC가각간");
    for (int i = 0; i < bytes.length; i++) {
      System.out.printf("%02x" , bytes[i]);
    }
  }
}


3. BoardHandler 에 (0.이전) 을 선택하면 저장하게 작동

public void service() {
  while (true) {
    System.out.printf("[%s]\n", this.title);
    System.out.println("1. 등록");
    System.out.println("2. 목록");
    System.out.println("3. 조회");
    System.out.println("4. 변경");
    System.out.println("5. 삭제");
    System.out.println("6. 검색");
    System.out.println("0. 이전");
    int menuNo = Prompt.inputInt(String.format("%s> ", this.title));

    switch (menuNo) {
      case 0:
        boardDao.save("board.data");
        return;
      case 1: this.inputBoard(); break;
      case 2: this.printBoards(); break;
      case 3: this.printBoard(); break;
      case 4: this.modifyBoard(); break;
      case 5: this.deleteBoard(); break;
      case 6: this.searchBoard(); break;
      default:
        System.out.println("잘못된 메뉴 번호 입니다.");
    }
  }
}


</pre>
<br>
<hr>
<br>
<h1>2023-01-31</h1>
<pre>
 
<strong>Decorator 설계기법을 이용하여 기능확장</strong>


DataOutputStream
-> write() 사용
FileOutputStream 
->
바이너리 파일(byte , byte[])
-> 
FileInputStream
-> read() 사용
DataInputStream



Data -- Stream = Decorator
File -- Stream = Data Sink Stream class


<strong>Decorator Design Pattern의 계층도 : I/O Stream</strong>


InputStream {
  FileInputStream{ // 기능을 추가해주는 class
    DataInputStream
  }
}


<strong>기능 확장법</strong>


1. 상속

A {
  public void run() {달려라}
  public void stop() {}
}
B extends A {
  public void run() {씽씽달려라}
  public void go() {}
}


2. 포함

B {
  run (){}
  stop(){}
}

-> call (위임)

A {
  run (){}
  stop(){}
}


3. 데코레이터

AA { 빵}
  B {크림빵} // 다른 형제 자손에게 기능을 덧붙이는 역할
  
  A {소보루}
  C {팥}
  D {초코}

class B {
  E obj;
  B(E obj) {
    this.obj = obj;
  }
}


new f2(new f1(new a()));

와 같이 중첩사용 가능 


<strong>객체 직렬화</strong>

객체
->write  
ObjectOutputStream
-> serialize(직렬화) = (marshaling) 
FileOutputStream
-> byte 클래스정보+
파일 
->
FileInputStream
->
ObjectInputStream
->deserialize(역직렬화) = (unmarshaling) 


</pre>
<br>
<hr>
<br>
<h1>2023-02-01</h1>
<pre>

<strong>cvs 텍스트 형식으로 출력하기 : FlieReader/FileWriter</strong>


'가'(0xac00(UTF-16)) -> Write(정수) -> FileOutputStream 
-> 맨뒤 1byte 만 출력 (00)


'A'(0x0041(UTF-16)) -> Write(문자코드) -> FileWriter 
  -> JVM 옵션 file.encoding 에 지정된 문자집합의 코드로 변환 (41)


  <strong>텍스트출력</strong>


객체 -> csv형식 텍스트 -> write() -> FileWriter

-> UTF-8 문자코드표에 따라 변환

텍스트 파일

-> UTF-8 문자코드 읽기

FileReader -> read() -> BufferedReader -> 한줄의 문자열로 객체 필드에 저장


<strong>리팩토링: information Expert, factory Method 패턴적용</strong>


Board -> BoardDao -> csv데이터 생성



만약 Board의 필드가 변경 삭제될경우 
BoardDao의 코드를 변경해야한다


BoardDao가 Board 인스턴스를 사용할 때
Board에서 클래스를 변경하면 인스턴스 생성코드를 변경해야한다

=>

직접 객체를 생성하는 대신 Board.create(csv문자열) 호출

즉 메서드에서 생성하는 코드로 만들어서 넘기면 필드가
바뀌더라도 메서드를 사용하는 쪽에서는 변경할게 없다

->


class Student {

// Factory Method 패턴 + Information Expert 패턴
public static Student create(String csv) {
  try {
    String[] values = csv.split(",");

    Student obj = new Student();
    obj.setNo(Integer.parseInt(values[0]));
    obj.setName(values[1]);
    obj.setTel(values[2]);
    obj.setCreatedDate(values[3]);
    obj.setPostNo(values[4]);
    obj.setBasicAddress(values[5]);
    obj.setDetailAddress(values[6]);
    obj.setWorking(Boolean.parseBoolean(values[7]));
    obj.setGender(values[8].charAt(0));
    obj.setLevel(Byte.parseByte(values[9]));

    return obj;

  } catch (Exception e) {
    throw new RuntimeException("Board 객체 생성 오류!", e);
  }
}

// Information Expert 패턴
public String toCsvString() {
  return String.format("%d,%s,%s,%s,%s,%s,%s,%b,%s,%d",
      this.getNo(),
      this.getName(),
      this.getTel(),
      this.getCreatedDate(),
      this.getPostNo(),
      this.getBasicAddress(),
      this.getDetailAddress(),
      this.isWorking(),
      this.getGender(),
      this.getLevel());
  }
}

class StudentDao {

public void save(String filename) {
  try (FileWriter out = new FileWriter(filename)) {

    list.forEach(obj -> {
      try {
        out.write(obj.toCsvString() + "\n");
      } catch (Exception e) {
        System.out.println("데이터 출력 중 오류 발생!");
        e.printStackTrace();
      }
    });

  } catch (Exception e) {
    e.printStackTrace();
  }
}

public void load(String filename) {
  if (list.size() > 0) { // 중복 로딩 방지!
    return;
  }

  try (BufferedReader in = new BufferedReader(new FileReader(filename))) {
    String str = null;
    while ((str = in.readLine()) != null) {
      list.add(Student.create(str));
    }

    if (list.size() > 0) {
      lastNo = list.get(list.size() - 1).getNo();
    }

  } catch (Exception e) {
    e.printStackTrace();
  }
 }
}


<strong>데이터 처리를 별도의 Application으로 분리</strong>


1. 분리전

App-> I/o 파일
App-> I/o 파일
App-> I/o 파일

로컬에 저장한다

문제점
- 각 App마다 파일을 관리하여 데이터공유가 불가능


2. 파일공유

App
App
App

->

computer HDD

여러 App에서 동시에 파일에 접근하여 I/O 수행하면
데이터가 왜곡발생 가능성이 있다


3. 파일 I/O 관리자 도입

App = Client Application
App = Client Application
App = Client Application

-> 요청/응답


App = server Application (관리자)


-> I/O


computer HDD


원격의 App가 파일을 관리하여 App에 접근을 제어한다
이를 통해 데이터가 왜곡되는것을 방지


<strong>Client / Server</strong>


Client
 socket
  -포트번호(port) OS가 자동부여


-> write()/ read()


Server
-포트번호(port) 수동지정
 socket













</pre>
<br>
<hr>
<br>
<h1>2023-02-02</h1>
<pre>

<strong>데이터처리 아키텍처</strong>


client -> (call) BoardDao


기존에는 데이터처리를 Dao에서 진행하였지만
ServerApp로 별도의 application 으로 분리

=>

BoardHandler -> BoardDao 이렇게 사용하는데 BoardHandler에서
Dao를 생성해서 사용한다(강결합) boardDao에서 변경이 생기면 
boardHandler도
변경해야 한다

->  해결책

로우커플링(low coupling)

1. 의존객체를 직성생성하는대신 주입 받기
Dependency Injection(DI)

2. 인터페이스를 통해 관계를 맺는다
-> 즉 직접 클래스를 언급 X


interface BoardDao 
로 변경하여 사용

NetworkBoardDao -> BoardDao 
LocalBoardDao -> BoardDao


class BoardHandler {
  BoardDao boardDao;  // 기존에는 다른 클래스를 사용하면 변경해야한다 
  BoardHandler(BoardDao boardDao){ // 파라미터도 똑같이 바꿔야한다
    this.boardDao = boardDao;
  }
}


하지만 interface를 사용하면 NetworkBoardDao 와
LocalBoardDao로 구현화를 시켜놓고 사용을 하면 
유지보수가 쉽다 
interface를 구현한 객체를 사용  


<strong>client/ Server Protocol</strong>

Clinet <-> Server


Client가 요청
데이터명
액션
파라미터(선택)

Server가 응답
상태코드(문자열)
데이터(Json텍스트)

상태코드(성공200,
 실패400(클라이언트),
 실패500(서버)),
 
 "result": 데이터(문자열,객체,배열)}





Client -> BoardHandler ->call -> NetworkBoardDao(stub = 클라이언트 중계인) 

<-> object Request Broker (ORB) 

Server -> BoardDao -> BoardServlet(skeleton = 서버중계인)


스테이스 풀(예)상담원)  -> 해당 요청이 끝날 때까지 다른 어플리케이션 사용불가
- 해결: thread 를 이용 즉, 상담원 수를 늘린다 

스테이스 리스 (예)114)-> 요청후 연결끊고 다른 어플리케이션이 사용가능 (단 이전에 요청을 다시 읽을수 없다)

커넥션 오리엔테이션

커넥션 리스


</pre>
<br>
<hr>
<br>
<h1>2023-02-03</h1>
<pre>


myapp 

settings.gradle

rootProject.name = 'myapp'
include('app-common')
include('app-client')
include('app-server')

사용할앱 추가


build.gradle

plugins {
  id 'java-library'
}


build.gradle (build scrept file)

dependencies {
  implementation project(':app-common') // 추가
}


<strong>Networking 연결방식</strong>


Connection-Oriented(연결지향) : 
예) 전화,게임,구글미트,유튜브

- 연결과정에서 시간소요
- 연결한 후 데이터 전송 => 신뢰성보장

  프로토콜 => TCP
    - Stateful : SSH,Telnet,FTP,채팅 
      상담전화

        연결 <-(지속)> 끊기 

      - 먼저 연결한 클라이언트가 요청 연결이 길다면 다른 클라이언트가
       오래 기다려야한다

    - Stateless : HTTP1, HTTP2
      114

        연결 -(요청,응답후 종료)> 끊기

      - 한번 연결에 요청,응답 한번만 하고 종료하기 때문에 다른클라이
      언트가 기다리는 시간이 적다

        -쓰레드 : main쓰레드가 클라이언트 요청을 순차적으로 처리

        -멀티 쓰레드 :main 쓰레드가 접수
          여러 쓰레드가 동시처리



Connectionless (비연결성) : 
예) 방송,편지,택배 

- 연결과정이 없다 => 시간절약
- 연결 확인 없이 데이터를 전송 => 신뢰성 낮음

  프로토콜 => UDP


TCP -> UDP로 바뀌면서 시간이 절약된다 


<strong>멀티테스킹 (Multi-tasking)</strong>


1. single-tasking

-cpu를 100% 활용 불가
  - 도커 활용 이유 
    여러서버를 구동하여 cpu의 활용성을 높인다 

cpu -> app -> app2 -> app3
app을 순차적으로 처리 뒤에는 대기

예) 한 종업원이 손님한명이 밥을 다 먹고 나갈때까지
기다리는 경우와 같다 


2. Multi-tasking

- cpu를 시간을 쪼개서 여러앱을 돌아다니며 명령처리 (시분할 시스템)

       app
cpu -> app
       app
      
여러 app이 동시실행하는것처럼 보인다

예) 한 종업원이 손님에게 요구사항을 받아 처리하면
    시간을 쪼개서 다른 손님 요구사항을 처리한다

    
  1) 프로세스 복제방식(fork())

  client -> Server (부모프로세스)

  -> server (자식프로세스 를 생성 하여 처리)

  - 문제점
    1. 프로세스(서버프로그램)가 사용하는 메모리도 그대로 복제 
    -> 메모리 낭비가 심하다

    2. 부모프로세스가 종료하더라도 자식 프로세스는 종료하지 않음
    -> 복제한 자식프로세스의 제어가 힘들다


  2) 멀티 쓰레드 방식 

  client -> Server 

  -> Thread (쓰레드가 요청을 처리)

  - 프로세스의 힙 메모리 를 공유한다
  -> 메모리 낭비 적다
  - 프로세스 종료시 쓰레드도 종료


<string>JVM과 쓰레드</string>

JVM (프로세스) -> main (Thread) -> main()

- 실행흐름이 한줄로 이어진 실(Thread) 과 같다  


계층도

system(TG)
  ==> Reference Handler(T)
  ==> Finalizer(T)
  ==> Signal Dispatcher(T)
  ==> Attach Listener(T)
  ==> Notification Thread(T)
  main(TG)
    ==> main(T)
  InnocuousThreadGroup(TG)
    ==> Common-Cleaner(T)


<strong>부모 쓰레드와 자식 쓰레드</strong>


main(Thread) -> main() -> { new(Thread)생성 -> }


<strong>cpu scheduling</strong>

-프로세스에게 cpu를 배정하는 방법

     프로세스
OS-> 프로세스
     프로세스
        쓰레드1
        쓰레드2
        쓰레드3


프로세스 의 명령을 실행하고 순서나 시간을 제어
이때 쓰레드 또한 순서와 시간을 제어한다


1. Round - Robin (Windows OS)
  - 모든프로세스를 통일한 시간으로 나눠 실행한다
  - 우선순위가 실행에 영향을 끼친다
  
2. Priority + Aging 기법 (Linux, Unix)
  - 우선순위가 높은 프로세스에게 실행회수나 시간을 더 부여한다
  - 우선 순위가 실행에 영향을 끼침


<strong>cpu 스케줄링과 Context Switching</strong>


- 실행정보와 명령을 cpu케시 메모리에 적재하는것

CPU 
  L1 (명령어)
  L2 (데이터)


OS

프로세스 A
  실행
프로세스 B
  실행
프로세스 C
  실행


- cpu 스케줄링 정책에 따라 프로세스가 돌아가면서 실행되면
  이전프로세스 실행정보와 명령을 케시메모리에 저장

  -> 즉 너무 많이 프로세스가 실행되면 Context Switching
     시간이 더 많이 소요되기 때문에 비효율적이 된다  


<strong>Creitical Region = Critical Section</strong>


-여러 쓰레드가 동시에 실행할 때 문제가 발생할 수 있는 코드 영역
=> synchronized 를 사용하여 lock을 걸어 동시 진입을 제어한다 
   (단점: 병목현상이 발생할 수 있다
    -> 현상이 발생하지 않는 코드는 Thread safe 라고 부른다)


화장실 (Critical Section)
- Semaphore(5)
- 동시에 5명까지 진입가능

  1번칸 (Critical Section)
  - Semaphore(1)
  - 동시에 1명까지 진입가능
  2번칸
  3번칸


Mutual Exclusion(상호배제) Mutex => 오직 한개만 선택  
예) 라디오채널,티비채널



</pre>
<br>
<hr>
<br>
<h1>2023-02-06</h1>
<pre>


<h2>Database, DBMS, SQL</h2>


<strong>DBMS를 사용하는이유</strong>

- 직접 파일 I/O를 프로그래밍 할 필요가 없다
- 데이터를 체계적으로 관리할 수 있다
- 프로그래밍 도구에 상관없이 일관된 방법으로 다룰 수 있다


<strong>Database</strong>

- 통합 관리되는 데이터의 집합체
  데이터 구조화 -> 중복제거

- 특징

  1. 사용자 질의 -> 즉각적응답
  2. 생성,수정,삭제를통한 최신상태 유지
  3. 여러사용자가 동시 공유
  4. App 에서 분리 -> 독립적으로 동작


<strong>DBMS</strong>

- Database 관리 App

  1. 데이터베이스정의 data의 형식,구조,제약 조건등을 정의
  2. Data를 파일에 쓰고/읽기
  3. Data 조작(manipulation)
  4. 공유
  5. 접근 제어를 통한 보호

사용자 <-> DBMS  

App <-> DBMS

- 사용자와 App가 요청,응답 하는 데이터를
  변경,관리,삭제하는 역할을 한다 

- SQL (Structured Query Language)
  DBMS에 작업요청할때 사용하는 명령문법


<h2>DBMS 학습</h2>

1. DBMS 설치및 설정

  해외

  - Oracle
  - DB2
  - MS-SQL
  - MYSQL
  - MAriaDB

  국내

  - Altibase
  - tibero
  - Cubrid


2. Database 추가 및 권한 부여

  >mysql -u -root -p   //접속 하기 
  >mysql -u -study -p
  패스워드 입력 

  로컬 사용자를 만들기:
  > CREATE USER 'study'@'localhost' IDENTIFIED BY '1111';

  원격 사용자를 만들기:
  > CREATE USER 'study'@'%' IDENTIFIED BY '1111';

  MySQL 데이터베이스 생성
  > CREATE DATABASE studydb CHARACTER SET utf8 COLLATE utf8_general_ci;

  사용자에게 데이터베이스 접근권한 부여 
  > GRANT ALL ON studydb.* TO 'study'@'localhost';  
  > GRANT ALL ON studydb.* TO 'study'@'%';  

  데이터베이스 목록 조회
  > show databases;

  사용자 교체
  > quit    (프로그램 종료 후)
  > mysql -u study -p   (다시 실행)

  기본으로 사용할 데이터베이스 지정하기
  > use 데이터베이스명
  > use studydb;

  데이터베이스의 전체 테이블 목록 조회
  > show tables;

  구조 출력
  > desc test1;


3. SQL 작성법

SQL
- DBMS에 데이터 처리 명령을 내릴때 사용하는 명령표준 문법

실무SQL
- SQL표준 문법 + DBMS 고유 문법

=> DBMS 마다 SQL 문이 약간씩 다르다
   App 작성할 때 DBMS에 맞춰 SQL을
   작성 해야한다

용어정리

  SQL -> DDL (Data Definition language)
        - 테이블,뷰,프로시저,함수,트리거,등을 정의,변경,삭제

        테이블 생성
  create table 테이블명 (
    컬럼명 타입 NULL여부 옵션,
    컬럼명 타입 NULL여부 옵션,
    ...
    컬럼명 타입 NULL여부 옵션
  );

예)
  create table test01 (
    name varchar(50) not null,
    kor int not null,
    eng int not null,
    math int not null,
    sum int not null,
    aver float not null
  ); 

  create table test1(
    c1 char(1),
    c2 int,
    c3 boolean
    c4 int default 20
    );

  

  - 데이터를 구분할 때 사용하는 컬럼들의 집합
  - 예)
    - {email}, {jumin}, {id}, {name, tel}, {tel, basic_addr, gender, name}
    - {name, jumin}, {email, id}, {id, name, email} ...

- candidate key (후보키 = 최소키)
  - key 들 중에서 최소 항목으로 줄인 키
  - {jumin}, {email}, {id}, {name, tel}
  
  - Primary

  - key
  - 데이터를 구분할 때 사용하는 컬럼들의 집합
  - 예)
    - {email}, {jumin}, {id}, {name, tel}, {tel, basic_addr, gender, name}
    - {name, jumin}, {email, id}, {id, name, email} ...
- candidate key (후보키 = 최소키)
  - key 들 중에서 최소 항목으로 줄인 키
  - {jumin}, {email}, {id}, {name, tel}

#### alternate key vs primary key

- primary key (주 키)
  - candidate key 중에서 DBMS 관리자가 사용하기로 결정한 키
  - 예) DBMS 관리자가 id 컬럼의 값을 데이터를 구분하는 키로 사용하기로 결정했다면,
    - 주 키는, {id} 가 된다.
    - 주 키로 선택되지 않은 모든 candidate key는 alternate key가 된다.
- alternate key (대안 키)
  - candidate key 중에서 primary key로 선택된 키를 제외한 나머지 키.
  - 비록 primary key는 아니지만, primary key 처럼 데이터를 구분하는
    용도로 대신 사용할 수 있다고 해서 **대안 키(alternate key)** 라 부른다.

#### artificial key (인공키)

- Primary key로 사용하기에 적절한 컬럼을 찾을 수 없다면,
  - 예) 게시글 : 제목, 내용, 작성자, 등록일, 조회수
- 이런 경우에 key로 사용할 컬럼을 추가한다.
- 보통 일련번호를 저장할 정수 타입의 컬럼을 추가한다.
  - 예) 게시글 : 게시글 번호
- 대부분의 SNS 서비스들은 일련의 번호를 primary key 사용한다.
- 왜?
  - 회원 탈퇴의 경우,
    - 회원 탈퇴할 때 아이디도 제거한다.
    - 아이디를 지우면 그 아이디와 연결된 게시글을 지워야 한다.
    - 그런데 회원 아이디 대신 일련 번호를 사용하면,
    - 그 회원이 쓴 게시글은 일련번호와 묶인다.
    - 따라서 아이디가 삭제되더라도 해당 글은 계속 유효하게 처리할 수 있다.
  - 이메일 변경,
    - primary key 값은 다른 데이터에서 사용하기 때문에,
      - 예) 게시글을 저장할 때 회원 이메일을 저장한다고 가정하자.
    - pk 값을 변경하면 그 값을 사용한 모든 데이터에 영향을 끼친다.
    - 그래서 PK 값을 다른 데이터에서 사용한 경우,
      DBMS는 PK 값을 변경하지 못하도록 통제한다.
    - 이렇게 변경될 수 있는 값인 경우, PK로 사용하지 말라.
    - 대신 회원 번호와 같은 임의의 키(인공 키)를 만들어 사용하는 것이 좋다.


      -> DML ()
        - 테이블에 데이터를 입력,변경,삭제등 데이터 조작

      -> DQL ()
        - 테이블의 데이터 조회


4. DBMS API 사용법

사용자 -(SQL입력)> DBMS client -(SQL요청)> DBMS -(데이터처리)> Database -> 파일


사용자 -(입력)> App -(call)> DBMS API -(요청,통신,응답)> DBMS
                ㄴ> 개발자가 작성  ㄴ>다운로드




















</pre>
<br>
<hr>
<br>
<h1>2023-02-07</h1>
<pre>

컬럼 값 자동 증가

- 숫자 타입의 PK 컬럼 또는 Unique 컬럼인 경우 값을 1씩 자동 증가시킬 수 있다.
- 즉 데이터를 입력할 때 해당 컬럼의 값을 넣지 않아도 자동으로 증가된다.
- 단 삭제를 통해 중간에 비어있는 번호는 다시 채우지 않는다.
  즉 증가된 번호는 계속 앞으로 증가할 뿐이다.

- 테이블 생성

create table test1(
  no int not null,
  name varchar(20) not null
);


- 특정 컬럼의 값을 자동으로 증가하게 선언한다.
- 단 반드시 key(primary key 나 unique)여야 한다.

alter table test1
  modify column no int not null auto_increment; /* 아직 no가 pk가 아니기 때문에 오류*/

alter table test1
  add constraint primary key (no); /* 일단 no를 pk로 지정한다.*/

alter table test1
  add constraint unique (no); /* no를 unique로 지정해도 한다.*/

alter table test1
  modify column no int not null auto_increment; /* 그런 후 auto_increment를 지정한다.*/


- 조회

select no, name, class from test1 where working = 'Y';

- 특정 조회를 가상 테이블로 만들기 (보여주는것이때문에 테이블의 값의 영향을 받음)

create view worker
  as select no, name, class from test1 where working = 'Y';

- 뷰 조회,삭제는 테이블과 동일



<strong>제약 조건 조회</strong> 

MariaDB [studydb]> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| studydb            |
+--------------------+

use information_schema; // Database
로 변경후 사용


<strong>information_schema</strong>

- INFORMATION_SCHEMA란 MySQL 서버 내에 존재하는 DB의 메타 정보(테이블, 칼럼, 인덱스 등의 스키마 정보)
를 모아둔 DB다. INFORMATION_SCHEMA 데이터베이스 내의 모든 테이블은 읽기 전용이며, 단순히 조회만 가능하다. 즉, 읽기전용(Read-only)으로 사용자가 직접 수정하거나 관여할 수는 없다.

1) 테이블의 제약 조건 조회

select table_name, constraint_name, constraint_type
from table_constraints;


2) 테이블의 키 컬럼 정보 조회

select table_name, column_name, constraint_name
from key_column_usage;


3) 테이블과 컬럼의 키 제약 조건 조회

select
  t2.table_name,
  t2.column_name,
  t2.constraint_name,
  t1.constraint_type
from table_constraints t1
  inner join key_column_usage t2 on t2.constraint_name=t1.constraint_name;


<strong>commit/ rollback</strong>


1. auto commit 상태 

임시DBMS에 저장된입력,변경,삭제를 테이블에 즉시 적용
inert,update,delete 등을 하면 DBMS가 table에 바로 적용


2. 수동 commit

입력, 변경,삭제 결과는 임시DBMS에서 보관
commit 명령을 받으면 보관된 정보를 실제 
테이블에 적용시킨다 

서버에 select를 요청하면 DBMS는 table 정보와
임시DBMS 에 있는 내용을 적용


3. rollback

임시 DBMS에 있는 정보들을 지운다
즉 commit 전상태라면 변경된 정보가 지워진다


<strong>Transaction</strong>

-여러개의 데이터 변경작업(insert,update,delete)을 한 단위로 묶은것
             
예) 여러개의 작업을 한 단위로 다뤄야하는 경우 
    즉 주문->결제 => 주문 완료 


<strong>select: projection/ selection</strong>

특정 컬럼의 값만 조회할 때 => "프로젝션(projection)"이라 부른다

select 컬럼명,컬럼명 from 테이블;
select no, name, tel from test1 where working name='홍길동';


특정 날짜의 게시글 찾기 

// Datetime 타입일경우

 select *
from test1
where regdt = '2022-6-17';


특정 기간의 게시글 조회 

select *
from test1
where regdt between '2022-11-1' and '2022-12-31';


// 날짜 기준이기 때문에 고려해서 사용하여야 한다

select *
from test1
where regdt >= '2022-11-1' and regdt <= '2022-12-31';


<strong>첨부파일 저장</strong>


1. DBMS에 파일저장

Client -> Server -> DBMS -> 테이블

1) 파일을 꺼낼때 DBMS를 경유하기 때문에 속도가 느리다
2) 데이터베이스의 크기를 급격하게 늘린다 
=> 비효율적이다

2. DBMS에 파일 경로에 저장

Client -> Server -> DBMS -> 테이블
                 -> HDD

- 특정 컬럼에 파일이 저장된 경로만 입력한다

  1) 데이터베이스가 급격하게 커지지 않는다
  2) 파일을 OS가 읽기 때문에 속도가 빠르다


<strong>첨부파일과 테이블</strong>


고민해볼 사항!
- 첨부 파일의 개수를 5 개로 정해 놓았다.
- 따라서 최대 5개의 첨부 파일만 테이블에 저장할 수 있다.
- 첨부파일이 없더라도 5개의 컬럼은 메모리를 차지한다.

실무에서 원하는 것!
- 첨부 파일의 개수에 제한을 받고 싶지 않다.
- 첨부 파일 개수만큼만 값을 저장하고 싶다.

이렇게 같은 데이터를 저장할 컬럼이 중복된 경우에는,
- 중복 컬럼을 별도의 테이블로 분리한다.
- 중복 컬럼의 값이 어느 테이블의 어느 데이터의 값인지 지정한다.


no title content rdt file1 file2 file3 file4 file5
--------------------------------------------------
1 | aaa |       |   |a.gif|     |     |     |     | // 4개 낭비
2 | bbb |       |   |b.gif|c.gif|     |     |     | // 3개 낭비
3 | ccc |       |   |     |     |     |     |     | // 5개 낭비
4 | ddd |       |   |a.gif|b.gif|c.gif|d.gif|e.gif|

5개의 컬럼이 생성되기때문에 사용하지 않는 컬럼이 낭비된다


insert into test1(title, content, filepath1,filepath2,filepath3,filepath4,filepath5)
values('제목1', '내용', 'a.gif', null,null,null,null);

insert into test1(title, content, filepath1,filepath2,filepath3,filepath4,filepath5)
values('제목1', '내용', 'b.gif', 'b1.gif','b2.gif',null,null);

insert into test1(title, content, filepath1,filepath2,filepath3,filepath4,filepath5)
values('제목1', '내용', null, null,null,null,null);

-- 파일 경로를 저장할수 있는 컬럼이 5개 밖에 없기 때문에 6,7번째 파일을 입력할수 없다
insert into test1(title, content, filepath1,filepath2,filepath3,filepath4,filepath5)
values('제목1', '내용', 'd1.gif','d2.gif','d3.gif','d4.gif','d5.gif'/*,'d6.gif','d7.gif'*/);


<strong>게시글 데이터와 첨부파일 데이터를 쪼개기</strong>


게시글 테이블(부모테이블) = entity

+----+-------+---------+---------------------+
| no | title | content | rdt                 | // no = primary Key (PK)
+----+-------+---------+---------------------+
|  2 | bbb   | NULL    | 2023-02-07 16:18:48 |
|  3 | ccc   | NULL    | 2023-02-07 16:18:48 |
|  4 | ddd   | NULL    | 2023-02-07 16:18:48 |
|  5 | eee   | NULL    | 2023-02-07 16:18:48 |
|  6 | fff   | NULL    | 2023-02-07 16:18:48 |
|  7 | ggg   | NULL    | 2023-02-07 16:18:48 |
|  8 | hhh   | NULL    | 2023-02-07 16:18:48 |
|  9 | iii   | NULL    | 2023-02-07 16:18:48 |
| 10 | jjj   | NULL    | 2023-02-07 16:18:49 |
+----+-------+---------+---------------------+


첨부파일 테이블(자식테이블)

+-----+-------------------+-----+
| fno | filepath          | bno | // bno = Foreign Key(FK)
+-----+-------------------+-----+ //  다른 테이블 key 값을 저장하는 컬럼
|   1 | c:/download/a.gif |   1 |
|   2 | c:/download/b.gif |   1 |
|   3 | c:/download/c.gif |   1 |
|   4 | c:/download/d.gif |   5 |
|   5 | c:/download/e.gif |   5 |
|   6 | c:/download/f.gif |  10 |
|   7 | c:/download/x.gif | 100 |
+-----+-------------------+-----+


Entity Relationship Diagram (ERD)


다른 테이블을 참조하고 제어하는 문법 

기존에 테이블에 무효한 데이터가 있을 수 있기 때문에 먼저 테이블의 데이터를 지운다.
delete from test2;

fk 컬럼을 설정하기 전에 무효한 데이터를 삭제해야 한다. 
alter table test2
    add constraint test2_bno_fk foreign key (bno) references test1(no);

IE표기법


<strong>테이블 조인 : 테이블 ERD</strong>


mgr(매니저)
mno(FK)
->

mno(PK)
memb(회원기본정보)
mno(PK)

->

mno(FK)
stnt(학생)
mno(PK)

->

mno(FK)
lect_appl(수강신청)
lno(FK)

->

lno(PK)
lect(강의)
rno(FK)

->

rno(PK)
room(강의실)
rno(PK)

->

rno(FK)
room_phot(강의실 사진)

</pre>
<br>
<hr>
<br>
<h1>2023-02-08</h1>
<pre>


<h3>테이블 관계: addr ㅣ-- ok memb</h3>


addr 

  ano(pk)  pst_no  bas_addr
    1       1111    강남구
    2       1112    서초구
    3       1113    광진구


memb

  mno(pk)   name    tel   ano(fk)
   1        홍길동  111    2
   2        임꺽정  222    2
   3        유관순  333    1
   4        안중근  444    .


addr ㅣ- ok memb
=>
1 : 0 이상
-ㅣ--ok- 


<strong>관계차수에 따른 표기법</strong>

1 : 0 Ehsms 1  
-ㅣ--oㅣ-

1 : 1  
-ㅣ--ㅣ-

1 : 0 이상
-ㅣ--ok- 

1 : 1 이상 
-ㅣ-- ㅣk


식별관계(identifying) = 실선
FK = PK

비식별관계(non-identfying) ---------------- = 점선
FK != PK


<strong>테이블 관계: stnt -ㅣo-- ㅣ- memb</strong>


stnt
- 회원중에서 학생회원의 추가정보를 저장하는 테이블

  mno(fk = pk)   work    acc_no    bank
   1              Y        -         -
   2              N        -         -
   4              Y        -         -


stnt -ㅣo-- ㅣ- memb

ㅣo
- 0..1
- 0,1

ㅣ
- 1

이라고 표기 0이상은 ,또는 .. 으로 표기한다


<strong>테이블 관계: stnt -ok-- ok- lect</strong>
-다 대 다 (n : n)

lect

  lno(pk)       titl      sdt   edt
   101         자바기초    -     -
   102         네이버      -     -
   103         파이썬      -     -


lect-appl

  (mno(fk)   lno(fk) pk)
    1         101
    1         103
    4         101
    4         102
    4         103
    1         101  // 중복신청


- 중복신청 을 막기위해 mno와 lno를 pk로 묶어준다 


stnt -ㅣ--ok- lect-appl k--ㅣ- lect

stnt
- 부모테이블

lect-appl
- 관계테이블
    두테이블의 관계를 저장한다보통 
    다대다 관계를 해소하기 위해 만듬
- 자식테이블

lect
- 부모테이블


<strong>DB 모델링</strong>

DB모델링

-> 데이터를 잘게 쪼갠다
   데이터간의 관계를 정의한다

=> 데이터 중복 제거
    
    1. 데이터 관리가 힘들다 여러 곳에 같은 데이터가 저장
       변경하려면 여러 곳을 변경해야한다 

    2. 변경 누락 발생 -> 데이터 결함 발생


<strong>실행 순서</strong>


-- 실행 순서: from -> where -> select -> order by
-- 1) from 또는 join: 테이블의 전체 데이터 또는 조인 데이터
-- 2) where: 조건에 따라 결과로 뽑을 데이터를 selection 한다
-- 3) group by : 조건에 따라 뽑은 데이터를 특정 컬럼을 기준으로 데이터를 묶는다
-- 4) having : 그룹을로 묶은 데이터를 조건에 따라 선별한다
-- 5) select : 최종 결과로 뽑을 컬럼을 표시(projection)한다. 표현식으로 계산한 컬럼도 포함
-- 6) order by : select 절에서 추가한 임의 컬럼이나 테이블 컬럼을 기준으로 정렬
-- 7) limit : 결과 데이터에서 지정한 범위의 데이터를 선택한다
-- 8) 결과추출 : 7번을 수행한 결과 데이터에서 5번에 표시된 컬럼만 추출한다


<strong>JOIN</strong>

1. cross join = cartesian join

A{
  a,b,c
}

B{
  a,b,c
}


2. natural join

     board         attach_file
bno  title      fno   path    bno
 1    aaa       100   a.gif    1
 2    bbb       101   b.gif    1
                102   c.gif    2

같은 이름을 가진 컬럼의 값을 기준으로
두 테이블의 데이터를 합친다

1    aaa       100   a.gif    1
1    aaa       101   b.gif    1
2    bbb       102   c.gif    2


3. join~on

    board         attach_file
 no  title       no   path    bno
 1    aaa       100   a.gif    1
 2    bbb       101   b.gif    1
                102   c.gif    2


두 테이블의 데이터를 join 하는 기준이 컬럼의 이름이 다를경우 사용하는 문법 
=> (pk컬럼명 != fk컬럼명)

1    aaa       100   a.gif    1
1    bbb       101   b.gif    1
2    bbb       102   c.gif    2



</pre>
<br>
<hr>
<br>
<h1>2023-02-09</h1>
<pre>


<h2>DBMS API : Vendor API(Native API)</h2>

app <-(call,return)> oracle API <-(요청, 응답)> oracle 
- DBMS 제조사에 제공

app <-(call,return)> MS-SQL API <-(요청, 응답)> MS-SQL

app <-(call,return)> MS-SQL API <-(요청, 응답)> MySQL
- C/C++ -> (.dll(Dynamic Link Library) .lib)windows (.so(shared object))unix
=> static libraty = dynamic library

** DBMS마다 API 사용법이 다르다
=> DBMS에 맞춰서 프로그래밍 해야한다

app -> .lib(print(),System())
=> .exe(실행파일) 

2개를 실행

Process {
  app+.lib
}

Process {
  app+.lib
}

app2 -> .lib(print(),System())
=> .exe(실행파일) 

2개를 실행

Process {
  app+.lib
}

Process {
  app+.lib
}


위와 같은 상황이라면 메모리에 .lib가 중복 로딩된다

static library(정적라이브러리)

- 프로그램실행시 무조건 실행되기때문에 
  중복실행이 가능하다 
=> 메모리 낭비


이런 메모리 낭비를 방지하기위해

dll정보를 .lib 와 대체하고 이 정보들을 다루는 .dll .so
를 공유하여 사용하면 메모리를 효율적으로 사용할수 있다


<strong>메소드가 실행되는 방법</strong>

JVM -(call)> OS -> computer -> 모니터 

- 자바에서 메소드를 호출하면 JVM이 메소드를 해당 OS에 있는 메소드에 
  맞춰서 호출 것이다 그래서 속도가 느리다 하지만 사용하기 편하다

  이때 c,c++은 직접적으로 접근하기 때문에 속도가 빠르다 하지만 
  OS마다 메소드명이 다르기 때문에 사용하기 복잡하다


<strong>ODBC API 명세 -> ODBC Driver(.dll/.lib/.so) </strong>
Open
Database
Connectivity

- DBMS API 명세서

app 

-> API 사용법이 ODBC Driver로 인해 통일되어
   DBMS마다 따로 개발할 필요가 없다 


oracle ODBC API 구현 <-(call,return)> oracle API <-(요청, 응답)> oracle 

MS-SQL ODBC API 구현 <-(call,return)> MS-SQL API <-(요청, 응답)> MS-SQL

MYSQL ODBC API 구현 <-(call,return)> MS-SQL API <-(요청, 응답)> MySQL

Excel ODBC API 구현 - (I/O) > Excel 

() ODBC API 구현 (c/c++를 사용)
- ODBC API 규격에 맞춰 함수 구현 => "ODBC Driver"


<strong>JDBC API(인터페이스) -> JDBC Driver(클래스) </strong>

Type1 = 'ODBC-JDBC 프릿지'

JAVA APP 

->

JVM JDBC type1 Driver
- JDBC API 인터페이스 구현
- JRE에 기본 포함

JDK { 
  컴파일러
  프로파일러
  +
JRE {
  JVM + library
  }
}

문제점
- local에 ODBC Driver를 설치해야한다

->

oracle ODBC API 구현 <-(call,return)> oracle API <-(요청, 응답)> oracle 

MS-SQL ODBC API 구현 <-(call,return)> MS-SQL API <-(요청, 응답)> MS-SQL

MYSQL ODBC API 구현 <-(call,return)> MS-SQL API <-(요청, 응답)> MySQL

Excel ODBC API 구현 - (I/O) > Excel 

Apache poi
  

Type2 = 'Native API call'

JABA app

-> API 사용법이 같기 때문에 따로 프로그램을 짤 필요가 없다

oracle JDBC Type2 Driver <-(call,return)> oracle API <-(요청, 응답)> oracle 

MS-SQL JDBC Type2 Driver <-(call,return)> MS-SQL API <-(요청, 응답)> MS-SQL

MYSQL JDBC Type2 Driver <-(call,return)> MS-SQL API <-(요청, 응답)> MySQL


() JDBC Type2 Driver
- Vendor 에서 사용 -> 다운로드 해야한다
- Native c/c++ API 호출 -> local Vendor API 가 있어야 한다
=>
문제점
- DBMS를 변경하면 local에 Vendor API를 교체해야한다
- Type2 JDBC Driver를 교체


Type3 = 'network Driver'


JABA app
- JDBC Driver를 다른타입으로 교체해도 API는 같기 때문에
프로그램을 새로 짤 필요가 없다
즉 app은 (드라이버타입) 과 아무상관없다

-(call)>

JDBC Driver 중계서버 통신용 JDBC Type3 Driver
- JDBC API 규격에따라 만든 구현체
- DBMS 를 교체 하더라도 영향을 받지 않는다
- 중계서버에서 제공 
  즉 중계서버를 교체하면 드라이버도 바꿔야한다
- 중계서버를 따로 구매하여 비용증가
- 중계서버를 경유하기 때문에 실행속도가 떨어진다

->

JDBC Driver 중계서버

-> 

oracle JDBC Driver <-(call,return)> oracle API <-(요청, 응답)> oracle 

MS-SQL JDBC Driver <-(call,return)> MS-SQL API <-(요청, 응답)> MS-SQL

MYSQL JDBC Driver <-(call,return)> MS-SQL API <-(요청, 응답)> MySQL

=>

로컬 {
  JAVA APP
  중계서버 통신용 JDBC Type3 Driver
}

서버2(middleware) {
  JDBC Driver 중계서버
  oracle JDBC Driver
  oracle API
}

서버1 {
  oracle
}


위 과정은 로컬과 서버2,서버1과 나눠서 요청,응답을 처리하기 때문에 속도가
느리다 그리고 서버2의 중계서버가 로컬의 통신용 중계서버를 제공하기 때문
에 중계서버가 바뀌면 통신용도 바꿔야한다  


type4 = 'Network Protocol driver'


JAVA App 

->

-> oracle Type4 Driver -> oracle 

-> MS-SQL Type4 Driver -> MS-SQL

-> MySQL Type4 Driver -> MySQL

() Type4 Driver
- DBMS Vendor에서 제공 -> 다운로드 해야한다
- DBMS와 직접 통신하기 떄문에 local에 설치할게 없다
  즉 c/c++과 같은 특정 OS에 종속되는 API를 사용하지 않는다
  => "pure JAVA" 


<h2>JDBC Driver 사용법</h2>


(1)
getconnection(JDBC URL(DBMS주소),ID,PWD) -> DriverManager (파일 경로: java.sql)

-(2)>
                                       (13)
(3)                                    (7)
createStatement() -> Connection 구현체 <-> T(Thread) DBMS
                                       (8)
-(4)>                                  (14)
<(6)-
(12)

(5)
executeQuery(select문) 
            <->        Statement 구현체
executeUpdate(insert,update,delete)


-(9)>
<(11)-

(10)
next() 
            <->           ResultSet구현체 //(15) 서버에서 가져온 다음레코드의 각컬럼값 보관
getxxx(컬럼명,컬럼번호)
(16)


<strong>Application Architecture</strong>


Client -> BoardHandler -> BoardDao 
                             <-
                              JdbcBoardDao <-> (T) DBMS





</pre>
<br>
<hr>
<br>
<h1>2023-02-10</h1>
<pre>

<h2>DB커넥션 공유</h2>


JDBCBoardDao

insert()
  Connetction 생성: 연결
    1. Anthentication(이름) : 사용자가 유효여부 검사
    2. Authorization(권한) : 사용자의 권한 검사
      예) 
      delete 접근가능?
      
      <strong>시스템간의 데이터 공유</strong>

      인사시스템 -> HR database // all 권한
          처리<->요청
      회계시스템 -> 회계 database // all 권한

      위와같은 상황에서 인사시스템의 database에 접근하여 모든 데이터
      접근을 막고 요청한 데이터에만 접근할 수 있게하는 방법 
      select권한만 부여한 아이디를 생성해준다

      문제점 권한검사하는 시간이 많이 걸린다
      -> 
      해결방법 : DB커넥션 공유

      1.
      - Vendor가 달라 DB접근차단
      - platorm이 다르다(C# : java) oson,xml로 데이터를 주고 받음 
      => 이기종 시스템과 데이터교환
      => system Integration(SI)
        
        회계시스템계발자의 경우
        - 인사시스템으로부터 직원정보를 받아서 처리하는 기능개발
          즉 기존 시스템과 연계

        인사시스템 유지보수 개발자
        - 회계시스템에서 요청한 서비스를 개발 기존시스템에 새로운
          기능 추가(SM)
         
     
  SQL 전달
  결과리턴 및 연결 끊기


findAll()
  Connetction 생성: 연결
  SQL 전달
  결과리턴 및 연결 끊기


<->

DBMS


<h2>Application server Architecture</h2>


1. 기존방식
  - 기능 추가,변경,삭제를 한다면 모든 pc에서 재설치 해야한다
  - App의 기능변경이 잦은경우 
    즉 유지보수가 힘들다
  

pc1 App

pc2 App

pc3 App


2. App을 서버에서 실행
  - APPlication Server(AS)
  - 서버만 변경하면 된다
  - 사용자 입력을 받아서 서버에 전달하면 서버 응답을 출력
  
  서버에서 실행하게 바꾼 이유?
   - 세계화인한 경쟁이 치열해지고 제품들의 생명주기가 짧아졋다
     이러한 상황때문에 app기능변경이 잦아져 서버만 바꾸면 되는
     방식을 사용
  

pc1 client 
  - 사용자 입력을 서버에 전달
  - 서버 응답을 출력  

pc2 client

pc3 client

<->

Server
  - 기능실행
  - UI 생성

  
<strong>통신 규칙 (protocol)</strong>


client

server


<strong>전송</strong>

이전방식

writeUTF() -> readUTF()


개선방식

print() -> 버퍼 -> writeUTF() -> readUTF()

  <strong>StringWrite 의 활용</strong>

  PrintWrite -> StringWrite -> 버퍼
    print()
    printf()
    println()
    ...




</pre>
<br>
<hr>
<br>
<h1>2023-02-13</h1>
<pre>

<strong>Desktop Application 과 Application server </strong>

Desktop App

  Standalone App
  - 지뢰찾기,메모장,포토샵,eclipseIDE


  client/server
  - 게임,메일,git


Application

- 기능변경이 쉽다
  서버쪽만 변경하면 된다
  클라이언트를 재설치 할 필요가 없다

중앙에서 권한관리 -> 보안 관리가 쉽다

서버에서 모든 기능을 실행
-> thin client 예) 크롬북


사용자 -> web Browser -> webserver -> app -> DBMS


<h2>트랜잭션 다루기</h2>


app_member
a
b
c

  app_student
    a
    b
    c

  app_teacher
    c


포함관계 (inclusive relationship)
- 회원데이터는 학생과 강사 데이터와 동시에 관련될수 있다
  c는 student이면서 teacher인 경우 이런식으로 표현 



app_member
1.홍길동
2.임꺽정
3.유관순
4.유관순

  app_student
    1.홍길동
    4.유관순

  app_manager
    2.임꺽정
    
  app_teacher
    3.유관순


배타적관계 (exclusive relationship)
- 회원데이터는 학생,매니저,강사중 하나의 데이터 하고만 관련될 수 있다
  유관순경우 student따로 teacher따로 만들어야한다


<h2>DAO 와 테이블</h2>


이전방식

studentHandler -> studentDao -> app_student<table> 


변경방식

studentHandler -> memberDao -> app_student<table> 


<strong>Handler - DAO - Table</strong>
  
owner 
- 변경권한 : insert/update/delete

Dao -(owner)> table

이때 테이블이 작고 관리가 용이한 경우 한개의 Dao가 두개의 테이블의 
ownership을 가질수 있다 하지만 한개의 테이블이 1개 이상의 Dao를 가
지는것은 관리가 어려워진다  


Handler -> Dao -(owner)> table

한개의 Handler가 다른 Handler를 다루면 안된다




</pre>
<br>
<hr>
<br>
<h1>2023-02-14</h1>
<pre>

<h2>멀티스레드 환경에서의 DB 커넥션</h2>


이전방식

c1 -> (T) -> BoardHandler -> BoardDao -> Connection -> (T) -> Table(DBMS)


c1 -> (T)-> connection -> (T) -> Table(DBMS)
c2 ->
c3 ->

현재 상황에서는 DB connection을 공유하기 때문에 c중 하나가 rollback을
하면 그전까지 작업한 내용도 rollback된다 


<h3>멀티스레드가 DB커넥션을 공유할 때 발생하는 문제점</h3>


c1 -> (T) -> Con -> (T)
member insert
student insert
30초간 정지
commit

c2 -> (T) -> Con -> (T)
member insert
teacher insert 오류


<h4>Thread 별로 Connection 관리</h4>

Connection 공유시

- 여러 Thread가하는 작업이 한곳에서 이루어 지기때문에 
  rollback된다면 다른 Thread작업도 같이 없어진다

->

스레드 별로 Connection 관리

- Thread마다 Connection을 따로 사용한다

  문제점 
    - garbage가 많이 생긴다
    - Connection 생성에 시간소요()


ConnectionFactory
  - getConnection()
  - ThreadLocal<Connection>


- Thread별로 킵해둔 Connection을 꺼낼 공장을 만든다
  

public class ConnectionFactory {
  String jdbcUrl;
  String username;
  String password;


  // 스레드 전용 변수
  // => 스레드마다 별도로 존재하는 변수
  // => connection 객체를 담는 변수
  ThreadLocal<Connection> conLocal = new ThreadLocal<>();

  public ConnectionFactory(String jdbcUrl, String username, String password) {
    this.jdbcUrl = jdbcUrl;
    this.password = password;
    this.username = username;
  }

  public Connection getConnection() throws Exception {
    // 현재 이 명령을 실행하는 스레드에 마련된 conLocal 변수에서 값을 꺼낸다
    Connection con = conLocal.get();

    if (con == null) {

      // 현재 스레드 변수에 값이 Connection 객체가 들어 있지 않다면 새로 만든다
      con = DriverManager.getConnection(jdbcUrl,username,password);
      
      // 현재 스레드가 다음에도 사용할수 있도록 connection 객체 준비
      conLocal.set(con);

      System.out.printf("[%s] Connection 객체를 생성\n", Thread.currentThread().getName());
    }
    System.out.printf("[%s]  Connection 객체를 리턴\n", Thread.currentThread().getName());
    // 현재 스레드에서 준비한 Connection 객체를 리턴
    return con;
  }
}


<h4>DB Connectionpool을 활용한 Connection 재사용 </h4>

- 풀링기법(pooling)
    1. 객체생성시 시간이 많이 소요되는경우
    2. 객체가 무거운경우(메모리 많이 사용하는경우)

이용하여 Connection 객체를 재사용하는법
- GoF 의 'Fly'


c1 -> ConnectionPool <-> list(con보관소)

c1이 con을 사용하고 반납하여 다른 c들이 재사용한다


<h2>PreparedStatement를 이용한 SQL 삽입 공격 막기</h2>


- 입력한 데이터를 sql문에 바로 적용하여 데이터를 보내는 방식의 문제점

  public class Exam0120 {
  
    public static void main(String[] args) throws Exception {
      String no = null;
      String title = null;
      String contents = null;
  
      try (Scanner keyboard = new Scanner(System.in)) {
        System.out.print("번호? ");
        no = keyboard.nextLine();
  
        System.out.print("제목? ");
        title = keyboard.nextLine();
  
        System.out.print("내용? ");
        contents = keyboard.nextLine();
      }
  
      try (Connection con = DriverManager.getConnection( //
          "jdbc:mariadb://localhost:3306/studydb?user=study&password=1111");
          Statement stmt = con.createStatement()) {
  
        // SQL 삽입 공격
        // => 입력 문자열에 SQL 명령을 삽입하여 프로그램의 의도와 다르게 데이터를 조작하는 행위.
        // => 사용자가 입력한 값을 가지고 SQL 문장을 만들 때 이런 문제가 발생한다.
        // => 예를 들어 이 예제를 실행할 때 다음과 같이 입력해 보라!
        // 번호? 1
        // 제목? okok
        // 내용? test', view_count = 300, created_date = '2019-3-3
        //
        int count = stmt.executeUpdate( 
            "update x_board set title = '" + title + 
            "', contents = '" + contents + 
            "' where board_id = " + no);
  
        // 위에서 사용자가 입력한 값을 가지고 SQL 문장을 만들면 다음과 같다.
        //
        // update x_board set title = 'okok',
        // contents = 'test', view_count = 300, created_date = '2019-3-3'
        // where board_id = 1
        //
  
        if (count == 0) {
          System.out.println("해당 번호의 게시물이 존재하지 않습니다.");
        } else {
          System.out.println("변경하였습니다.");
        }
      }
    }
  }
  

- sql문을 PreparedStatement 사용하여 sql삽입 공격을 막을수 있다


  public class Exam0210 {

    public static void main(String[] args) throws Exception {
      String title = null;
      String contents = null;
  
      try (Scanner keyboard = new Scanner(System.in)) {
        System.out.print("제목? ");
        title = keyboard.nextLine();
  
        System.out.print("내용? ");
        contents = keyboard.nextLine();
      }
  
      try (Connection con = DriverManager.getConnection(
          "jdbc:mariadb://localhost:3306/studydb?user=study&password=1111");
          PreparedStatement stmt = con.prepareStatement(
              "insert into x_board(title,contents) values(?,?)")) {
  
        // SQL 삽입 공격
        // => 입력 문자열에 SQL 명령을 삽입하여 프로그램의 의도와 다르게 데이터를 조작하는 행위.
        // => 사용자가 입력한 값을 가지고 SQL 문장을 만들 때 이런 문제가 발생한다.
        // => 예를 들어 이 예제를 실행할 때 다음과 같이 입력해 보라!
        // 제목? aaaa
        // 내용? bbbb'), ('haha', 'hoho'), ('hehe', 'puhul
        //
  
        // 위에서 준비한 SQL 문에 값을 설정한다.
        // => ? : 값이 놓일 자리를 의미한다. 'in-parameter' 라 부른다.
        // => in-parameter 에 들어갈 값의 타입에 따라 적절한 setXxx() 메서드를 호출한다.
        //
        stmt.setString(1, title);
        stmt.setString(2, contents);
  
        // => 이미 SQL 을 준비한 상태이기 때문에 실행할 때는 SQL를 줄 필요가 없다.
        // => setXxx()로 설정된 값은 단순한 텍스트로 처리한 후
        //    SQL을 실행할 때 파라미터로 전달되기 때문에 
        //    SQL 삽입 공격이 불가능 하다. 
        int count = stmt.executeUpdate();
  
        System.out.println(count + " 개를 입력하였습니다.");
      }
    }
  }


<h2>Mybatis SQL Mapper</h2>


이전 방식

java코드 
+
jdbc코드
+
sql


개선

sql코드 ->  분리
  - sql코드를 읽기 쉽고
  - 다루기 쉽다

jdbc  -> 캡슐화 -> Mybatis API
  - DB프로그램을 간결하게 쉽게 만든다

java코드 -> java코드 + Mybatis API사용


<strong>Mybatis 객체</strong>

SqlSessionFactoryBuilder -(build())> SqlSessionFactory 

-> 
insert()
findAll()
... 

Dao  



</pre>
<br>
<hr>
<br>
<h1>2023-02-15</h1>
<pre>


<h2>Mybatis 사용법</h2>


<h3>1. Session 객체</h3>

SqlSession.seletOne() -> select문 : 0 또는 1개 결과
  - 만약 2개 이상의 결과를 리턴하면 예외발생

SqlSesstion.selectList() -> select문 : 0개 이상의 결과

SqlSesstion.insert() 
SqlSesstion.update()
SqlSesstion.delete()

- insert/update/delete 메서드와 상관없이 실행가능
  하지만 일관성있게 사용해야 한다 
  => JDBC API 에서도 executeUpdate()로 모두 실행


<h3>2. 메서드와 SQLID</h3>

SQLMapper

<!--
<mapper namespace="BoardMapper"></mapper>

<insert id="insert" parameterType="bitcamp.myapp.vo.Board">
  insert into app_board(title, content, pwd)
  values(#{title}, #{content}, #{password})
  </insert>

자바코드

List<Board> list = sqlSesion.selectList("BoardMapper.findAll");


- namespace와 id값으로 찾는다
-->

<h3>3. 컬럼과 프로퍼티</h3>

<!--
<select id="findAll" resultType= "bitcamp.myapp.vo.Board"> 
  
  select
    board_id as no,   // 별명을 부여하여 프로퍼티를 호출한다
    title,
    created_date as createdDate,
    view_cnt as viewCount
  from
    app_board
    order by
      board_id desc
  
</select>  
-->

- 위에서 호출하는 세터 메서드는 존재하지 않기때문에
  해당 컬럼의 값을 자바 객체에 담을수 없다


<h3>4. 결과 레코드와 자바 객체</h3>


table의 레코드를 Board 인스턴스에 담아서 List에 보관한다
그리고 selectList로 해당 인스턴스를 접근해 사용


<h3>5. in-parametor 와 메서드 파라미터</h3>


자바코드

public void insert(Board b) {

  try (SqlSession sqlSession = sqlSessionFactory.openSession()) {

SqlSession.insert("BoardMapper.insert", b(Board 인스턴스));
sqlSession.commit();
  }
}

SQLMapper

<!-- 
<insert id="insert" parameterType="bitcamp.myapp.vo.Board">
  insert into app_board(title, content, pwd)
  values(#{title}, #{content}, #{password}) // get___의 리턴값

  *주의*
   - in-parametor는 타입에 상관없이 프로퍼티명 으로 값을 삽입 
</insert>
 -->


 <h3>5. in-parametor 와 자바원시타입 String</h3>


SqlSession.selectOne("BoardMapper.findByNo", 20);


<h2>DAO와 Transaction</h2>

                    insert
                    commit 
Handler -> MemberDao <-> DBMS
        -> StudentDao


- insert가 개별적으로 실행된다면 insert후에 commit하는게 맞다

- 다른 작업과 묶일수 있는 경우라면 개별적으로 commit/rollback 하면 안된다
 위처럼 여러 Dao작업을 하나의 트랜젝션으로 묶어서 사용하는 경우가 있기 때문이다
 
 => commit/rollback은 Dao를 사용하는 쪽에서 제어해야 한다


 <h2>Mybatis를 사용하는 DAO의 트랜잭션 제어</h2>


이전방식 


ConnectionFactory 를 활용하여 DAO에 connection을 사용하는 방식

setAutoCommit(false)
 commit()
 rollback()

- 모든 작업이 하나의 connection에서 이루어졌다


변경방식

MemberDao -> SqlSession

StudentDao -> SqlSession

1. 트랜잭션 시작
2. MemberDao
3. StudentDao
4. commit/rollback


  <h3>SqlSession 의 트랜잭션 제어</h3>

  Handler -> TransactionManager -> SqlSession Factory -> Thread


  <h4>SqlSessionFactory 클래스의 기능 변경 (추가,변경,삭제)</h4>

    SqlSessionFactory(interface)


    BitcampSqlSessionFactory(concrete)

    -> proxy 패턴 활용으로 sqlSessionFactory를 감싸서 사용한다

    - SqlSessionFactory를 사용했을때 문제점
      - MemberDao 와 StudentDao처럼 각각 다른 SqlSession 을 사용하는경우 
        MemberDao가 작업을 처리한후 Session을 close한다 StudentDao의
        작업은 적용하지 못한다

        *해결방법*
        proxy를 활용한다 interface를 구현하고 oiriginal 구현체에게 위임
      
        =>
        
        기존 코드는 변경하지 않고 원하는 기능을 구현체에서 수정 
        하여 사용 2가지를 변경


        1) commit을 false로 변경하고 사용한 Session을 null로 비워주고 
           여러개의 Dao가 사용하는 경우 Session에 여러 Dao가 입력한 데
           이터를 넣고 commit 을 하게 한다 

           하지만 null이라면 하나의 Session만 사용한것이기때문에 original 리턴
           아니라면 false 여러 Dao가 사용할 객체 리턴

         public class BitcampSqlSessionFactory implements SqlSessionFactory {

          SqlSessionFactory original;
        
          ThreadLocal<SqlSession> sqlSessionLocal = new ThreadLocal<>();
        
          public void prepareSqlSessionForThread() {
            SqlSession sqlSession = sqlSessionLocal.get();
            if (sqlSession == null) {
              sqlSessionLocal.set(new BitcampSqlSession(original.openSession(false)));
            }
          }
        
          public void clearSqlSessionForThread() {
            BitcampSqlSession sqlSession = (BitcampSqlSession) sqlSessionLocal.get();
            sqlSession.closeOriginal();
            sqlSessionLocal.set(null);
          }
        
          public BitcampSqlSessionFactory(SqlSessionFactory original) {
            this.original = original;
          }
        
          @Override
          public SqlSession openSession() {
            SqlSession sqlSession = sqlSessionLocal.get();
            if (sqlSession == null) {
              // 트랜잭션 없이 사용할 SqlSession 리턴
              return original.openSession(true);
            }
        
            // 스레드에서 공유할 SqlSession 객체 리턴
            return sqlSession;
          }


        2) try문에서 자동으로 original.close()를 사용하기 때문에
            처음 데이터를 입력한 Dao만 적용되고 뒤에 Dao는 입력
            불가 그래서 closeOriginal로 원하는 상황에 닫게 설정
        
        public class BitcampSqlSession implements SqlSession {

          SqlSession original;
        
          public void closeOriginal() {
            original.close();
          }

          @Override
          public void close() {
            //original.close();
          }
        


</pre>
<br>
<hr>
<br>
<h1>2023-02-16</h1>
<pre>


<h3>DAO 구현체</h3>


 BoardDao -> DAO구현체 -> InvocationHandler 구현체
invoke 메서드로 Dao 구현체에 들어갈 메서드를 만들어 준다


public class DaoGenerator implements InvocationHandler {

  SqlSessionFactory sqlSessionFactory;

  public DaoGenerator(SqlSessionFactory sqlSessionFactory) {
    this.sqlSessionFactory = sqlSessionFactory;
  }

  @SuppressWarnings("unchecked")
  public <T> T getObject(Class<T> classInfo) {
    String className = classInfo.getName();

    return (T) Proxy.newProxyInstance(
        getClass().getClassLoader(), // 현재 클래스의 로딩을 담당한 관리자: 즉 클래스 로딩 관리자
        new Class[] {classInfo}, // 클래스가 구현해야 할 인터페이스 정보 목록
        this // InvocationHandler 객체
        );
  }

  // 자동 생성된 프록시 객체에 대해 메서드를 호출하면
  // 실제 InvocationHandler의 invoke()가 호출된다.
  @Override
  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

    SqlSession sqlSession = sqlSessionFactory.openSession();

    String daoName = proxy.getClass().getInterfaces()[0].getSimpleName();
    String methodName = method.getName();
    String sqlStatementName = String.format("%s.%s", daoName, methodName);
    System.out.printf("%s.%s() 호출!\n", daoName, methodName);
    Class<?> returnType = method.getReturnType();

    if (returnType == int.class || returnType == void.class) {
      return args == null ? sqlSession.insert(sqlStatementName) :
        sqlSession.insert(sqlStatementName, args[0]);
    } else if (returnType == List.class) {
      return args == null ? sqlSession.selectList(sqlStatementName) :
        sqlSession.selectList(sqlStatementName, args[0]);
    } else {
      return args == null ? sqlSession.selectOne(sqlStatementName) :
        sqlSession.selectOne(sqlStatementName, args[0]);
    }
  }


<h3>Application Server에 웹기술 적용</h3>


Local
  -client-app
  -> 변경
  web Browser

  client-app 을 만들필요없다

<-> 응답,요청

Application Server
  - server-app
  ->변경
  - web server
  - Application server
      call -> Serverapp(직접만든)

  server-app 을 개발 X
    - 통신 프로그래밍 X
    - 멀티스레딩 X
    - 프로토콜 X

<-> 응답,요청

DBMS


<h3>Web Application Architecture</h3>


web browser 

->

web server

->

Application server 

->

app

->

DBMS

  <h4>Web Application Architecture : Servlet/JSP</h4>

  web browser 

  ->
  Tomcat Server

    web server
    
    ->
    
    Servlet Container 
      - 서플릿 객체생성 -> 실행 -> 소멸관리
      - DB커넥션 등 공유자원 관리

    * 서블릿 (Servlet = server Application + let(작은것을 의미))
       - 서버 어플리케이션의 작은 기능
  ->
  
  Servlet JSP
    - 작은기능을 수행하는 서버 app조각
  
  ->
  
  DBMS

인사관리 시스템에 있는 정보입력,변경,삭제등 어플에 작은기능


  <h4>Tomcat 서버 설치</h4>

  ~/server/tomcat서버디렉토리/
            bin/ : 톰켓 서버를 구동시키는 쉘스크립트와 실행파일이 들어있다
            conf/ : 톰캣 서버 설정파일들
            lib/ : .jar 자바라이브러리파일 톰켓 서버를 자바로 만든 프로그램
                    (톰켓서버를 실행하는데 필요한 라이브러리)
            logs/ : 톰켓 서버가 실행하는 동안 시스템 상태를 출력한 로그파일들
            temp/ : 톰켓 서버가 실행할때 사용하는 임시작업폴더
            webapp/ : 톰켓 서버가 실행시킬 web app들
            work/ : 톰켓 서버가 생성한 변환 파일들

  
  <h4>서블릿/JSP 기술 규격</h4>

  TomcatServer 구현체 (Servlet container)
    - 서블릿 기술규격에 맞게 개발해야한다
    그래야 규격에 맞게 작성한 app을 실행가능

  -> call

  서블릿
    - 기술 규격에 맞게 작성해야 서버에서 
    실행가능
  

<4h> Servlet App 만들기</4h>

1. 프로잭트를 Servlet/JSP 웹 프로젝트로 전환
  1) Servlet API 라이브러리 추가 -> build.gradle
  2) 웹 프로잭트 표준 디렉토리 구조로 전환
    local/main/java
        / resources
        / webapp
            /*.html
            /*기타 자원
            /WEB-LUF
    - 관련 디렉토리 생성
    - gradle plugin추가 : war , eclipse-wtp 설정
    - eclipse 웹프로잭트 속성 설정
    - 'gradle clean eclipse' 실행
      'gradle eclipse'
    - 빌드및 배포 테스트 
      'gradle build' 실행 -> buile -> libs -> web.war
      -> 복사 -> %톰켓서버/webapps/web.war 이후 톰캣서버 재실행


 2. 서블릿 앱 만들기
  
servlet Container()
  
 ->

HelloServlet(콘크리트)  ----------- Servlet(인터페이스)
  init(){}
    - servlet 객체 생성후 즉시 : 작업에 필요한 준비
  service(){}
    - 클라이언트 요청마다 : 클라이언트 요청 작업 수행
  destroy(){}
    - 웹앱 종료할때 : 사용한 자원 해제
  getServletInfo(){}
    - 서블릿의 간단한 설명 : 관리 기능을 위해
  getServletConfig(){}  
    - 서블릿 설정 정보: 작업중에 필요하면 사용

    서블릿 lifecycle 메서드

<h3>Eclipse 와 Tomcat 서버연동하기 </h3>

1. Eclipse IDE preferences 에 temcat 서버경로 설정
  -> Eclipse IDE에서 tomcat서버를 실행할 수 있도록 서버가 설치된 경로를 알려준다

2. 개발 및 테스트용 배치 환경구축
  - 톰켓서버가 설치된 폴더에 개발중인 webapp 을 직접 배치하기 않기 위해
  - 테스트용 배치 완경및 폴더를 따로 준비한다

  C:\Users\bitcamp\eclipse-workspace\.metadata\.plugins\org.eclipse.wst.server.core

  에서 배치환경 구축

  


<h2>github 활용법</h2>

repo. 에 올린 프로잭트가 어떻게 작동하는지 설명과 
unittest 코드를 작성한다 







</pre>
<br>
<hr>
<br>
<h1>2023-02-17</h1>
<pre>


<h3>Applicatino Server Architecture</h3>


Client App -> Server App -> DBMS

- 네트워킹,멀티쓰레딩,프로토콜을 짜야한다 이때 회사마다 규칙이 다르기때문에
  통일성이 없다 

  해결
  => 

WebBrowser -> Webserver -> APP -> DBMS

- 이미 네트워킹,쓰레딩,프로토콜이 표준기술 이기때문에 짤필요가 없고 어느 회사
  에서든 사용법이 같다 HTML,CSS,JAVAScript  사용이 가능하다 

- ui 기술이 다르다면 App 개발할때 라이브러리가 다르기때문에 
  java로 개발한 app은 python에서 사용이 안된다  
  
  하지만 web기술을 사용하면 ui가 통일되어 app server를 사용할 때
  문제가 없다  


  APP

    Application관리자 <-> App
      
      - App 생성->실행->소멸
      - 공유자원관리
      - web server와의 연동담당
        - App 개발자가 web server로부터 데이터를 받고
          웹서버에 결과 데이터를 보내는 것을 대신처리


<h3>서버 이중화 </h3>

Client <-> Tomcat Server <-> HelloServlet 


c1 -> Tomcat Server <-> HelloServlet
c2 ->

c3 -> Tomcat Server// 문제발생 <-> HelloServlet 
c4 ->

      Tomcat Server -> HelloServlet

- 문제가 발생했을때 사용하던 servlet은 serialize 인터페이스를 구현한 
  객체를 상속 받아서 사용해야 한다 그래야 이전시 serialize 하여 인스
  턴스를 그대로 유지 한상태로 이전시킨다 


<h3>web Project 개발과 테스팅 흐름</h3>

1)
(프로젝트 폴더)
web project
  index.html
    - 편집 및 저장

2)
(톰캣테스트 환경의 배치 폴더)
temp0/wtpwebapps/myapp-server
  - 자동 저장

3)
WebBrowser 갱신


<h3>서블릿 출력과 한글 문자코드 인코딩</h3>

out.println("AB가각")

기본 문자집합 ISO-8859-1을 사용해 인코딩

JVM 기본문자집합(UTF-16) -> 0041('A') 0042('B') 


<h3>URL 정보 알아내기 getServletPath(),getPathInfo()</h3>


http://localhost:8080/web/board/list?name='홍길동'


String contextPath = request.getContextPath(); // web
String servletPath = request.getServletPath(); // board
String pathInfo = request.getPathInfo(); // list
String queryString = request.getQueryString(); // name='홍길동'

System.out.printf("%s -- %s-- %s-- %s\n", contextPath,servletPath, pathInfo,queryString);

출력결과 :
/web -- /board-- /list/a/ok/no-- ed


<h4>요청파라미터와 한글 인코딩</h4>

AB가각

get요청(UTF-8) -> 전송 -> getParameter("neme") -> UTF-16 

post요청(UTF-8) -> 전송 (IOS-8895-1)-> getParameter("name") -> UTF-16


post요청으로 전송 받은 문자열이 UTF-8로 인코딩 되었다고 알려줘야한다
-> request.setCharacterEncoding("UTF-8");


<h4>Command design pattern</h4>

 하나 명령 -> 하나 메서드 

실행될 기능을 캡슐화함으로써 기능의 실행을 요구하는 호출자(Invoker)
클래스와 실제 기능을 실행하는 수신자(Receiver) 클래스 사이의 의존성을 제거한다

따라서 실행될 기능의 변경에도 호출자 클래스를 수정 없이 그대로 사용 할 수 있도록 해준다


</pre>
<br>
<hr>
<br>
<h1>2023-02-20</h1>
<pre>
 

<h3>myapp 수정</h3>


from 

- radio 
- checkbox
- selectbox 

선택 사항이라면 선택안함 항목을 추가해줘야한다 
하지만 필수항목이라면 checked,selected와 같이
기본 선택하게 표시   


Mapper

- dynamicsql
- staticsql


<h3>리스너 및 servletcontext 보관소 사용법</h3>


servletcontext
  - webapp시작 후 종료시까지 유지
  서블릿들이 공유할 자원을 보관
  예) DAO,DB커넥션등

HttpSession
  - 로그인 후 로그아웃 까지
  로그인 동안 사용할 정보 저장
  예) 로그인 사용자 정보

ServletRequest
  - 요청 후 응답까지
  요청처리중 생성된 중간결과 보관  
  s1,s2,s3
  예) select결과등

JSPcontext
  - JSP 실행하는 동안 유지
  각 JSP를 실행할 때마다 생성 실행완료 후 종료
  

<h4>리스너</h4>


  ServletContextlistener(구현체)

  - 웹 어플리케이션이 시작되거나 종료될 때 호출할 메서드를 정의한 인터페이스.

  - contextInitialized(ServletContextEvent sce) : 웹어플리케이션을 초기화할 때 호출
  
  - contextDestroyed(ServletContextEvent sce) : 웹 어플리케이션을 종료할 때 호출.


  ServletRequestListener(구현체)

  - requestInitialized : ServletRequest 객체가 생성될 때 호출됨 (요청들어왓을때)

  - requestDestroyed : ServletRequest 객체가 소멸될 때 호출됨 (요청을 완료할때)


  HttpSessionListener(구현체)

  - sessionCreated() : 세션 생성할 때 (로그인할때)

  - sessionDestroyed(): 세션 종료할 때 (로그아웃할때)


<h3>자원공유 전/후</h3>

공유 전
  - 서블릿 마다 DAO 객체를 생성한후 보유한다 => 메모리 낭비

공유 후 (Flyweight 패턴)
  - 서블릿 들이 공유하는 Dao를 만든다


<h3>필터 구동과 사용법</h3>

- 서블릿 실행 전/후 로 작업을 추가할 수 있다
- GOF의 chain of Responsibility 패턴

    - 객체 지향 프로그래밍에서 책임의 분리와 위임을 적용할 수 있는 유용한 방법 중 하나입니다
      객체들 간의 결합도를 낮추면서 유연성을 확보하고 객체의 책임을 분리하여 객체의 재사용성을
      높이는 데에도 도움을 줌
    
      =>
      기능(작업)을 추가/ 제거하기 쉽다(기존코드수정x)

  <h4>필터 실행 과정</h4>

   요청 -> Servlet Container -> doFilter() -> Filter1-> doFilter() -> Filter2 -> servlet() -> 서블릿 

   - 호출된 순서로 리턴된다

  doFilter(){
    // 다음필터 실행전 수행할 작업
    nextChain.doFilter(); // 다음필터 실행
    // 다음필터 실행한후 수행할 작업
  }

  @WebFilter("/student/*")
public class Filter3 implements Filter {

  // 웹앱 시작시 필터 생성
  @Override
  public void init(FilterConfig filterConfig) throws ServletException { 
    System.out.println("Filter3.init() 호출");
  }

  // 요청이 들어왔을 때 생성
  @Override
  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) 
      throws IOException, ServletException { 
    System.out.println("Filter3.doFilter() - 작업시작");

    chain.doFilter(request, response); // 다음 필터없으면 서블릿 실행

    System.out.println("Filter3.doFilter() - 작업끝");
  }

  // 웹앱 종료시 필터 제거
  @Override
  public void destroy() {       
    System.out.println("Filter3.destroy() 호출");
  }
}

  - 필터 등록하는 방법 deployment(배치)방법
  
  실행예)

  1.

  요청 <-> Servlet Container <-> Filter1 <-> filter2 <-> BoardListServlet

  - 요청순서대로 리턴

<h3>java 와 JSP</h3>


class BoardListServlet -> JSP 작성에 필요한 태그 필요한  

<% (@) : directive element = 태그 사이에 JSP 페이지의 속성을 정의

<% (!) : declaration elemen = 필드와 메서드 정의

<% : scriptlet : 자바코드 정의
() : = 자바코드
%>

<% (=) : expression element = 변수나 함수 호출 결과 등을 출력하는 데 사용
                              자동으로 문자열로 변환되어 출력



</pre>
<br>
<hr>
<br>
<h1>2023-02-21</h1>
<pre>


<h4>web Application Architecture</h4>


Servlet container <-> Servlet <-> JDBC API <-> DBMS

Servlet 
- 자바코드중심

=>

JSP
- 출력중심 -> UI생성이 쉽다 -> "view" 역할
- 업무에 따라 Dao 작업흐름제어 -> 트랜잭션제어
-> 출력제어 "Controller"역할

  MVC(model-view-controller)모델

    <ol>I.MVC모델</ol>
      ServletContainer -> JSP 

    <ol>II.MVC모델</ol>
      ServletContainer -> Servlet -> Dao -> DBMS
      
      - Servlet : controller 
        업무로직수행 -> 실행흐름제어 -> UI출력제어

      - Dao : Model
        데이터 처리

      - JSP : View
        UI생성
    
    예)

    Servlet -> BoardListServlet -> BoardDao -> DBMS

    <ul>BoardListServlet(Controller)</ul>
    - forward
    - list.jsp

    <ul>BoardDao</ul>


<h3>JSP 구동원리</h3>


ServletContainer -> JSP파일이 변경되었나? -> list.jsp -> list.java -> list.class


<h3>JSTL 과 EL</h3>

  <ol>JavaServer Pages Standard Tag Library (JSTL)</ol>
    
    - JSP 페이지에서 자주 사용되는 로직과 기능을 태그 형태로 제공하는 라이브러리

    1. Core 태그 라이브러리: 조건문(if), 반복문(forEach), 변수 설정(set) 등의 기능을 제공합니다
    2. Formatting 태그 라이브러리: 날짜, 시간, 숫자 등을 서식에 맞게 표시하는 기능을 제공합니다.
    3. SQL 태그 라이브러리: SQL 문을 실행하고, 결과를 가져오는 기능을 제공합니다.
    4. XML 태그 라이브러리: XML 문서를 파싱하고, 조작하는 기능을 제공합니다.


  <ol>EL (Expression Language)</ol>

    - JSP와 Servlet에서 사용할 수 있는 표현 언어입니다. EL을 사용하면 JSP 페이지에서
     Java 코드를 작성하지 않고도 변수, 프로퍼티, 메서드 등에 접근할 수 있습니다

    1. 문법이 간결하고 직관적입니다. EL을 사용하면 변수나 메서드에 접근할 때, ${} 기호를 사용하여 표현할 수 있습니다
    2. EL은 null값 처리에 용이합니다. EL은 null값 처리를 위해 ?. 연산자를 제공하며, 해당 변수나 프로퍼티가 null값인 경우, null을 반환합니다
    3. 컬렉션과 맵 등에 쉽게 접근할 수 있습니다. EL은 컬렉션과 맵 등의 요소에 접근할 때, [] 연산자를 사용하여 간편하게 접근할 수 있습니다
    4. 스코프에서 속성을 검색할 수 있습니다. EL은 JSP에서 사용되는 스코프(예: request, session, application)에서 속성을 검색할 수 있습니다
    5. EL은 연산자를 지원합니다. EL은 산술, 비교, 논리 연산자 등을 지원하여, 변수나 상수의 계산이 가능합니다



<h3>Server-rendering vs client-rendering</h3>


1. ServerRendering : 서버에서 UI 생성


장점

- 웹 페이지 초기 로딩 지연시간을 줄일 수 있습니다.

SSR 방식은 Server 에서 화면 구성에 필요한 데이터를 가지고 렌더링을 진행한 뒤 결과물인
 html 을 Client 로 서빙 합니다. Client 에서는 초기 웹 페이지 구성에 필요한 데이터를 
 요청하지 않아도 됩니다

- SEO(Search Engine Optimization) 가 많은 양의 웹 콘텐츠 정보를 수집하게 되므로
 검색사이트 상위 노출에 유리합니다

검색엔진 봇이 웹 사이트 정보를 수집하고자 Server 에 요청하면 Server 는 콘텐츠
 정보를 포함한 html 을 제공하므로 검색엔진 봇은 많은 정보를 수집할 수 있게 됩
 니다

 단점

 - Server 에서 데이터를 이용해 동적으로 html 을 생성하기에 Server 부담이 발생합니다


2. ClientRendering : UI 생성


장점

- Server 부담을 줄일 수 있습니다

CSR 방식을 이용하면 Server 는 Client 에서 요청한 데이터만 제공하면 됩니다
 템플릿 엔진을 이용한 웹 페이지 렌더링을 하지 않으므로 SSR 방식보다 적은 
 부담이 발생합니다


단점

- 웹 페이지 초기 로딩 지연시간이 발생합니다.

CSR 방식은 Server 로 부터 html 파일을 서빙 받은 뒤, AJAX 를 통해 화면 구성에
 필요한 데이터를 Server 에 요청하게 됩니다. 이로 인해 웹 페이지 초기 로딩 지
 연시간이 발생합니다

- SEO(Search Engine Optimization) 가 웹 콘텐츠 정보를 수집하지 못해 검색사이
트 상위 노출에 불리하게 됩니다

CSR 방식의 경우, 초기 html 에는 별다른 정보가 없습니다.

그러므로 검색엔진 봇이 수집하는 콘텐츠 정보가 적어, SSR 방식으로 개발된 웹
 사이트에 비해 상대적으로 검색 노출에 불리하게 됩니다. 


</pre>
<br>
<hr>
<br>
<h1>2023-02-22</h1>
<pre>


<h3>세션으로 클라이언트 구분하기</h3>


Connection - Oriented
연결후 데이터 전송

  - Stateful
   client가 접속을 종료할 때 까지 유지

   - Stateless
   하나의 요청이 끝날때까지 유지

Connectionless
일단 데이터 전송 


WebBrowser <-> Servlet Container

- 쿠키 = 세션ID

  웹서버가 웹브라우저에게 보내는 정보 
  브라우저에서 정보 보관 웹서버 방문시
  제출

- Session 객체

  세션ID로 접근한 클라이언트를 확인함

  <h4>세션 생성및 사용 과정</h4>
    - 세션ID는 cookie

  1. client -> Server ->  Session

    1) 클라이언트가 요청을하면 서버가 세션을 생성

    2) 세션ID(쿠키)를 클라이언트에게 부여 
      =  응답프로토콜
       Set-Cookie: age=20
       Set-Cookie: working=true
       Set-Cookie: name2=홍길동 

    3) 클라이언트 쿠키보관

    4) 다시 요청시 쿠키를 통해 이전 정보를 server로 넘겨줌 
      =  요청프로토콜
      Cookie: name=hong; age=20; working=true; name2=홍길동


  <h4>세션과 쿠키를 이용한 로그인처리</h4>

WebBrowser -> ServletContainer -> LoginServlet -> StudentDao -> DBMS

Browser가 로그인 요청을 하면 세션ID를 받아 쿠키테이블에 보관한다
그리고 나중에 재 방문시 세션ID를 통해 저장된 정보를 확인하고 접
근한다 이때 ** ID가 없다면 server에서 새로 만들어서 쿠키로 보내
준다 이 쿠키는 브라우저가 종료되면 지워진다

<h4>web.xml</h4>


$contextroot/ *html,css,js,gif 등 정적자원
/ jsp <- 동적자원
/WEB-INF
  classes/ .calss,.properties,.xml 등
  lib/.jar
  web.xml <- web app 설정정보를 담은 파일 자원배치 정보
                     서블릿/JSP,필터,리스너,파라미터등   <= Deployment Descriptor 파일 (DD파일)


<h4>Refresh vs Redirect</h4>

Refresh
- 컨텐트 포함 응답후 출력

Redirect
- 콘텐트 포함하지 않음


<h4>필터를 이용한 로그인 여부검사</h4>

ServletContainer -> AuthFilter -> ... -> Servlet



 <h4>DB데이터를 중첩객체에 저장하는 방법</h4>

 이전 방식 

 번호 제목 작성자번호   이름
  1    a      10       가나다    -> :Board

 - 부모테이블과 관계가 없었다


 Board {       <>-->     Member {
  번호                      번호
  제목                      이름
  작성자번호              }
  이름
 }                  


=> SQL에서 설정 result map



  <h4>테이블 관계와 객체 관계의 비교</h4>

  테이블 관계

    app_member -ㅣ-- ok- app_board
  
 
  객체 관계

   Board <>--> Member
   Member <>--> Board

   필요에 따라 관계를 정의 
   테이블 관계의 영향을 받지 않음




</pre>
<br>
<hr>
<br>
<h1>2023-02-23</h1>
<pre>


<h3>파일업로드처리 </h3>


app_member -ㅣ-- ok- app_board -ㅣ-- ok- app_board-file

member_id(pk)    board_id(pk)             boardfile_id(pk)
                 writer(fk)               attachedFiles(fk)


  <h4>파일업로드처리 - Servlet과 Dao</h4>

  BoardInsertServlet -> BoardDao -> app_board


  form.jsp 

    input type="file" name='files' multiple
    
    - multiple을 붙여야 파일 여러개 지정가능 

  
  BoardInsertServlet.java

    String[] files = request.getParameterValues("files");
    for (String file : files) {
      System.out.println(file);
    }

    - 파일이 여러개 넘겨오게 할려면 값을 배열로 받고 줘야한다

    
    
  <h4>파일업로드처리 - 멀티파트 데이터 처리</h4>


  Apache.org의 fileupload 라이브러리
  - 멀티파트 형식의 요청데이터를 객체에 담아준다

  파라미터 정보 -> 객체  

  - 버퍼를 사용하여 객체를 저장한후 마지막에 요청을 처리한다

  

























</pre>
</section>
</main>
</div>
<footer id="footer">

<li><small><a href="https://github.com/96abab/test.io.git">96abab.GitHub.com - test.io</a></small></li>
</footer>
</body>
</html>
