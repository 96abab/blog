<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>96abab</title>
    <link rel="stylesheet" href="stylesheet.css">
    <link rel="icon" href="https://96abab.github.io/test.io/ducklogo.png">
    
</head>
<body>
<div id="container">
<header>
  <h2>JAVA</h2>
  <nav>
    <ul id="topMenu">
      <li><a href="https://96abab.github.io/test.io">home</a></li>
      <li><a href="#">menu1</a></li>
      <li><a href="#">menu2</a></li>
    </ul>
  </nav>
</header>
</div>
<aside>
<ul id="sidebar">
  <li><a href="index.html">Home</a></li>
  <br>
  <li><a href="assignment.html">과제</a></li>
  <br>
  <li><a href="tictactoe.html">TICTACTOE</a></li>
  <br>
  <li><a href="cloudOS.html">1.CloudOS(리눅스서버설치)</a></li>
  <br>
  <li><a href="linux.html">2.리눅스 명령어 정리</a></li>
  <br>
  <li><a href="HTML5.html">3.HTML수업</a></li>
  <br>
  <li><a href="CSS.html">4.CSS수업</a></li>
  <br>
  <li><a href="JAVAscript.html">5.JAVAscript</a></li>
  <br>
  <li><a href="JAVA.html">6.JAVA</a></li>

</ul>
</aside>
<main class="contents">
<section id="headling">
<h1>2022-12-26</h1>
<br>
<br>
<pre>
<strong>web Application Architecture</strong>


client (web browser)
HTML
CSS
JAVAscript
+
jquery
bootstrap
+
react

-서버에 있는 자원을 받아 실행


web server 

HTML,CSS,javascript등 읽는다
-정적자원 :실행하지 않고 그대로 읽어 리턴해 주는것(static resource)


<strong>springboot 기술스택</strong>


java로 만들어졋다 (JVM - interpreter,player,runtime Engine) -> tomcat server -> jakartaEE API(javaEEApi) -> spring Framework -> java APP , mybatis , JSP , thymeleaf

JDK

<strong>java설치 준비</strong>

1. java.oracle에서  x64 MSI Installer 다운
2. 환경변수 설정
JAVA_HOME -> JDK 설치 폴더
PATH -> JDK/bin 폴더경로 추가


setx JAVA_HOME JDK설치폴더 /m
setx PATH "JDK/bin;%PATH%"

/usr/libexec/java_home -V


gradle.org



*JAVA_HOME
1. JDK가 설치된 폴더 경로
2. java App 이 JDK를 찾을떄 이 환경변수를 이용한다


*PATH
-> 실행프로그램이 있는 폴더 경로
-> CLI에서 프로그램 이름으로 
바로 실행하고 싶을 때  

빌드 도구 설치 및 설정
1. 프로잭트폴더를 준비
2. JDK 를 이용하여 컴파일 신청, 테스트 수행
3. 아카이브 (archive) 파일을 생성 
배포파일 (.jar,)


*인터프리터 방식 

node hello.js


*컴파일 방식

gcc -o hello.exe hello.c

실행 hello.exe or hello


*하이브리드 방식 


컴파일 방식보다 나은 이유

1. 동일한 바이트코드를 생성하여 OS마다 컴파일 할 필요가 없다

2. OS용 JVM이 설치되어 있다면 실행할 수 있다

3. 컴파일 과정에서 문법의 오류를 모두 찾아낸다 
(실행마다 문법검사를 하는 순수 인터프리터방식 보다 실행속도가 빠르다)

4. 완전 기계어는 아니지만 기계어에 가까운 언어로 
   변환된 명령을 실행하기 때문에 소스에 작성된 
   명령을 실행하는 것보다 빠르다



Hello.java

-컴파일

문법검사 수행 -> 문법오류를 모두 찾아냄
최적화 -> 실행 성능 향상


<strong>LLVM 컴파일</strong>
low level virtural Machine

1. LLVM 이전

 
hello.c -> C compiler -> 기계어 -> windows or macOS or Linux

컴파일러를 만드는 입장에서 c 언어를 해석하는 부분은 동일하다
=> 중복개발 


서로 다른언어 일때 컴파일러가 windows 에 맞는 기계어로 바꾸는
부분은 동일
=> 중복개발


*기존방식의 문제점

compiler제작자는 변환시킬 언어들과 변환후 적용할 기계어 또한
알아야한다는 부담


2. LLVM 이후 
LLVM 방식을 사용하는 이유
새 프로그래밍 언어와 컴파일러를 만들기 쉽다
다양한 언어를 쉽게 중간어로 바꾸고 다시 기계어로 변환시킬 수 있다


1단계 컴파일

-각 언어들을 중간어로 바꾸면 된다 컴파일러 제작자는 
한개의 가상기계어만 다루면 된다 


2단계 컴파일

-중간어를 기계어로 바꾸기만 하면 된다 


<strong>JAVA 와 LLVM</strong>


java -> .java
kotlin -> .kt
scala -> .scala  
groovy -> groovy.
자바 호환 언어

=> .class (bytcode)

=> 기계어



<strong>JDK,JRE,JVM</strong>

.class -> JVM -> 실행


JRE (java Runtime Environment)
javalibrary


JDK (java development kit)
개발도구(컴파일러,디버거등)


<strong>java EE, java SE, java ME</strong>


java EE (Enterprise Edition) -> 기업용 Applucation 제작에 필요한 도구

java SE (Standard Edition) -> java.app 제작 필수 도구
-JDK, JRE, server 용 JRE

java ME (Micri Edition) -> 임베디드 app 제작에 필요한 도구


<strong>Eclipse IDE</strong>


개발 플랫폼 + plug-in => 개발도구확장



<strong>java project 폴더 준비</strong>


1. 프로젝트 폴더 생성

c:/users/bitcamp/git/bitcamp-ncp/boot-project


2. 'boot-project/' 폴더를 java프로젝트 폴더로 초기화 

$gradle init

패키지는 보통 회사.프로잭트명 으로한다

kr.co.bitcamp.bootapp


3. 기본 예제 프로그램 실행

gradle -q run  (설명 빼고 결과만 실행)


프로젝트 폴더 boot-app


app 하위 프로젝트. 메인프로젝트
src/main/java   -> java소스파일을 두는 폴더
src/main/resources -> 기타 파일을 두는 폴더
src/test/java -> 단위테스트를 수행하는 자바소스파일
src/test/resources -> 단위테스트 관련 기타 파일

app
build.gradle -> build script파일 (빌드설정정보)
build -> 빌드로 생성한 파일 및 디렉토리를 두는 폴더 


boot-app
setting.gradle -> 프로그램 설정정보
gradlew,gradlew.bat -> gradle 도구 설치 명령 파일 
                      (gradle 도구가 설치되지 않았을때 사용)
gradle/ -> gradlew,gradlew.bat 가 사용하는 파일이 들어있다
.gradle/ -> gradle 도구들  


<strong>springboot 프로젝트 만들기</strong>


spring.io방문 -> project -> springboot 메뉴 -> spring initializr 클릭 
add dependencies

1. spring boot dev tool     -> 자동 로딩
2. spring configuration processor  -> project
3. spring web


<strong>JAVA에서 Spring Boot 까지</strong>


Spring Boot -> Tomcat server (networking API, thrend prog.) 
+ spring framework(spring webVMC,spring IOC)+ mybatis+(JSBC API) + SQL)


-> servlet/JSP, JSBC API

-> java I/O API, collection API

-> java 기본 문법 (built-in class)

-객체지향문법
-메서드/클레스
-연산자/제어문/반복문
-변수/리터럴

</pre>
<br>
<hr>
<br>
<h1>2022-12-27</h1>
<br>
<br>
<pre>
<strong>Maven 빌드 도구의 표준 프로젝트 디렉토리 구조</strong>

~/git/bitcamp-ncp/      //git repo.
~/git/bitcamp-ncp/boot-app/ // project 폴더


settings.gradle       // gradle 빌드 보조그크립트 파일
gradle/       // gradle 프로그램을 local에 설치해주는 도우미 프로그램
gradlew.bat     // gradle/ 폴더에 들어있는 설치프로그램을 실행하여 gradle을 설치하고
                // 설치한 gradle을 사용해 gradle 명령어를 실행하는 shell 프로그램
gradlew     // unix/linux/winOS 용
.gradle/ gradle 도구가 작업하는 동안 사용하는 임시 폴더


/app/     // sub project 
/app/src/     //소스폴더
/app/build.gradle/      gradle 빌드 스크립트 파일


/////////

<strong>App.java 에서 @명령어 로 import 가 자동 완성 안됬을 때</strong>


1. boot-app (프로젝트 파일에 .gradle 이 repo. 등 다른 곳에 있는지
확인 하여야한다)

2. .gradle이 잘못된 경로에 있을 경우 지웟다가 gradle -q run 을 
정확한 경로에 지정해줘야 한다

3. 이게 경우가 아닐시에는 해당 기능을 하는 서포트 프로그램이 작동하는지 확인
(java일 경우 language support of java(TM) by Red Hat  있는지 확인)



<strong>Gradle 빌드 도구</strong>

Gradle
default tasks (기본 실행작업)

.init
.project
.wrapper
.tasks

gradle tasks --all
현재할 수 있는 모든 작업


build.gradle
plug-in {           //  build script 빌드도구의 설정정보
  id '플러그인 ID'

}


eclipse 

.eclipse 로 아래 있는 모든것을 한번에 생성 

.eclipseProject -> .project 파일 생성
.eclipseClasspath -> .classpath 생성
.eclipseJdt -> .settings 생성 (지울시 파일 껍때기가 남음)


*eclipse 에러날시에  clean으로 지우고 다시 설치하는게 빠를수도 있다



<strong>.java 와.class 컴파일</strong>


Test1.java  (source)

class A {}  
class B {}
class C {}

javac Test1.java 컴파일시 class 만큼 bytcode 생성 
위상황에는 3개의 클래스 생성


A.java
class A {}  

B.java
class B {}

유지보수가 쉽도록 하나에 하나씩만 생성


<strong>소스파일과 .class파일 분리</strong>
배포 파일을 추출하는 등 관리가 쉽도록 분리


src/A.java
/B.java
/C.java

bin//A.java
/B.java
/C.java


javac -d bin src/A.java src/B.java  //  해당 자바파일 컴파일
javac -d bin src/*.java    // 모든 자바 컴파일
// 파일이 없으면 만들어서 생성 (bin)
// src는 파일 경로 안에 있는 A.java 를 컴파일 해서 bin에 넣는다


<strong>소스파일과 디렉토리</strong>
여러개의 소스파일을 관리하기 쉽하기 위해 하위디렉토리에 분류
-하지만 src파일에 여러개의 파일안에 소스가 존재해도 bin폴더에 한번에 컴파일한다


<strong>소스파일과 패키지</strong>  
클래스 블록을 유지 보수를 쉽게 하기 위해 만든 문법

src/A.java

src/B.java
package p1;
class B {}

src/p1/*.java

package 하면 컴파일시 p1 파일안에 B.class가 생긴다
소스파일을 찾기 쉽도록 소스파일도 package 이름과 같
은 폴더에 둔다


package는 여러개를 안에 넣을 수 있다

예)
package p1.px;   // package 를 안에 생성시 . 을 붙여준다
class B {}

src/p1/px/*.java 

와같이 소스파일과 package파일의 경로를 똑같이 맞춰준다  


</pre>
<br>
<hr>
<br>
<h1>2022-12-28</h1>
<br>
<br>
<pre>
<strong>shell script</strong>

set outputdir="C:\Users\bitcamp\git\bitcamp-nap\myapp\bin\main"
-파일 경로지정

echo %outputdir%
-경로 확인

for /d /r %v in (*) do javac -d %outputdir% %v\*.java
-반복문을 이용한 컴파일 작업


<strong>Maven</strong>

프로젝트 객체모델(Project Object Model: POM) 이라는 개념을 바탕으로  
프로젝트의 의존성관리, 라이브러리관리, 프로젝트 라이프사이클 관리 
기능등을 제공하는 프로젝트 관리도구이다. 플러그인을 기반으로 소스
코드로부터 배포 가능한 산출물을 만들어내는 빌드 기능을 제공한다.


<strong>클래스 블록의 공개 여부</strong>

public class A {}

public
-> 공개여부를 지정 : 다른 패키지에서 이 클래스에 접근할 수 있다 
공개 클래스명과 파일명이 같아야한다
하나의 파일에 2개 이상의 public클래스를 둘수 없다 
파일명과 동일해야하기 때문이다  

src\main\java\p1\X.java:2: error: class B is public, should be declared in a file named B.java
public class B {}
       ^


<strong>다른 패키지 클래스에 접근</strong>


p1.B obj;
다른패키지 클래스에 접근하는법


javac -d bin/main -classpath bin/main src/main/java/A.java

-classpath
컴파일시 다른 패키지 클래스에 접근

-bin/main
루트패키지가 들어있는 폴더여야 한다

예) bin/main/p1  (X)
패키지에 소속되지 않은 클래스를 나타냄


<strong>접근제한자</strong>

접근 제한자(Access Modifier)는 말 그대로 접근을 제한하기 위해 사용
여기서 접근이란 클래스 및 인터페이스 그리고 이들이 가지고 있는 멤버의
접근을 말합니다. 


- public 접근 제한자
 단어 뜻 그대로 외부 클래스가 자유롭게 사용할 수 있도록 합니다.

- protected 접근 제한자
 같은 패키지 또는 자식 클래스에서 사용할 수 있도록 합니다.

- private 접근 제한자
 단어 뜻 그대로 개인적인 것이라 외부에서 사용될 수 없도록 합니다

- default 접근 제한
 같은 패키지에 소속된 클래스에서만 사용할 수 있도록 합니다.


 ////////////////////


*import
경로를 미리 지정해준다

예)
import p1.B;
// import p2.C;
import p2.px.C;
import p2.px.aaaaa.bbbbb.ccccc.ddddd.D;
class A {
  B obj; 
  p2.C obj2;
  C obj3;
  D obj4;
}

- 둘다 같은 코드이나 import문장을 활용한 차이이다 
- 위를 이용시 아래처럼 바꿔서 컴파일 한다 

class A {
  p1.B obj; 
  p2.C obj2;
  p2.px.C obj3;
  p2.px.aaaaa.bbbbb.ccccc.ddddd.D obj4;
}


<strong>-sourcepath</strong>



javac -d bin/main -sourcepath src/main/java src/main/java/A.java


-sourcepath src/main/java

->
사용하는 클래스의 소스파일이 있다면
classpath로 경로를 지정할 필요가 없다

A.java 를 컴파일할때 A클래스가 사용하는 다른
클래스의 소스파일 경로를 알려준다
=> 
A.java를 컴파일 할 때
A가 사용하는 클래스의 소스파일도 함께 컴파일 된다


<strong>main()</strong>

$java A

java
-bytecode인터프리터
-bytecode player
-JVM (자바버추얼머신)

1. A 클래스 코드를 메모리에 적재(loading)
2. byetcode 검증
3. main() 호출 

puclic static void main(String[] args) {}

-엔트리포인트 (entry point)
-main 메소드 형식(Method Signature = function prototype)을 반드시 
지켜야하며 args (변수명) 은 달라도 된다


-classpath

$java -classpath bin/main A
$java -cp bin/main A
$java -cp bin/main p1.B

루트패키지와 클래스가 들어있는 디렉토리 경로
자바컴파일러와 JVM은 클래스를 찾을 때 이 옵션의 경로를 따라간다


<strong>소스파일 인코딩</strong>

vs코드에서 저장하여 a.java 파일을 컴파일 하고
eclipse에서 읽을 때 window는 한글이 깨진다
949로 저장하기 때문


-encoding UTF-8
을 지정


<strong>정수 리터럴</strong>

4byte

10진수: 100
8진수:  078
2진수:  0b0101
        0B0101
16진수: 0XAC00
        0xAC00


javascript와 다르게 정수 리터럴의 메모리 크기(표현할 수 있는 값의 범위가 있다)가 있다

100 (4byte 정수): -2147483648 ~ 2147483647


<strong>데이터 타입과 리터릴</strong>


정수

4byte 리터럴 (int) 100
8byte 리터럴 (long) 100L 100l

부동소수점

4byte 리터럴 (float <- 단정도) 3.14f 3.14F
8byte 리터럴 (double <- 배정도) 3.14

논리

4byte 리터럴 true,false

문자

2byte 리터럴 'A' '가'

문자열 
- 9.x 버전보다 낮으면 char(2byte) 배열
- 9.x 높다면 byte(1~3)배열

객체 "Hello"

자바기본데이터타입 (primitive Data Type)



값을 메모리에 저장

encoding(변환)

sign-magnitude

논리
true(1) false(0)

한개(4byte)
배열(1byte)



부동소수점 -> IEEE-754 명세서 


12.375 -> 2진수 -> 전기신호 -> 메모리저장

2진수 
-> 1100.011
-> 1.100011 X 10**3
-.100011(가수부), 3(지수부)


</pre>
<br>
<hr>
<br>
<h1>2022-12-29</h1>
<br>
<br>
<pre>
<strong>변수선언(delaration)</strong>
값을 담는 메모리를 준비시키는 문법


자바기본데이터타입 (primitive Data Type)
데이터타입 변수명;

정수 
-byte(1byte)
-short(2byte)
-int(4byte)
-long(8byte)

부동소수점
-float(4byte)
-double(8byte)

논리
-boolean (4/1)

문자
-char(2byte)


reference type

그외
-클래스


*활용*


int a(storage location);

a = 100;

=
-> assignment operator(할당연산자,배당연산자,대입연산자)


<strong>정수 변수</strong>
int a(4byte 정수 메모리) = 100(4byte 정수 리터럴);
long b(8byte 정수 메모리) = 100(4byte 정수 리터럴);

// 예외조건: 리터럴 값이 메모리보다 크기가 크더라도 담을 수
있다면 허용한다! 
->
short c(2byte 정수 메모리) = 100(4byte 정수 리터럴); 
byte d(1byte 정수 메모리) = 100(4byte 정수 리터럴);


<strong>char 변수</strong>


char c;

c (범위: 0~65535)
=> 문자코드(ucs2=UTF-16) 를 저장하는 2byte 메모리
c = 65;


System.out.println(c);

1. 현재 프로그램에서 사용하는 폰트 파일을 찾는다 => D2coding
2. D2coding 폰트 파일에서 65에 해당하는 문자를 찾는다
3. 폰트파일에서 읽은 A문자그림을 출력한다 

결과 
=> A



short s;

s (범위: -32768~ +32767)
s = 65;
System.out.println(c);
결과 
=> 65


<strong> '' 연산자</strong>


'A' -> return -> 65 
A문자에 대한 ucs2 코드값

char c = 'A';




/////////////////////////

public static void main(String[] args) {
  // 한 번에 한 개씩 변수를 선언할 수 있고,
  int i1;
  int i2;
  int i3;
  
  // 콤마(,)를 사용하여 여러 개의 변수를 한 번에 선언할 수 있다.
  int j1, j2, j3;
}


<strong>변수에 값 할당</strong>


- 변수가 가리키는 메모리에 값을 저장하는 것
- 문법
    변수명 = 변수 또는 리터럴;
- 용어 
    = : 할당 연산자(assignment operator)
    l-value : = 왼쪽에 있는 변수를 가리킨다. l-value는 리터럴이 될 수 없다.
    r-value : = 오른쪽에 있는 변수나 리터럴을 가리킨다.
- 의미
    = 오른쪽에 지정된 값을 왼쪽 변수가 가리키는 메모리에 저장.


<strong>변수 선언과 값 할당을 동시에 하기</strong> 


- 변수과 동시에 값을 즉시 저장할 수 있다.
- 문법
    데이터타입 변수명 = 값;


public class Exam0140 {
  public static void main(String[] args) {
    
    //변수 선언 + 값 저장
    //- 이렇게 변수 선언과 값 저장을 한 번에 하는 것을 '변수 초기화 문장'이라 부른다.
    int age = 20; 
  }
}


<strong># 여러 개의 변수를 한 번에 선언하고 초기화도 함께 수행하기 II</strong>


public class Exam0160 {
  
  public static void main(String[] args) {
    //모든 변수를 다 초기화시킬 필요는 없다.
    int a1, a2 = 200, a3, a4 = 400, a5;
  }
}


<strong>변수 사용</strong>

다른 도구(메서드; 함수라고도 부른다)에 값을 전달 할 수 있다.


int age = 20;

println() 메서드(도구)
- 콘솔(console)로 값을 출력할 때 사용하는 도구이다.
- 즉 JVM의 표준 출력 장치로 값을 출력한다.
- 사용법
    System.out.println(리터럴 또는 변수, 결과가 생성되는 명령문)

System.out.println(age); 
 println()을 실행할 때 age 변수를 넘기는 것이 아니라
 age 변수에 들어있는 값을 넘기는 것이다!!!!


<strong>레퍼런스 변수</strong>


public class Exam0451 {
  public static void main(String[] args) {

    java.util.Date d1 = new java.util.Date();
    java.util.Date d2 = d1;
    
    System.out.printf("%d, %d\n", d1.getDate(), d2.getDate());
    
    d1.setDate(22);
    
    System.out.printf("%d, %d\n", d1.getDate(), d2.getDate());
    // d1에 저장된 일자 값을 변경한 후 
    // d2에 저장된 일자 값을 출력해 보면 d1과 똑같이 변경되어 있다.
    // 이유는?
    // d1과 d2에 저장되는 것은 값이 아니라 (날짜 정보가 저장되어 있는 메모리의) 주소이다.
    // 이렇게 값을 저장하지 않고 값이 저장된 위치(주소)를 저장하는 변수를 
    // "레퍼런스 (변수)"라 부른다.
    // 자바 기본 데이터 타입(byte, short, int, long, float, double, boolean, char)을
    // 제외한 모든 타입의 변수는 레퍼런스이다.
  }
}


<strong>배열</strong>
같은 종류의 메모리를 여러개 생성할 때 사용하는 문법

데이터타입[] 변수명;  <- 권장
데이터타입 변수명[];  <- c style

변수명
=> 주소를 담는 변수 = reference 변수

변수명 = new 


<strong>배열선언</strong>


int a1, a2, a3, a4;
-변수들이 개별적이기 때문에 연속된 메모리가 아니다

a 
다른 메모리의 주소를 담을 만큼 적절한 크기


int[] a;

a = new int[4];
-연속된 메모리다

new
JVM은 Heap 영역이 연속된 int 타입의 메모리를 준비
리턴값은 준비한 메모리의 시작주소이다


<strong>RAM과 메모리 주소</strong>


app을 실행하면 OS가 사용할 메모리를 제공하고 app 실행 종료시 
사용한 메모리 영역은 사용가능한 영역으로 바뀐다 하지만 영역에
는 쓰레기(garbage value)가 남는다 이를 사용할 때 초기화하여 
사용한다고 의미한다 

메모리는 연속된 바이트의 1 차원 배열이다 
이해를 돕기위해 2차원으로 표현한다

app -> OS로부터 제공받은 메모리
명령문 -> (code segment)
데이터를보관 -> (data segment)


<strong>JVM과 메모리</strong>


java.exe(JVM) -> 사용

OS가 승인한 메모리에

method Area
- 클래스 코드를 둔다
- static 변수를 둔다

Heap
-new명령으로 준비한 변수를 둔다

constant Pool
-상수값을 둔다

stack
-스레드(thread)별로 stack 영역을 관리 
-> 1thread = 1stack


<strong>배열 메모리에 접근</strong>


int[] arr = new int[4];

arr[0] = 100;
arr[1] = 200;
arr[2] = 300;
arr[3] = 400;
arr[4] = 500;  // 실행오류 (runtime exception = Array )

예)
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 5 out of bounds for length 5
	at com.eomcs.lang.ex04.Exam0520.main(Exam0520.java:28)



<strong>배열 reference 변수</strong>

배열 인스턴스의 주소를 담는 변수


int[] arr = new int[4];

arr = 0;   // (X)
arr = null // (O)  레퍼런스 주소를 초기화시킨다


int a;

로컬변수는 자동으로 초기화 되지않는다
반드시 직접초기화 해야한다


<strong>배열 인스턴스와 가비지(garbage)</strong>

인스턴스의 주소를 잃어버려 사용할 수 없는 상태의 인스턴스

int[] arr = new int[4];

arr[0] = 300;
arr[2] = 400;


arr = new int[3];

arr[0] = 70;

위에있는 int[0] = 300; 은 주소를 잃어버려 접근 불가
이것을 farbage라고하며 메모리 부족시
garbage collector 가

1. 메모리가 부족할 때 
2. CPU 한가할 때 

자동으로 지워서 메모리를 제공해준다
 
 
<strong>가비지와 레퍼런스 카운트</strong>


JVM


int[] arr1 = new int[3]; (200)  X

int[] arr2 = arr1; (200)

int[] arr3 = new int[2]; (300)

arr1 = new int[4]; (400)

arr2 = arr3; (300)

JVM Cnt 
200 0
300 2
400 1



1) 배열 선언 + 초기화

  데이터타입[] 변수명 = new 데이터타입[]{값, 값, 값};
  - 배열 메모리를 초기화시킬 때는 배열 개수를 지정해서는 안된다.
  - 배열을 초기화시키는 값의 개수 만큼 메모리가 만들어진다.
  - 즉 다음은 값 개수만큼 int 메모리가 3개가 생성된다.
   ex) int[] arr = new int[]{10, 20, 30};
  - 다음과 같이 new 명령을 생략할 수 있다.
    데이터타입[] 변수명 = {값, 값, 값};
    ex) int[] arr = {10, 20, 30};


 2) 배열 선언 후 따로 배열 초기화 문장 실행

   데이터타입[] 변수명;
   변수명 = new 데이터타입[]{값, 값, 값};
   ex)
   int[] arr1;
   arr1 = new int[]{10, 20, 30};
  - 변수를 선언한 후 따로 배열을 초기화시킬 때는
    new 명령을 생략할 수 없다.


<strong>상수 - 변수의 값을 고정하는 방법</strong>

public class Exam0610 {
  public static void main(String[] args) {
    // 변수
    // => 언제든지 값을 변경할 수 있다.
    int a; //static type binding
    a = 10;
    a = 100;
    a = -300;

    // 상수
    // => 값을 오직 한 번만 저장할 수 있다.
    // => 변수 앞에 final을 붙여라!
    final int b;
    b = 100;

    // 만약 final로 선언된 변수의 값을 두 번째로 바꾸려 한다면?
    //    b = 200; // 컴파일 오류!

    // 변수와 상수를 구분하기 위해서
    // => 상수인 경우 이름을 보통 모두 대문자로 작성한다.
    // => 그리고 변수를 선언하는 문장에서 바로 값을 초기화시킨다.
    final float PI = 3.14159f;
    final float MILE = 0.621371f;


<strong>변수의 종류</strong>


public class Exam0710 {

  int a; // 인스턴스 변수

  static int b; // 클래스 변수 == 스태틱 변수


  public static void main(String[] args/*로컬변수=파라미터*/) {

    int c; // 로컬 변수

  }
}

// 인스턴스 변수(instance variable)
// - new 명령을 사용하여 인스턴스를 생성할 때 준비되는 변수
//
// 클래스 변수(class variable = static variable)
// - 클래스가 로딩될 때 준비되는 변수
//
// 로컬 변수(local variable)
// - 블록을 실행할 때 준비되는 변수
//
// 파라미터(parameter)
// - 메서드의 아규먼트를 받는 로컬 변수이다.
//   예) 위의 코드에서 main()의 args 로컬 변수
//


1. 값.println(값)
2. 



system.out.println()

system
도구함(class)

out
변수(field)

println
작업자=연산자(method=function)

()
파라미터



system.out.println("번호: " + no)
=>

과정 (Optimizing)
"번호: " + "1"

결과
번호: 1


System.out.printf("번호: %d\n", no);

printf
문자열과 

String levelTitle;
switch (level) {
  case 0: levelTitle = "비전공자"; break;
  case 1: levelTitle = "준전공자"; break;
  default : levelTitle = "전공자";
}

System.out.printf("전공: %s\n" , levelTitle);


<strong>키보드 입력</strong>


Scanner KeyScanner = new Scanner(System.in);

new Scanner
-파라미터로 주어진 입력장치에서 데이터를 읽는 일을 하는 객체
-> 키보드에서 읽은 바이트를 가공한 문자데이터(UTF-16)

(System.in)
-키보드정보 :
사용자가 키보드의 키를 눌렀을때 어떤 키를 눌렀고 이때
caps lock의 상태가 무엇이며, shift키의 상태는 무엇인지

keyScanner.nextLine()
-keyScanner(값) 의 문자정보를 받아서 사용자가
enter를칠때 까지 한줄의 문자열을 만든후 리턴
한다

keyScanner (맨앞 소문자)
-값

nextLine()
-값을 사용해서 작업수행


Integer.parseInt (문자열값)

Integer (맨앞 대문자)
-도구함


**** 객체 = 데이터(값) 이  저장된 메모리****

외부 호출자에게 작업결과 리턴 <= 객체.매서드(파라미터,파라미터)

객체에 값을 사용,저장할 수 있고 파라미터의 값을 사용하여
외부 호출자에게 작업 결과를 리턴할 수 있다

</pre>
<br>
<hr>
<br>
<h1>2022-12-30</h1>
<br>
<br>
<pre>
<strong>Date 클래스</strong>


1.
java.sql.Date today = new java.sql.Date(System.currentTimeMillis());
String createdDate = today.toString();

-toString 가 사용하는 도구함은  java.sql.Date 이다


currentTimeMillis
- OS의 시간 데이터를 읽어서 long타입의 정수값(1970년1월1일 0시 0분 0초 이후 경과된 시간)
으로 today = new Date()에게 리턴한다

-> 년,월,일, 데이터 생성 

=> today.toString() yyyy-MM-dd 로 리턴


2.

Date today = Date(System.currentTimeMillis());
String createdDate = today.toString();

에서 Date를 사용하고 싶다면 eclipse에서 해당 코드에
커서를 두고 ctrl + shift + O 를 하면 

java.sql.Date
java.util.Date

어떤것을 사용할것인가 나온다 해당 도구함을 선택하면
자동으로 import 로 추가해 준다

import java.sql.Date;


<strong>배열의 사용법</strong>


if (str.equals("Y")) {
  break;
}

비교할때
자바에서는 = 은 불가능
equals를 써줘야한다


Scanner keyScanner = new Scanner(System.in);{
  .
  .
}
keyScanner.close();

위와 같이 열고닫아야하는 메서드가 있다

<strong>메서드 사용법</strong>

method 
-기능단위로 코드로 묶는 문법
-재사용이쉽다
-코드가 블록 단위로 정리되어 유지보수가 쉽다
-

다른 메서드에서 선언한 변수는 접근불가

static을 이용하면 접근가능


<strong>클래스 사용법</strong>


1.메서드 분류하기 -> class 문법

class App {
  main(){}
  InputMembers(){}
  promptMember(){}
  promptString(){}
  promptInt(){}
}


<strong>클래스 사용법 II</strong>


int no;
String name;
String tel;
String postNo;

=> 
회원 정보를 담을 새 데이터 
타입을 정의 

class Member {
  
int no;
String name;
String tel;
String postNo;

}


<strong>클래스로 정의한 새타입의 메모리 준비하기</strong>


Member m(레퍼런스변수) = new Member();

- new 명령으로 준비하는 배열은 자동으로 초기화 된다
- m의 주소에 있는 값들을 instance라고 한다
- 주소를 저장한 변수에 0을 넣고 싶다면 null키워드를 사용한다
- null 은 문자열이 아니다 

값을 넣을때는 

m.no = 100;
m.name = "홍길동";


Member m2 = new Member();
m2에 맞는 메모리에 주소와 instance가 준비

=> 

Member 의 인스턴스 
Member의 객체 


<strong>키보드 입력, 변수, 조건문 ,반복문</strong>

main 

-int,byte,boolean,String
-Scanner,System
-

4. 배열
배열
for(),반복문,break

5. 메서드 사용법

main()

inputMembers(){}
  promptString
  promptInt
promptMembers(){}

클래스 사용법

main()

MemberHeandler
inputMembers(){}
  promptString    
  promptInt


promptMembers(){}
  inputString
  inputInt


<strong>GRASP 패턴</strong>
OOP의 일반적인 설계지침

1. Information Expert
2. Low Coupling
3. High cohesion


<strong>자습하기</strong>

1. git\bitcamp-ncp-teacher\myapp\app-04 

- myapp 
- gradle eclipse
- eclipse에서 f5번

클래스 나누기 연습

ex07,09 보기


</pre>
</section>
</main>
</div>
<footer id="footer">

<li><small><a href="https://github.com/96abab/test.io.git">96abab.GitHub.com - test.io</a></small></li>
</footer>
</body>
</html>
