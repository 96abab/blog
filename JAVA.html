<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>96abab</title>
    <link rel="stylesheet" href="stylesheet.css">
    <link rel="icon" href="https://96abab.github.io/test.io/ducklogo.png">
    
</head>
<body>
<div id="container">
<header>
  <h2>JAVA</h2>
  <nav>
    <ul id="topMenu">
      <li><a href="https://96abab.github.io/test.io">home</a></li>
      <li><a href="#">menu1</a></li>
      <li><a href="#">menu2</a></li>
    </ul>
  </nav>
</header>
</div>
<aside>
<ul id="sidebar">
  <li><a href="index.html">Home</a></li>
  <br>
  <li><a href="assignment.html">과제</a></li>
  <br>
  <li><a href="tictactoe.html">TICTACTOE</a></li>
  <br>
  <li><a href="cloudOS.html">1.CloudOS(리눅스서버설치)</a></li>
  <br>
  <li><a href="linux.html">2.리눅스 명령어 정리</a></li>
  <br>
  <li><a href="HTML5.html">3.HTML수업</a></li>
  <br>
  <li><a href="CSS.html">4.CSS수업</a></li>
  <br>
  <li><a href="JAVAscript.html">5.JAVAscript</a></li>
  <br>
  <li><a href="JAVA.html">6.JAVA</a></li>

</ul>
</aside>
<main class="contents">
<section id="headling">
<h1>2022-12-26</h1>
<br>
<br>
<pre>
<strong>web Application Architecture</strong>


client (web browser)
HTML
CSS
JAVAscript
+
jquery
bootstrap
+
react

-서버에 있는 자원을 받아 실행


web server 

HTML,CSS,javascript등 읽는다
-정적자원 :실행하지 않고 그대로 읽어 리턴해 주는것(static resource)


<strong>springboot 기술스택</strong>


java로 만들어졋다 (JVM - interpreter,player,runtime Engine) -> tomcat server -> jakartaEE API(javaEEApi) -> spring Framework -> java APP , mybatis , JSP , thymeleaf

JDK

<strong>java설치 준비</strong>

1. java.oracle에서  x64 MSI Installer 다운
2. 환경변수 설정
JAVA_HOME -> JDK 설치 폴더
PATH -> JDK/bin 폴더경로 추가


setx JAVA_HOME JDK설치폴더 /m
setx PATH "JDK/bin;%PATH%"

/usr/libexec/java_home -V


gradle.org



*JAVA_HOME
1. JDK가 설치된 폴더 경로
2. java App 이 JDK를 찾을떄 이 환경변수를 이용한다


*PATH
-> 실행프로그램이 있는 폴더 경로
-> CLI에서 프로그램 이름으로 
바로 실행하고 싶을 때  

빌드 도구 설치 및 설정
1. 프로잭트폴더를 준비
2. JDK 를 이용하여 컴파일 신청, 테스트 수행
3. 아카이브 (archive) 파일을 생성 
배포파일 (.jar,)


*인터프리터 방식 

node hello.js


*컴파일 방식

gcc -o hello.exe hello.c

실행 hello.exe or hello


*하이브리드 방식 


컴파일 방식보다 나은 이유

1. 동일한 바이트코드를 생성하여 OS마다 컴파일 할 필요가 없다

2. OS용 JVM이 설치되어 있다면 실행할 수 있다

3. 컴파일 과정에서 문법의 오류를 모두 찾아낸다 
(실행마다 문법검사를 하는 순수 인터프리터방식 보다 실행속도가 빠르다)

4. 완전 기계어는 아니지만 기계어에 가까운 언어로 
   변환된 명령을 실행하기 때문에 소스에 작성된 
   명령을 실행하는 것보다 빠르다



Hello.java

-컴파일

문법검사 수행 -> 문법오류를 모두 찾아냄
최적화 -> 실행 성능 향상


<strong>LLVM 컴파일</strong>
low level virtural Machine

1. LLVM 이전

 
hello.c -> C compiler -> 기계어 -> windows or macOS or Linux

컴파일러를 만드는 입장에서 c 언어를 해석하는 부분은 동일하다
=> 중복개발 


서로 다른언어 일때 컴파일러가 windows 에 맞는 기계어로 바꾸는
부분은 동일
=> 중복개발


*기존방식의 문제점

compiler제작자는 변환시킬 언어들과 변환후 적용할 기계어 또한
알아야한다는 부담


2. LLVM 이후 
LLVM 방식을 사용하는 이유
새 프로그래밍 언어와 컴파일러를 만들기 쉽다
다양한 언어를 쉽게 중간어로 바꾸고 다시 기계어로 변환시킬 수 있다


1단계 컴파일

-각 언어들을 중간어로 바꾸면 된다 컴파일러 제작자는 
한개의 가상기계어만 다루면 된다 


2단계 컴파일

-중간어를 기계어로 바꾸기만 하면 된다 


<strong>JAVA 와 LLVM</strong>


java -> .java
kotlin -> .kt
scala -> .scala  
groovy -> groovy.
자바 호환 언어

=> .class (bytcode)

=> 기계어



<strong>JDK,JRE,JVM</strong>

.class -> JVM -> 실행


JRE (java Runtime Environment)
javalibrary


JDK (java development kit)
개발도구(컴파일러,디버거등)


<strong>java EE, java SE, java ME</strong>


java EE (Enterprise Edition) -> 기업용 Applucation 제작에 필요한 도구

java SE (Standard Edition) -> java.app 제작 필수 도구
-JDK, JRE, server 용 JRE

java ME (Micri Edition) -> 임베디드 app 제작에 필요한 도구


<strong>Eclipse IDE</strong>


개발 플랫폼 + plug-in => 개발도구확장



<strong>java project 폴더 준비</strong>


1. 프로젝트 폴더 생성

c:/users/bitcamp/git/bitcamp-ncp/boot-project


2. 'boot-project/' 폴더를 java프로젝트 폴더로 초기화 

$gradle init

패키지는 보통 회사.프로잭트명 으로한다

kr.co.bitcamp.bootapp


3. 기본 예제 프로그램 실행

gradle -q run  (설명 빼고 결과만 실행)


프로젝트 폴더 boot-app


app 하위 프로젝트. 메인프로젝트
src/main/java   -> java소스파일을 두는 폴더
src/main/resources -> 기타 파일을 두는 폴더
src/test/java -> 단위테스트를 수행하는 자바소스파일
src/test/resources -> 단위테스트 관련 기타 파일

app
build.gradle -> build script파일 (빌드설정정보)
build -> 빌드로 생성한 파일 및 디렉토리를 두는 폴더 


boot-app
setting.gradle -> 프로그램 설정정보
gradlew,gradlew.bat -> gradle 도구 설치 명령 파일 
                      (gradle 도구가 설치되지 않았을때 사용)
gradle/ -> gradlew,gradlew.bat 가 사용하는 파일이 들어있다
.gradle/ -> gradle 도구들  


<strong>springboot 프로젝트 만들기</strong>


spring.io방문 -> project -> springboot 메뉴 -> spring initializr 클릭 
add dependencies

1. spring boot dev tool     -> 자동 로딩
2. spring configuration processor  -> project
3. spring web


<strong>JAVA에서 Spring Boot 까지</strong>


Spring Boot -> Tomcat server (networking API, thrend prog.) 
+ spring framework(spring webVMC,spring IOC)+ mybatis+(JSBC API) + SQL)


-> servlet/JSP, JSBC API

-> java I/O API, collection API

-> java 기본 문법 (built-in class)

-객체지향문법
-메서드/클레스
-연산자/제어문/반복문
-변수/리터럴

</pre>
<br>
<hr>
<br>
<h1>2022-12-27</h1>
<br>
<br>
<pre>
<strong>Maven 빌드 도구의 표준 프로젝트 디렉토리 구조</strong>

~/git/bitcamp-ncp/      //git repo.
~/git/bitcamp-ncp/boot-app/ // project 폴더


settings.gradle       // gradle 빌드 보조그크립트 파일
gradle/       // gradle 프로그램을 local에 설치해주는 도우미 프로그램
gradlew.bat     // gradle/ 폴더에 들어있는 설치프로그램을 실행하여 gradle을 설치하고
                // 설치한 gradle을 사용해 gradle 명령어를 실행하는 shell 프로그램
gradlew     // unix/linux/winOS 용
.gradle/ gradle 도구가 작업하는 동안 사용하는 임시 폴더


/app/     // sub project 
/app/src/     //소스폴더
/app/build.gradle/      gradle 빌드 스크립트 파일


/////////

<strong>App.java 에서 @명령어 로 import 가 자동 완성 안됬을 때</strong>


1. boot-app (프로젝트 파일에 .gradle 이 repo. 등 다른 곳에 있는지
확인 하여야한다)

2. .gradle이 잘못된 경로에 있을 경우 지웟다가 gradle -q run 을 
정확한 경로에 지정해줘야 한다

3. 이게 경우가 아닐시에는 해당 기능을 하는 서포트 프로그램이 작동하는지 확인
(java일 경우 language support of java(TM) by Red Hat  있는지 확인)


<strong>Eclipse IDE 와 프로젝트</strong>



<strong>Gradle 빌드 도구</strong>

Gradle
default tasks (기본 실행작업)

.init
.project
.wrapper
.tasks

gradle tasks --all
현재할 수 있는 모든 작업


build.gradle
plug-in {           //  build script 빌드도구의 설정정보
  id '플러그인 ID'

}


eclipse 

.eclipse 로 아래 있는 모든것을 한번에 생성 

.eclipseProject -> .project 파일 생성
.eclipseClasspath -> .classpath 생성
.eclipseJdt -> .settings 생성 (지울시 파일 껍때기가 남음)


*eclipse 에러날시에  clean으로 지우고 다시 설치하는게 빠를수도 있다



<strong>.java 와.class 컴파일</strong>


Test1.java  (source)

class A {}  
class B {}
class C {}

javac Test1.java 컴파일시 class 만큼 bytcode 생성 
위상황에는 3개의 클래스 생성


A.java
class A {}  

B.java
class B {}

유지보수가 쉽도록 하나에 하나씩만 생성


<strong>소스파일과 .class파일 분리</strong>
배포 파일을 추출하는 등 관리가 쉽도록 분리


src/A.java
/B.java
/C.java

bin//A.java
/B.java
/C.java


javac -d bin src/A.java src/B.java  //  해당 자바파일 컴파일
javac -d bin src/*.java    // 모든 자바 컴파일
// 파일이 없으면 만들어서 생성 (bin)
// src는 파일 경로 안에 있는 A.java 를 컴파일 해서 bin에 넣는다


<strong>소스파일과 디렉토리</strong>
여러개의 소스파일을 관리하기 쉽하기 위해 하위디렉토리에 분류
-하지만 src파일에 여러개의 파일안에 소스가 존재해도 bin폴더에 한번에 컴파일한다


<strong>소스파일과 패키지</strong>  
클래스 블록을 유지 보수를 쉽게 하기 위해 만든 문법

src/A.java

src/B.java
package p1;
class B {}

src/p1/*.java

package 하면 컴파일시 p1 파일안에 B.class가 생긴다
소스파일을 찾기 쉽도록 소스파일도 package 이름과 같
은 폴더에 둔다


package는 여러개를 안에 넣을 수 있다

예)
package p1.px;   // package 를 안에 생성시 . 을 붙여준다
class B {}

src/p1/px/*.java 

와같이 소스파일과 package파일의 경로를 똑같이 맞춰준다  


</pre>
<br>
<hr>
<br>
<h1>2022-12-28</h1>
<br>
<br>
<pre>
<strong>shell script</strong>

set outputdir="C:\Users\bitcamp\git\bitcamp-nap\myapp\bin\main"
-파일 경로지정

echo %outputdir%
-경로 확인

for /d /r %v in (*) do javac -d %outputdir% %v\*.java
-반복문을 이용한 컴파일 작업


<strong>Maven</strong>

프로젝트 객체모델(Project Object Model: POM) 이라는 개념을 바탕으로  
프로젝트의 의존성관리, 라이브러리관리, 프로젝트 라이프사이클 관리 
기능등을 제공하는 프로젝트 관리도구이다. 플러그인을 기반으로 소스
코드로부터 배포 가능한 산출물을 만들어내는 빌드 기능을 제공한다.


<strong>클래스 블록의 공개 여부</strong>

public class A {}

public
-> 공개여부를 지정 : 다른 패키지에서 이 클래스에 접근할 수 있다 
공개 클래스명과 파일명이 같아야한다
하나의 파일에 2개 이상의 public클래스를 둘수 없다 
파일명과 동일해야하기 때문이다  

src\main\java\p1\X.java:2: error: class B is public, should be declared in a file named B.java
public class B {}
       ^


<strong>다른 패키지 클래스에 접근</strong>


p1.B obj;
다른패키지 클래스에 접근하는법


javac -d bin/main -classpath bin/main src/main/java/A.java

-classpath
컴파일시 다른 패키지 클래스에 접근

-bin/main
루트패키지가 들어있는 폴더여야 한다

예) bin/main/p1  (X)
패키지에 소속되지 않은 클래스를 나타냄


<strong>접근제한자</strong>

접근 제한자(Access Modifier)는 말 그대로 접근을 제한하기 위해 사용
여기서 접근이란 클래스 및 인터페이스 그리고 이들이 가지고 있는 멤버의
접근을 말합니다. 


- public 접근 제한자
 단어 뜻 그대로 외부 클래스가 자유롭게 사용할 수 있도록 합니다.

- protected 접근 제한자
 같은 패키지 또는 자식 클래스에서 사용할 수 있도록 합니다.

- private 접근 제한자
 단어 뜻 그대로 개인적인 것이라 외부에서 사용될 수 없도록 합니다

- default 접근 제한
 같은 패키지에 소속된 클래스에서만 사용할 수 있도록 합니다.


 ////////////////////


*import
경로를 미리 지정해준다

예)
import p1.B;
// import p2.C;
import p2.px.C;
import p2.px.aaaaa.bbbbb.ccccc.ddddd.D;
class A {
  B obj; 
  p2.C obj2;
  C obj3;
  D obj4;
}

- 둘다 같은 코드이나 import문장을 활용한 차이이다 
- 위를 이용시 아래처럼 바꿔서 컴파일 한다 

class A {
  p1.B obj; 
  p2.C obj2;
  p2.px.C obj3;
  p2.px.aaaaa.bbbbb.ccccc.ddddd.D obj4;
}


<strong>-sourcepath</strong>



javac -d bin/main -sourcepath src/main/java src/main/java/A.java


-sourcepath src/main/java

->
사용하는 클래스의 소스파일이 있다면
classpath로 경로를 지정할 필요가 없다

A.java 를 컴파일할때 A클래스가 사용하는 다른
클래스의 소스파일 경로를 알려준다
=> 
A.java를 컴파일 할 때
A가 사용하는 클래스의 소스파일도 함께 컴파일 된다


<strong>main()</strong>

$java A

java
-bytecode인터프리터
-bytecode player
-JVM (자바버추얼머신)

1. A 클래스 코드를 메모리에 적재(loading)
2. byetcode 검증
3. main() 호출 

puclic static void main(String[] args) {}

-엔트리포인트 (entry point)
-main 메소드 형식(Method Signature = function prototype)을 반드시 
지켜야하며 args (변수명) 은 달라도 된다


-classpath

$java -classpath bin/main A
$java -cp bin/main A
$java -cp bin/main p1.B

루트패키지와 클래스가 들어있는 디렉토리 경로
자바컴파일러와 JVM은 클래스를 찾을 때 이 옵션의 경로를 따라간다


<strong>소스파일 인코딩</strong>

vs코드에서 저장하여 a.java 파일을 컴파일 하고
eclipse에서 읽을 때 window는 한글이 깨진다
949로 저장하기 때문


-encoding UTF-8
을 지정


<strong>정수 리터럴</strong>

4byte

10진수: 100
8진수:  078
2진수:  0b0101
        0B0101
16진수: 0XAC00
        0xAC00


javascript와 다르게 정수 리터럴의 메모리 크기(표현할 수 있는 값의 범위가 있다)가 있다

100 (4byte 정수): -2147483648 ~ 2147483647


<strong>데이터 타입과 리터릴</strong>


정수

4byte 리터럴 (int) 100
8byte 리터럴 (long) 100L 100l

부동소수점

4byte 리터럴 (float <- 단정도) 3.14f 3.14F
8byte 리터럴 (double <- 배정도) 3.14

논리

4byte 리터럴 true,false

문자

2byte 리터럴 'A' '가'

문자열 
- 9.x 버전보다 낮으면 char(2byte) 배열
- 9.x 높다면 byte(1~3)배열

객체 "Hello"

자바기본데이터타입 (primitive Data Type)



값을 메모리에 저장

encoding(변환)

sign-magnitude

논리
true(1) false(0)

한개(4byte)
배열(1byte)



부동소수점 -> IEEE-754 명세서 

12.375 -> 2진수 -> 전기신호 -> 메모리저장

2진수 
-> 1100.011
-> 1.100011 X 10**3
-.100011(가수부), 3(지수부)


</pre>
</section>
</main>
</div>
<footer id="footer">

<li><small><a href="https://github.com/96abab/test.io.git">96abab.GitHub.com - test.io</a></small></li>
</footer>
</body>
</html>
