<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JAVAscript</title>
    <link rel="stylesheet" href="stylesheet.css">
    <link rel="icon" href="https://96abab.github.io/test.io/ducklogo.png">
    
</head>
<body>
<div id="container">
<header>
  <h2>JAVAscript</h2>
  <nav>
    <ul id="topMenu">
      <li><a href="https://96abab.github.io/test.io">home</a></li>
      <li><a href="#">menu1</a></li>
      <li><a href="#">menu2</a></li>
    </ul>
  </nav>
</header>
</div>
<aside>
<ul id="sidebar">
  <li><a href="index.html">Home</a></li>
  <br>
  <li><a href="assignment.html">과제</a></li>
  <br>
  <li><a href="tictactoe.html">TICTACTOE</a></li>
  <br>
  <li><a href="cloudOS.html">1.CloudOS(리눅스서버설치)</a></li>
  <br>
  <li><a href="linux.html">2.리눅스 명령어 정리</a></li>
  <br>
  <li><a href="HTML5.html">3.HTML수업</a></li>
  <br>
  <li><a href="CSS.html">4.CSS수업</a></li>
  <br>
  <li><a href="JAVAscript.html">5.JAVAscript</a></li>
</ul>
</aside>
<main class="contents">
<section id="headling">
<hr>
<h1>2022-12-01</h1>
<br>
<br>
<strong>##프로그램 실행과 프로그래밍</strong>
<br>
<br>
app (컴퓨터가 할 일을 순서대로 기록한 것 = programming)을 읽기OS에 (loading)저장<br>
ram에 저장한 기록을 cpu에 전달하고 명령어 실행하고 다시 ram으로 전달 하면 결과를<br>
OP에서 다시 APP로 전달해 출력한다
<br>
- 위 과정을 프로그램 실행이라고 한다 이때 ram에 저장한 데이터를 읽는 방법이 각각cpu<br>
명령어가 다르기 때문에 주의해야한다 
<br>
<br>
<strong>##CPU 와 RAM , bit</strong>
<br>
<br>
cpu와 ram이  테이터를 주고 받는 선 개수가 bit이다 나머지 선들은 전원과
다른기능들을 담당하고 제조사는 cpu를 통해 명령을 실행시키는 방법을 명
세서로 제공한다
<br>
신호를 보내는 비트 규칙을 instruction set 이라고 부른다
예) 64개=64bit
-cpu 버전이 높아지면 명령규칙 추가된다
-cpu 마다 명령어가 다르다
예) i계열vs제온계열
-cpu 제조사마다 규칙(전기신호)이 다르다
<br>
<br>
<strong>##명령어 작성</strong>
<br>
<br>
1. cpuinstruxtionset 명세서를 보고 직접 명령어(기계어) 작성
<br>
<br>
- cpu bit가 적은 8bit 시절에는 개발자가 직접 작성하기도 했다
<br>
- 보통 2진수를 짧게 표현한 16진수를 사용해서 작성
<br>
- 인간의 문자와 많이 다르기 때문에 작성이 까다롭고 힘들다
<br>
- cpu bit가 36,64 로 늘어나면서 더욱 어려워 졋다
<br>
- cpu마다 명령어(전기신호,비트규칙)가 다르기 때문에 다양한 cpu에서<br>
실행할 수 있는 명령어를 작성하기 매우 힘들다
<br>
<br>
2. 직접 기계어로 작성하는 대신 간결한 영어로 이루어진 명령어 사용 (assembly) <br>
- assembly언어를 기계어로 바꿔주는 프로그램을 compiler 라고 한다
<br>
<br>
- 명령어가 영어단어와 비슷해서 작성이 편하다
<br>
- compiler가 각각의 기계어로 번역해주기 때문에 cpu마다 명령어를<br> 
다르게 작성 할 필요가없다
<br>
<br>
3. C 인간 친화적인 프로그래밍 언어로 명령어 작성하기
<br>
<br>
-명령어를 만들고 각각 compiler 로 기계어로 바꾼후 각 cpu와<br>
 운영 체제에 알맞게 맞춰야한다
 <br>
-예전 프로그램 공유 문화 명령어 소스코드를 그대로 공유하여<br>
 각 cpu에 맞게 컴파일 했다
<br>
-linux는 컴파일러가 기본 내장
<br>
-c컴파일 +OS 적용 명령 사용<br>
DirextX 명령은 windows 전용 따라서 다른 운영체제를 사용하면<br> 
컴파일할 수 없다 
<br>
<br>
<strong>프로그래밍 언어 와  컴파일러</strong>
-언어선택
<br>
프로그래밍언어마다 특장점이 있다<br>
->프로젝트 성격에 따라 언어 선택<br>
-인공지능,머신러닝,딥러닝 : python <br>
web app : haba,php,go <br>
web ui : JAVAscript,typescript
<br>
<br>
<strong>컴파일 방식과 인터프리트 방식</strong>
<br>
컴파일 방식 : c언어를 컴파일러로 os에 맞춰 기계어로 바꿔주고 OS에 저장 cpu에서 명령처리
- 실행할때 기계어 파일만 있으면 된다
- 소스파일 필요없다 -> 소스파일을보호(자산)
- 실행할때 컴파일러 불필요
- 기계어 바로실행 -> 실행속도 빠름
<br>
<br>
인터프리트방식 (viewe) : js를 JAVAscriptinterpreter (컴파일 하지 않음)  
- 실행할때마다 소스 파일 필요 -> 소스파일 공개 -> 자산으로 보호하기 힘들다
- 실행하려면 인터프리트 필요
- 명령어를 해석해서 실행 -> 실행속도 느리다
예) 
<br>
<br>
<strong>JAVAscript (interpreter)Engine</strong>
<br>
chrome에는 webkit html,css렌더링엔진 과 v8 javascript엔진 이 있다 <br>
v8을 이용해 node.js 를 만들엇다 웹 브라우저 없이 JAVAscript실행
<br>
<br>
<strong>JIT compile 과 AOT compile</strong>
<br>
1. plain 인터프리터: 매번 소스를 검사하고 해석하기 때문에 속도가 느리다
<br>
2. JIT (just in time) 컴파일: 실행하려는 일부 코드를 컴파일 -> 컴파일 <br>
할 때 잠깐 느려지지만 이후 실행할때 빨라진다
<br>
3. AOT (ahead of time) 컴파일: 설치 시점에 미리 전체 소스를 컴파일 해둔다 <br>
-> 설치시간이 좀 더 걸린다 -> 실행은 컴파일방식과 같다
<br>
- bytecode ="중간코드" = p-code : 진짜  기계어가 아니라 흡사한 코드
<br>
- 안드로이드를 자바로 개발하면 bytecode로 play store 에 올린다<br> 
다운 받을시 사용자의 cpu에 맞춰 컴파일 한다 
<br>
<br>
<strong>Web browser와 JAVAscript</strong>
<br>
<hr>
<br>
<h1>2022-12-02</h1>
<br>
<br>
<strong>OS,cpu,ram,HDD,기계어,명령문 관계도</strong>
<br>
<br>
1. 개발자가 명령문 작성 (instruction set)
<br>
- c,java등 인간친화용 언어로 명령문 작성<br>
- compiler 가 기계어로 번역<br>
<br>
2. HDD.SSD등 외장하드에 저장
<br>
3. 일부명령어를 실행하기 위해 ram으로 복사 (loading)
<br>
4. cpu로 보내 각 명령어를 처리<br>
<br>
- l1 명령어 임시 보관
<br>
- l2 data 임시 보관
<br>
- l3 data 멀티디어 , core끼리 공유
<br>
<br>
console.log(값,값,값,,);   <br>
웹브라우저에 개발자 보드 콘송함에를 값을 출력<br>
<br>
-console = 도구 = object (객체)
<br>
-log = 기능 = funcrion (함수)
<br>
-(값,값,값,,) = 기능을 수행하기위한 값 = argument (인자),parameter (파라미터)
<br>
<br>
<strong>변수와 값 할당</strong>
<br>
<br>
변수 선언 (variables)
<br>
갑을 저장할 메모리를 확보하는 명령문<br>
-> var,let,const
<br>
<br>
할당,대입 (assignment)
<br>
메모리에 값을 저장
<br>
-변수명 = 값; <br>
-변수명 = 변수명;<br>
-변수명 = 함수; <br>
= 을 assignment operator
<br>
변수=(변수 ,값,함수...) <br>
변수 (l-value) = 반드시 메모리여야한다 <br>
(변수 ,값,함수...) (r=value) 
<br>
<br>
<strong>for 반복문</strong>
<br>
<br>
<pre>
for (var i = 0; i < size; i++) {
  console.log(i, message);
  if (i == 5) {
    var working = true;
    break;
  }
</pre>
<br>
<br>
var i = 반복문을 실행하는 동안 사용하는 변수 주로 반복문에서 횟수를 제어하기위해 사용 <br>
i < size  = 반복문 횟수 지정 <br>
i++  =  값을 1씩 증가 <br>
<br>
<br>
<strong>function(함수)</strong>
<br>
특정 기능을 수행하도록 짜놓은 명령순을 묶어서 이름을 붙인것 필요할때 재실행 가능<br>
코드 재사용성을 높이는 문법
<br>
<br>
<pre>
function plus(a, b) {        <- 함수 정의 (definition)
  return a + b;
}

plus = 함수 이름
(a, b) = parameter             
a + b; = 실행 완료후 리턴 값

var sum = plus(100,200);       <- 함수사용법 호출 (call)


console.log(plus(10, 20)); 

ok = plus;
console.log(ok(100, 200));

var haha = ok;
console.log(haha(1000, 2000));

ok = "Hello";
ok(100, 200);

    
</pre>
<br>
<br>
<strong>함수레퍼런스</strong>
<br>
함수의 이름은 함수의 주소를 보관하고 있는 변수이다 
<br>
<strong>static type dinfing vs dynamic type dinfing</strong>
<br>
<pre>
dynamic type dinfing (짧은 코드 작은프로젝트) 
값을 넣을때 변수의 유형이 바뀐다 하지만 script 류의 프로그래밍 언어
자유분방하고 프로그래밍이 쉬워 유지보수가 어렵다 

javascript

var a;

a= 100;
a= "hello";
a= true;

static type dinfing (긴코드 큰 프로젝트)
언어 류의 프로그램 언어이고 엄격해 프로그래밍이 까다롭지만 유지보수가 쉽다

int a;

a= 10;
a= 20;
a= "hello"  (X)

인트로 지정해 문자는 불가능
</pre>

<br>
<br>
<pre>
객체 : 덩어리 (변수+함수+객체)

// 1) Object라는 원형 틀을 기반으로 기본 객체를 생성한다.
var obj1 = new Object(); // => HashMap<String,Object> obj1 = new HashMap<>();

// 기본 객체에 프로퍼티를 덧붙인다.
obj1.name = "홍길동"; // => obj1.put("name", "홍길동");
obj1.age = 20; // => obj1.put("age", 20);
obj1.working = true; // => obj1.put("working", true);
obj1.hello = function() {
  console.log("안녕하세요, " + this.name + "님!");
}; // => obj1.put("hello", 함수);

----------------------------------------------------------------
객체를 자바스크립트로 코드화한 것 (object literal)


var obj2 = {
  name:"임꺽정",
  age:30,
  working:true,
  hello:function() {
    console.log("안녕하세요, " + this.name + "님!")
  },
  hello2() {
    console.log("안녕하세요, " + this.name + "님2!")
  }
};
</pre>
<br>
<br>
literal (값을 코드로 표현한것)<br>
<br>
<br>
문자열 -> "abc"
<br>
숫자 -> 10
<br>
논리 -> true,false
<br>
변수의 값이 저장된 적이 없는 상태 -> undefined
<br>
객체 주소가 없는 상태 -> null
<br>
<br>
<strong>DOM API - getElementById()</strong>
<br>
태그를 다루는 프로그램을 짤 때 사용하는 도구
<br>
document <- HTML
<br>
boject <- 객체
<br>
model <- 구조로 만든것
<br>
<br>
DOMM
<br>
tag를 tree구조로 객체화 시킨것 tag를 찾고, 변경하고,추적,삭제하기 쉽도록 한것
<br>
<br>
API
<br>
application<br>
programming<br> 
intorface<br>
app을 프로그래밍 할때 사용하는 도구
<br>
<br>
<strong>객체와 함수(메서드=operator) , 파라미터의 관계</strong>
<br>
<br>
<pre>
document.getElementById("태그 아이디")
 ㄴ객체       ㄴ함수(일하는놈)    ㄴ함수가 기본데이터를 다룰때 사용할 값


예)

학생명단.find("홍길동")

학생명단 = 기본데이터
find = 작업 = 작업자 (operator)
홍길동 = 부가데이터
</pre>
<br>
ECMA스크립트란, Ecma International이 ECMA-262 기술 규격에 따라 정의하고 있는 표준화된<br>
스크립트 프로그래밍 언어를 말한다. 자바스크립트를 표준화하기 위해 만들어졌다. 액션스<br>
크립트와 J스크립트 등 다른 구현체도 포함하고 있다
<br>
ECMA스크립트는 ECMA-262에 의해 표준화된 언어의 이름이다.<br>
자바스크립트와 J스크립트는 모두 ECMA스크립트와의 호환을 목표로 하면서, ECMA 규격에<br>
포함되지 않는 확장 기능을 제공한다.
<br>
<strong>태그 찾기 -> 이벤트리스너 등록</strong>
<pre>
var tag1 = document.getElementById("btn1")

tag1.onclick = function() { // Observer 패턴: 리스너 => 이벤트 리스너 => 이벤트 핸들러 
=> 콜백함수(callback; cb)

  var tag2 = document.getElementById("p1");
  tag2.innerHTML = "비트캠프!";
};
사용자가 tag1을 클릭(onclick) 이라고 저장된 함수를 호출
innerHTML은 해당 함수에 등록된 태그의 내용을 바꿔준다
</pre>
<br>
<br>
<strong>요점 정리 - 5.HTML 태그와 DOM 트리 객체 응용</strong>
<pre>

  var inputNameIndex = 1;
  var btnAddName = document.getElementById("btnAddName");
  var inputNameContainer = document.querySelector("#inputNameContainer");
  var inputNameDiv = document.querySelector(".inputName");

  btnAddName.onclick = function() {
  inputNameIndex++;
  var e = inputNameDiv.cloneNode(ture);
  e.querySelector(".name").innerHTML = "이름" + inputNameIndex;
  e.querySelector("input").name = "name" + inputNameIndex;
  e.querySelector("input").value = "";
  inputNameContainer.appendChild(e);

</pre>
<br>
<br>
<strong>웹페이지 조립</strong>
<br>
<br>
서버에 자원을 요청
<br>
1. server-side rendering <br>
서버에서 HTML을 만들어준다(JSP,thymleaf) 
<br>
<br>
2. client-side rendering <br>
클라이언트에서 HTML을 만든다(reect,)
<br>
<br>
<strong>JSON 포맷</strong>
<br>
<pre>
var obj = {
  "name": "홍길동",
  "age": 20,
  "working": false,
};
</pre>
<br>
javascript의 object literal 을 참조해 만듬
<br>
<br>
과제 : 틱택토 만들기 12-04일 저녁 10시까지
<br>
<hr>
<br>
<h1>2022-12-05</h1>
<br>
<pre>
ohora>헐.../ohora>


script type="text/plain">
  // script의 type 속성이 "text/javascript"로 설정되어 있지 않으면
  // 웹브라우저는 이 태그의 값을 무시한다.
  // => 화면에 출력하지는 않으면서 특정 목적으로 이용할 때 종종 이런 방식을 사용한다.
  // 예) Handlebars 라이브러리
  console.log("Hello, world!");
  // type 속성의 값으로 보통 MIME 타입을 지정한다.
  // MIME(Multi-purpose Internet Mail Extensions) 타입
  // => 이메일의 콘텐트 타입을 지정하는 용도로 등장하였다.
  // => 현재는 이메일 뿐만아니라 웹 콘텐트의 타입을 지정할 때도 사용된다.
  // => 대중적으로 널리 알려진 포맷에 대해서는 MIME 타입의 이름이 결정되어 있다.
  /script>
</pre>
<br>
<br>
// 웹브라우저는 HTML을 로딩한 후 위에서 아래로 태그가 나온 순서대로 실행한다.<br>
// 실행하다가 script라는 태그를 만나면 "자바스트립트 엔진"을 이용하여 코드를 실행한다. <br>
// script 태그 실행이 완료되면 계속 이어서 다음 태그를 처리한다.
<br>
<br>
<strong>객체와 함수</strong>
<br>
<br>
document.getElementById("btnl") 
<br>
document<br>
객체,함수가 작업할 때 사용하는 기본 데이터
<br>
getElementById<br>
함수,작업을 수행(operator=function=method)
<br>
("btnl")<br>
파라미터,작업을 제어하는 데이터 (parametor=argument)
<br>
<br>
window.alert("hello, world");
<br>
<br>
window<br>
객체, 도구함
<br>
alert<br>
함수, 도구
<br>
("hello, world")<br>
파라미터, 기능 수행에 필요한 데이터
<br>
<br>
<strong>*코드 실행 순서</strong>
<br>
<br>
<strong>인터프리트 방식과 커파일 방식</strong>
<br>
<br>
인터프리터 <br>
명령문을 한줄씩 읽어 인터프리터에서 실행한다 만약 명령문이 잘못작성되었어도 실행<br>
하기전까지 알 수 없다 
<br>
<br>
컴파일 <br>
명령문 전부를 컴파일러가 컴파일하여 기계어로 번역한다 만약 명령문이 잘못되었으면 컴파 <br>
일 과정에서 모두 걸러진다 따라서 문법오류는 없는 상태이다
<br>
<br>
// script 태그 안에 있는 자바스크립트를 실행하는 중에 오류가 발생하면 <br>
// 즉시 script 태그의 실행을 중단하고 다음 태그로 간다. <br>
<br>
<br>
<pre>
예전에는 script 태그를 head 태그 안에 두었다.
그 시절에는 실행할 자바스크립트 코드의 양이 많지 않았기 때문에
HTML 본문을 출력하기 전에 자바스크립트를 두어도 괜찮았다.
그러나 최근에는 사용자의 다양한 행위와 동적인 화면을 지원하기 위해
자바스크립트 코드의 양이 굉장히 많아 졌다.
그래서 head 태그에 있는 자바스크립트를 실행하는 동안
body 태그의 내용은 화면에 출력할 수 없기 때문에
화면 출력이 느려지게 되었다.
이런 이유로 사용자가 지루해 하지 않도록 하기 위해
일단 화면의 일부를 출력한 후 자바스크립트를 실행하도록
script 태그를 body의 맨 끝에 두는 게 요즘 경향이다.

예전에는 스크립트 태그를 head안에 넣엇지만 점점 코드의 양이 많아지면서
body 맨끝에 두는게 요즘 트렌드이다 
</pre>
<br>
<br>
<strong>Promise</strong>
Asynchronous (비동기) <br>
자바스크립트의 비동기 처리란 특정 코드의 연산이 끝날 때까지 코드의 실행을 멈추지 않고 <br>
다음 코드를 먼저 실행하는 자바스크립트의 특성을 의미한다 만약 처리해야할 코드가 많은데 <br>
연산이 끝날 때 까지 기다릴 수는 없기 때문에 나머지 코드부터 먼져 실행한다 <br>
<br>
-script태그는 바디 맨 끝에 두는게 좋다 
<br>
<br>
<pre>
  const express = require('express')
const app = express()
const port = 3000

app.get('/exam05_1', async (req, res) => {
  await new Promise(resolve => setTimeout(resolve, 10000));
  express.send('console.log("exam05_1 ok!");')
})

// 위에서 같이 사용하려면 async라고 지정을 해주고 awsit을 사용해야한다
이 코드가 동일하게 실행하지 않는다는 것을 알려줘야 한다 

app.get('/exam05_2', (req, res) => {
  res.send('consloe.log("exam05_2 ok!");')
})

app.get('/exam05_x', async (req, res) => {
  await new Promise(resolve => setTimeout(resolve, 10000));
  res.send('var rate = 30000;')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})
</pre>
<br>
<br>
자바스크립트의 변수는 "동적 타입 바인딩(dynamic type binding)"이다<br>
변수를 넣으면 그 변수에 맞게 타입이 적용된다
<br>
<br>
script 태그를 실행할 때 변수나 함수가 선언된 위치에 상관없이 선언 문을 먼저 실행한다<br>
// 그래서 변수 선언이나 함수 선언을 끌어 올린다는 의미로 "hoisting"이라는 표현을 쓴다. <br>
hoisting은 현재 태그에 선언된 변수나 함수에 대해서만 수행한다.
<br>
<br>
<strong>var 변수와 블럭</strong>
<br>
<br>
1.global 변수<br>
-window 객체 소속
<br>
2. 함수 변수<br> 
-함수를 실행하는 동안 생성<br>
-함수 내에서만 실행
<br>
<br>
<strong>let 변수 와 블록</strong>
<br> 
<br>
let <br>
블록 영역에 종속 : 블록에 진입 할때 생성 , 블록을 나가면 삭제 
<br> 
<br>
const 
<br>
initializer <br>
-변수 선언과 동시에 값을 할당해야 한다  
<br>
<br>
var v2 = 100; // f1() 함수에서만 사용되는 로컬 변수이다.
<br>
스택 메모리에서 관리하기 때문이다
<br>
->메모리의 스택(stack) 영역은 함수의 호출과 관계되는 <br>
지역 변수와 매개 변수가 저장되는 영역이다
<br>
<br>
함수 안에서 같은 이름에 글로벌 변수를 사용하고 싶다면 window.을 붙이면 로컬에서도 <br>
글로벌 변수를 사용할 수 있다
<br>
<br>
<strong>여러개의 변수를 손쉽게 만드는 문법(배열) 만들기</strong>
<pre>
// 배열 만들기
// 1) new => 빈 객체를 만든다.
// 2) Array() 호출
//    => Object() 호출
//        => 객체에 필요한 최소한의 변수나 함수를 추가한다.
//        Array()를 호출했는데 Object()가 호출되는 이유:
//        => 자바의 상속처럼 Array() 생성자는 Object() 생성자를 상속받기 때문이다.
//        => 그래서 Array()를 호출할 때 상위 생성자인 Object()가 먼저 호출되는 것이다.
//    => 배열 관리에 필요한 변수나 함수를 기본 객체에 추가한다.
var arr = new Array(); // 빈 객체 생성 => Object()로 기본 변수와 함수를 준비 => Array()를 실행하여 배열에 필요한 변수나 함수를 추가

1. new -> 빈 객체 생성
2. Array -> 배열관리에 필요한 변수,함수 추가
3. arr.push() -> 배열의 값 추가 -> length 도 증가 
</pre>
<br>
<br>
<strong>인덱스 0 과 메모리 주소</strong>
<br>
<br>
<pre>
arr 의  217 = 217+0 = [0]
        218 = 217+1 = [1]
        .
        .
</pre>
<br>
메로리 시작 주소를 가지고 배열의 항목을 가리키기 때문에 <br>
인덱스 0 부터 시작한다 
<br>
<br>
<strong>변수 - 배열을 만드는 단축 문법</strong> 
<br>
<br>
var arr = ["aaa", "bbb", true, 100, new Object(), function() {}];
<br>
배열을 대괄호로 묶어준다, 자바스크립트는 타입상관없이 배열을 구성할 수 있다
<br>
<br>
<strong>##틱택토 게임 구현방법을 ppt로 5분안에 설명하시오.</strong>
<br>
<br>
변수 사용
<br>
1.const -> 2.let -> 3.var 순서로 사용 <br>
const로 지정한 값을 바꾸고 싶다면 let을 사용하여 바꾸고 변수들 끼리 공유를 하고싶다면 <br>
var를 사용하여 순서대로 이용하여야 한다
<br>
<hr>
<br>
<h1>2022-12-06</h1>
<br>
<br>
<strong>문법</strong>
literal<br>
값을 표현하는 문법 <br>
예) "aaa", 'aaa', 10 ,3.14 , true,false 등
<br>
variables<br>
값을 저장하는 메모리를 준비하는 문법<br>
예)var/let/const/[]
<br>
제어문
<br>
1. 분기문<br>
-if~else<br>
-switch
<br>
2. 반복문<br>
-whrle<br>
-for
<br>

<br>
<br>
<strong>연산자 - 산술연산자</strong>
<br>
<br>
y = 100
<br>
y<br>
100<br>
1.r-value 를 모두 수행<br>
2. = 연산수행
<br>
++,-- 연산자는 *,/,% 보다 우선한다
<br>
<br>
console.log("100" == 100); //==연산전에 숫자 100을 형변환후 비교 <br>
console.log("100" === 100);//=== 두 피연산자가 같은 타입이고 값이 같을 때 true이다
<br>
<br>
<pre>
console.log("100" == 100); //==연산전에 숫자 100을 형변환후 비교
console.log("100" === 100);//=== 두 피연산자가 같은 타입이고 값이 같을 때 true이다
console.log("100" != 100) //false 두 피연산자를 비교하기전에 100을 "100" 으로 형변환후 비교한다
console.log("100" !== 100)// 두 피연산자의 데이터 타입이 다르기 때문에 값을 비교할 필요가 없이 다르다

console.log("--------------------------");

console.log(100 < 200);
console.log(100 <= 200);
console.log(100 > 200);
console.log(100 >= 200);
console.log("---------------------------");

//문자열을 비교할떄 문자 코드 값을 비교한다

console.log("AB" > "AC");    false
console.log("a" > "A");      true 
console.log("똘" < "똠");    true
console.log("---------------------------");
</pre>
<br>
<br>
<strong>리터럴(literal) - 숫자 진수 표현법</strong>
<br>
<br>
<strong>연산자 - 비트연산자</strong>
<br>
<br>
<pre>
// AND: 두 비트가 1일 때 1, 그외 0
// -두 비트가 1 일 때 1, 그 외 0
// -1 로 설정한 비트의 값은 그대로 통과하는 효과가 있다.
// - 특정비트의 값만 추출 할 때 활용한다

console.log((a & b).toString(2)); // 1100000


console.log("-----------------------------");

// 응용 1
// - 색상 값에서 빨강 색을 제거하기
// - 예) 사진에서 빨강색 제거 
let color = 0xFF00FF; // 보라색
console.log((color & 0x00FFFF).toString(16));// 0000FF

//OR 비트 연산자 
// - 두 비트 중에 한 개라도 1이면 결과는 1, 그 외 0
// -AND 비트 연산자와 반대로 동작
// - 0 비트는 그대로 통과, 1비트는 기존 값 제거
console.log((a | b).toString)


// 응용 
// -특정 색상을 강화하기 
// -예) 빨강색 강화하기
color = 0x283386;
console.log(color.toString(2));
console.log((color | 0x550000)); // 빨강색 강화 : 01010101
//기존 빨강색 : 00101000
//강화 : 01010101
//--------------
//변경된 색상 : 01111101
console.log("-----------------------------");


// XOR(exclusive OR) 비트 연산자
// - 두 비트의 값이 다를 때 1, 같으면 0
console.log((a ^ b).toString(2));
// a: 01100100
// b: 11110000
// ----------
// 10010100
console.log("-----------------------------");


// NOT 비트연산자
console.log((~a).toString(2));
// a : 01100100
//------------------
// ~ : 10011011
console.log("-----------------------------");


// << 비트 이동 연산자
// -왼쪽으로 지정한 비트만큼 이동시킨다
// -오른쪽의 빈자리는 0으로 채운다
// -1 비ㅡㅌ 이동할 때마다 2*한 효과가 있다
// -* 2 연산을 수행하는 것 보다 비트이동 연산자가 실행속도가 빠르다
// - n 비트 이동 = 값 * 2**n
a = 7; // 0000111
console.log((a * 2).toString(2)); //  (14)
console.log((a >> 2).toString(2));// 1110 (14)
console.log((a * 4).toString(2)); //  (28)
console.log((a << 2).toString(2));// 1110 (28)
console.log((a * 8).toString(2)); //  (56)
console.log((a << 3).toString(2));// 111000 (56)
console.log("-----------------------------------");


// >> 비트 이동 연산자
// -오른쪽으로 지정한 비트만큼 이동시킨다
// -왼쪽의 빈자리는 부호비트(양수:0,음수는:1)로 채운다
// -1 비트 이동할 때마다 /2한 효과가 있다
// - / 2 연산을 수행하는 것 보다 비트이동 연산자가 실행속도가 빠르다
// - n 비트 이동 = 값 / 2**n
a = 100; // 01100100
console.log((a / 2).toString(2)); // 50
console.log((a >> 2).toString(2));// 0110010|0 (50)
console.log((a / 4).toString(2)); // 25
console.log((a >> 2).toString(2));// 011001|00 (25)
console.log((a / 8).toString(2)); // 12.5
console.log((a >> 3).toString(2));// 01100|100 (12)
// 50 : 0011 0010
// -50: 1100 1110
a = -100;   // 
console.log(a >> 1);  // -100
console.log((a >> 1).toString(2)); // -50 
console.log("-----------------------------------");


// >> 비트 이동 연산자
// -오른쪽으로 지정한 비트만큼 이동시킨다
// -왼쪽의 빈자리는 0으로 채운다. 음수를 비트이동하면 양수로 바뀐다
// -양수인 경우 1 비트 이동할때마다 /2한 효과가 있다
// -양수인 경우, n 비트 이동 = 값 /2**n
a = 100;
console.log(a >>> 1);
console.log((a >>> 1).toString(2));

a = -100;              // 
console.log(a >>> 1);  // 2147483598
console.log((a >>> 1).toString(2)); 

</pre>
<br>
<br>
<strong>이미지와 바이트 수</strong>
<br>
<br>
1. 흑백 사진 각 비트값 -> 0: 검은색 ,1: 흰색<br>
-> 1픽셀 = 1bit
<br>
<br>
2. 칼라사진 1픽셀크기: RGB 3byte<br>
-> 9픽셀크기 = 27byte
<br>
<br>
3. HD급 = 2,073,600픽셀 = 6,220,800byte<br>
천만화소 를 관리하기 쉽게 압축 <br>
-손실압축 (JPEG)<br>
-비손실압축 (GIF)<br>
압축 해제시 -> 비트맵 -> 출력가능
<br>
<br>
<strong>프로그래밍 트렌드</strong>
<br>
<br>
1. 절차적 프로그래밍 (기능들의 덩어리를 그룹화 하는것)<br>
예)basic,
<br>
<br>
2. function<br>
예)c,code,<br>
명령어를 기능단위로 묶는다<br>
-관리용이<br>
-재사용<br>
-가독성
<br>
<br>
3. class<br>
예)c++,java<br>
클레스로 묶어 코드 덩어리로 만든다<br>
-기능이 많아지고 함수가 많아진다 함수를 역할단위로 묶는다<br>
-관리용이<br>
-재사용<br>
-가독성
<br>
<br>
4. package<br>
클레스가 계속 많아져서 그룹으로 묶음
<br>
<br>
5.module<br>
페키지를 묶은것
<br>
<br>
<strong>Data() 생성자</strong>
<br>
<br>
1. new <br>
2. object <br>
3. data()<br>
=> 객체 생성
<br>
new HTMLButtonElement()
<br>
instanceof<br>
객체를 초기화 시키는지 확인한다
<br>
<hr>
<br>
<h1>2022-12-07</h1>
<br>
<br> 
<strong>반복문 for</strong>
<br>
<br>
<pre>
for (변수선언및초기화; 조건 ;변수값증감) {
  ...
}

배열
const arr = new Array();
</pre>
<br>
Array <br>
빈객체에 용도따라서 필요한 변수와 함수들을 채워넣는 아주 특별한 함수 "생성자(constructor)"<br>
객체가 자신의역할을 제대로 수행할 수 있도록 필요한 값과 함수를 준비하는 일을 한다
<br>
<br>
<strong>배열과 destructuring</strong>
<br>
destructuring 문법을 사용하여 key와 value를 분해하여 받는다.
<br>
<br>
<pre>
let a = ["name", "홍길동"];

let key = a[0];
let value = a[1];
//
key = name
value = 홍길동
->
let [key, value] = ["name", "홍길동"]
</pre>
<br>
<br>
<strong>구조 분해(destructuring) - 배열</strong>
<br>
<br>
<pre>
  // 값을 분해하여 여러 변수에 받을 수 있다.
  //
  var arr = ["홍길동", "1111-2222", true, 20];
  console.log(arr);
  
  // 보통 한 개의 변수에 한 개의 값을 받는다.
  var n = arr[0];
  var t = arr[1];
  var w = arr[2];
  var a = arr[3];
  console.log(n, t, w, a);
  console.log("----------------");
  
  // 배열의 값을 분해해서 받을 수 있다.
  var [name, tel, working, age] = arr;
  console.log(name, tel, working, age);
  console.log("----------------");
  
  // 배열 개수 보다 적은 변수를 선언하면 그 변수 개수만큼만 분해해서 받는다.
  var [name2, tel2] = arr;
  console.log(name2, tel2);
  
</pre>
<br>
<br>
<strong>구조 분해(destructuring) - 객체</strong>
<br>
<br>
<pre>
  var obj = new Object();
obj.name = "홍길동";
obj.age = 20;
obj.tel = "1111-1111";
obj.working = true;

// 객체에서 값을 여러 변수에 분리하여 담을 때는 
// 객체의 프로퍼티 이름과 같은 이름으로 변수를 선언한다.
// => 분해 변수의 이름과 일치하는 프로퍼티 값을 넣어준다.
var {tel, name, age, gender} = obj;
console.log(name);
console.log(age);
console.log(tel);
console.log(gender); // 객체에 지정된 이름의 프로퍼티가 없다면 undefined 이다.

</pre>
<br>
<br>
<strong>구조 분해(destructuring) - 객체 II</strong>
<pre>
  var obj = new Object();
  obj.name = "홍길동";
  obj.age = 20;
  obj.tel = "1111-1111";
  obj.working = true;
  
  // 객체에서 특정 프로퍼티 값을 분리하여 받은 후에
  // 나머지 값을 별도의 객체에 담아서 받고 싶다면
  // {변수1, 변수2, ...나머지값받을변수}
  var {age, tel, ...other} = obj;
  console.log(age);
  console.log(tel);
  console.log(other);
  console.log(other.name);
  console.log(other.working);
</pre>
<br>
<br>
<strong>구조 분해(destructuring) - 함수 리턴 값</strong>
<br>
<br>
<pre>

function f1() {
  return ["홍길동", 100, 90, 80, 270, 90];
}

var r1 = f1();
console.log(r1);
console.log(r1[0], r1[1], r1[2], r1[3]);



// 함수의 리턴 값이 배열이기 때문에
// 배열을 값을 destructuring 하는 문법은 같다.
var [name, kor, eng, math] = f1();
console.log(name, kor, eng, math);
console.log("-----------------------");

// 배열의 중간 값을 건너 뛰고 변수에 받을 수 있다.
var [name,,,,sum,aver] = f1();
console.log(name, sum, aver);
</pre>
<br>
<br>
<strong>구조 분해(destructuring) - 함수 리턴 값 II</strong>
<br>
<br>
<pre>
  function f2() {
    var obj = new Object(); 
    obj.name = "홍길동"; 
    obj.age = 20;
    obj.tel = "1111-1111";
    obj.working = true;
    return obj;
  } 
  
  // 보통 다음과 같이 함수가 리턴한 객체를 통째로 받는다.
  // 실제 객체 주소를 받는다.
  var r2 = f2();
  console.log(r2);
  console.log("------------------------");
  
  // 리턴 받은 객체에서 값을 꺼낼 때 
  // 프로퍼티와 일치하는 이름의 변수를 선언하면 된다.
  var {tel, age} = f2();
  console.log(tel, age);
</pre>
<br>
<br>
<strong>변수 -const</strong>
<br>
<br>
<pre>
// var 로 선언한 변수는 값을 변경할 수 있다.
var v1 = 100;
v1 = 200;
console.log(v1);

// const로 선언한 변수는 값을 변경할 수 없다.
const v2 = 100;
//v2 = 200; // 예외 발생!
console.log(v2);

// const 변수는 선언할 때 값을 할당해야 한다.
// const v3; // 예외 발생!
// v3 = 100;
// console.log(v3);
console.log("---------------------------");

const v4 = "오호라";
console.log(v4);
console.log(window.v4); // const 변수는 window 객체에 보관되지 않는다.
</pre>
<br>
<br>
<strong>변수 - const 객체</strong>
<br>
<br>
<pre>
  var v1 = new Object();
  v1.name = "홍길동";
  v1.age = 20;
  v1.tel = "1111-2222";
  console.log(v1);
  
  v1 = new Object();
  console.log(v1);
  
  // const 변수에 객체를 할당한다면,
  // => 실제로 객체의 주소가 할당되는 것이다.
  // 변수를 다른 객체의 주소로 변경할 수 없지만,
  // => 그 변수가 가리키는 객체에 대해서는 변경할 수 있다.
  // 즉 const 로 선언한 변수는 변수의 값만 못 바꾼다는 것이다.
  const v2 = new Object();
  v2.name = "홍길동";
  v2.age = 20;
  v2.tel = "1111-2222";
  console.log(v2);
  
  // const 변수의 값은 변경할 수 없다.
  v2 = new Object(); // 예외 발생!
  
  // 그러나 const 변수가 가리키는 객체의 프로퍼티는 바꿀 수 있다.
  v2.name = "임꺽정";
  v2.working = true;
  console.log(v2);  
</pre>
<br>
<br>
<strong>변수 - let</strong>
<br>
<br>
<pre>
  var v1 = "홍길동";
  {
    var v1 = "임꺽정"; // 기존 변수의 값을 변경한다.
    var v2 = 20; // 새 글로벌 변수를 추가한다.
  }
  console.log(v1, v2);
  console.log("--------------------");
  
  var v3 = "홍길동";
  {
    // let으로 선언한 변수는 사용 범위가 블록으로 한정(block-scoped)된다.
    let v3 = "임꺽정"; // 새 로컬 변수이다. 글로벌 변수가 아니다.
    let v4 = 30; // 새 로컬 변수이다. 글로벌 변수가 아니다.
    console.log(v3, v4);
    
  }
  console.log(v3); // OK
  //console.log(v4); // let으로 선언한 변수는 그 블록을 벗어나면 사용할 수 없다.
  console.log("--------------------");
  
  let v4 = "오호라";
  
  console.log(v4); 
  console.log(window.v4); // let 으로 선언한 변수는 window 객체에 보관되지 않는다.
</pre>
<br>
<br>
<strong>변수 - let II</strong>
<br>
<br>
<pre>
  // if, for 등의 블록에서 var로 선언한 변수는 글로벌 변수이다.
  for (var i = 0; i < 5; i++) {
    console.log(i);
  }
  console.log("==>", i);
  console.log("==>", window.i);
  
  console.log("--------------------")
  
  for (let x = 0; x < 5; x++) {
    console.log(x);
  }
  // for 블록 안에서 let으로 선언한 변수는
  // for 블록을 벗어나면 자동으로 제거되기 때문에 사용할 수 없다.
  console.log("==>", x);
</pre>
<br>
<hr>
<br>
<h1>2022-12-08</h1>
<br>
<br>
<strong>function</strong>
<br>
<br>
<pre>
function 함수명 (파라미터, . . . ) {
   ㄴ> 
  명령문;
  return 표현식(expresstion: 값을 리턴하는 문장);
  // 리터럴: "aaa", 20 ,true...
     변수 : a,score,sum...
     식 : a+"hello", a*2...
}

함수호출(함수 실행시키는 명령)
함수명(값,값,...)
값 = 아규먼트(argument)

function f4(a, b) { // 파라미터도 있고, 리턴 값도 있는 함수
	return a + b;
}

console.log(f4(10, 20));
console.log("----------------");
// 10 + 20 =30
</pre>
<br>
<br>
<strong>아규먼트와 파라미터</strong>
<br>
<br>
<strong>함수 - 함수 아규먼트와 함수 내장 변수 arguments</strong>
<br>
<br>
<pre>
// 자바스크립트의 함수는 함수를 호출할 때 전달한 값들을 보관하는 배열과 유사한 변수를 내장하고 있다.
// => 그 내장 변수의 이름은 "arguments" 이다.

function f1(a) {
	console.log("a =", a);
	console.log(arguments); // arguments 에는 넘어 오는 모든 값이 저장되어 있다.
}

f1();
console.log("----------------");

f1(100);
console.log("----------------");

f1(100, 200, 300, 400);
console.log("----------------");

function f2(a) {
	for (var i = 0; i < arguments.length; i++) {
		console.log(arguments[i]);
	}
}
f2(100, 200, 300, 400);
console.log("----------------");

function f3(a) {
  for (var value of arguments) {
    console.log(value);
  }
}

f3(100, 200, 300, 400);
console.log("----------------");

function f4(a) {
  for (var i in arguments) {
    console.log(arguments[i]);
  }
}

f4(100, 200, 300, 400);
console.log("----------------");
</pre>
<br>
<br>
<strong>함수 - 함수와 window 객체</strong>
<br>
<br>
<pre>
  // 함수도 var 변수와 같이 자동으로 window 객체에 소속된다.
  function f1(str) { 
    console.log(str);
  }
  
  window.f1("안녕1");
  f1("안녕2"); // window. 을 생략할 수 있다.
  
  // 함수나 변수나 객체 입장에서는 그냥 프로퍼티이다.
  // 따라서 프로퍼티 값을 가리키는 다음 문법을 그대로 사용할 수 있다.
  // => 객체["프로퍼티명"]
  // => 객체['프로퍼티명']
  // 
  window["f1"]("안녕3"); // f1 이름으로 저장된 함수 주소를 가져와서 호출한다.
  
  // 함수의 주소를 값처럼 다룰 수 있다.
  // 즉 다른 변수에 저장하여 사용할 수 있다.
  var ohora = window.f1; 
  ohora("안녕4"); // 함수 주소를 갖고 있는 변수는 함수처럼 사용할 수 있다.
</pre>
<br>
<br>
<strong>함수 - 함수와 레퍼런스</strong>
<br>
<br>
<pre>
function f1() {---}
f1 ()
f2 = f1;

두 함수는 주소가같고 함수도 객체이기 때문에 객체처럼 사용가능

</pre>
<br>
<br>
<strong>함수 - 익명 함수</strong>
<br>
<br>
<pre>
  // 예) a 변수에 문자열을 저장하면 문자열을 다루는 함수를 사용할 수 있다.

  let a = "가나다";
  console.log(a.indexOf("나"));
  
  // 예) a 변수에 배열을 저장하면 배열을 다루는 함수를 사용할 수 있다
  a = ["100", "200", "300", "400", "500"];
  let a2 = a.slice(1, 3);
  console.log(a2);
  
  
  // 즉 변수에 어떤 타입의 값을 저장하느냐에 따라
  // 그변수에 묶이는 함수가 달라짐
  // 이걸 다이나믹 함수라고한다

</pre>
<br>
<br>
<strong>함수 -  함수 호이스팅(hoisting)</strong>
<br>
<br>
<pre>
  script>
    // 함수도 변수처럼 함수 정의를 맨 먼저 실행한다.
    // => 즉 script 태그를 실행할 때 함수 정의가 있으면 제일 먼저 실행한다.
    // => 이렇게 함수를 정의한 코드를 맨 위로 끌어올린다 하여 "함수 호이스팅(hoisting)"이라 한다.
    //
    
    // 함수를 정의하기 전에 사용한다.
    // 그런데도 오류가 발생하지 않는 이유는 함수 정의가 먼저 실행되기 때문이다.
    f1();
    
    function f1() {
      console.log("안녕!");
    }
    
    /script>
    
    script>
    // 이전 스크립트 태그에서 정의한 함수나 변수가 window 객체에 보관되는 글로벌 함수나 변수라면,
    // 그 이후의 스크립트 태그 안에서 그대로 사용할 수 있다.
    f1();
    
    f2(); // 실행오류!
    // 현재 스크립트 태그가 아닌 다음 스크립트 태그에서 정의한 함수는
    // 호이스팅 대상이 아니다.
    // 호이스팅은 그 script 태그를 실행할 때 수행된다.
    // 따라서 아래에 f2() 함수는 아직 정의된 상태가 아니기 때문에 호출할 수 없다.
    /script>

</pre>
<br>
<br>
<strong>함수 -함수 호이스팅(hoisting)과 익명 함수</strong>
<br>
<br>
<pre>
  // 변수 선언과 그 변수의 값을 초기화시키는 할당문이 함께 있을 경우
  // 호이스팅 대상은 변수 선언만이 그 대상이 된다.
  //
  console.log(v1); // 아래에 선언된 v1 변수가 호이스팅 되기 때문에 사용할 수는 있다.
  
  var v1 = "홍길동"; // 변수 선언은 호이스팅 규칙에 따라 먼저 실행된다.
                   // 그러나 값을 할당하는 = 연산자는 현재 위치에 도달할 때 실행된다.
  console.log(v1);
  
  // 위의 규칙을 그대로 적용하여 다음을 이해해 보라!
  f1(); // 실행 오류! 
  
  var f1 = function() { // 위의 경우와 마찬가지로 현재 위치에 도달했을 때 익명 함수가 정의되어 그 주소가 f1에 저장된다.
      console.log("안녕!");
  };
  
  f1(); //OK! 현재 f1 변수에는 익명 함수의 주소가 들어 있다.

</pre>
<br>
<br>
<strong>함수 -아규먼트로 함수를 전달하기</strong>
<br>
<br>
<pre>
  // 함수는 객체이기 때문에 주소를 주고 받을 수 있다.
  // 
  
  // 함수 객체를 아규먼트로 넘길 때 
  // 보통 파라미터 이름을 fn 또는 cb(callback)로 한다.
  // "콜백(callback) 함수"
  // => 직접 호출하는 것이 아니라 다른 함수에게 파라미터 값으로 전달하여 
  //    호출되도록 만드는 함수.
  // 
  function play(cb) {
      console.log("계산 결과 =", cb(100, 200));  // 콜백 함수
  }
  
  function plus(a, b) {return a + b;}
  function minus(a, b) {return a - b;}
  
  play(plus); // 호출될 함수를 파라미터로 넘긴다. 그러면 play()가 호출해 줄 것이다.
  play(minus);
  
  // 생각해 볼 문제?
  // 다음은 콜백 메서드인가? 아닌가?
  function play2(v1, v2, op) {
    if (op == "+") {
      console.log(plus(v1, v2)); // 파라미터로 받은 함수를 호출하는 것이 아니기 때문에 콜백 함수가 아니다.
    } else if (op == "-") {
      console.log(minus(v1, v2)); // 파라미터로 받은 함수를 호출하는 것이 아니기 때문에 콜백 함수가 아니다.
    } else {
      console.log("해당 연산을 지원하지 않습니다.");
    }
  }
  
  play2(100, 200, "+");
  play2(100, 200, "-");
  
</pre>
<br>
<br>
<strong>함수 - 함수 리턴하기</strong>
<br>
<br>
<pre>
  // 함수는 객체이기 때문에 주소를 주고 받을 수 있다.
  //
  
  // 함수 안에서 함수를 만들어 리턴할 수 있다.
  function createInterestCalculator(type) {
      switch (type) {
      case "보통예금":
        return function(money, month) {return money + (money * 0.0011 * month);};
      case "정기예금":
        return function(money, month) {return money + (money * 0.0014 * month);};
      default:
        return function(money, month) {return money;};
      }
  }
  
  // createInterestCalculator() 함수가 리턴하는 것은 내부에서 정의한 함수의 주소이다.
  // => 이렇게 함수 안에서 정의한 함수를 '클로저(closure)'라 부른다.
  var fn = createInterestCalculator("정기예금"); 
  
  console.log("100억 7달 =", fn(10000000000, 7));
  
</pre>
<br>
<br>
<strong>함수 - 클로저(closure)와 바깥 함수의 로컬 변수</strong>
<br>
<br>
<pre>
  // 함수 안에 정의된 함수를 보통 클로저(closure)라 부른다.
  // => inner function, nested function 이라고도 표현한다.
  // => 클로저의 핵심 개념 
  //    closure에서 바깥 함수의 로컬 변수를 사용할 때, 
  //    바깥 함수의 호출이 끝나면 해당 로컬 변수가 제거되기 때문에
  //    클로저는 존재하지 않는 변수를 사용하는 상황이 발생한다.
  //    그래서 이런 경우를 방지하고자, 
  //    클로저에서 사용하는 바깥 함수의 로컬 변수는 클로저의 별도 메모리에 복제된다.
  //
  //
  
  function createGreeting(name) {
    var message = name + "님 반갑습니다!";
    
    // 클로저 만들기
    var f = function() {
      console.log(message); // 클로저에서 바깥 함수의 변수를 사용하기
      // 클로저가 바깥 함수의 로컬 변수를 사용하면,
      // 내부적으로 클로저 메모리에 같은 이름으로 그 값을 복제해 둔다.
      // 따라서 바깥 함수의 호출이 끝나 로컬 변수가 사라지더라도 영향을 받지 않는다. 
    };
    
    return f;
  }
  
  var test1 = createGreeting("홍길동");
  var test2 = createGreeting("임꺽정");
  
  test1();
  test2();


*closure
함수를 만들 당시 로컬변수로 변수를 지정하면 변수 수행후 로컬변수는 사라사라 진다

-> 바깥 함수의 로컬변수를 사용할때 발생하는 문제 해결법

closure를 만들때 클로저가 사용하는 바깥 함수의 로컬 변수가 있다면, 클로저의 별도
메모리에 복제해 두기때문에 바깥 함수의 message가 없어도 상관없다
매번 함수를 호출 할때마다 새로운 클로저를 생성한다
</pre>
<br>
<br>
<strong>함수 - 클로저(closure)와 바깥 함수의 로컬 변수2</strong>
<br>
<br>
<pre>
  // 함수 안에 정의된 함수를 보통 클로저(closure)라 부른다.
  // => inner functoin, nested function 이라고도 표현한다.
  // => 클로저의 핵심 개념 
  //    closure에서 바깥 함수의 로컬 변수를 사용할 때, 
  //    바깥 함수의 호출이 끝나면 해당 로컬 변수가 제거되기 때문에
  //    클로저는 존재하지 않는 변수를 사용하는 상황이 발생한다.
  //    그래서 이런 경우를 방지하고자, 
  //    클로저에서 사용하는 바깥 함수의 로컬 변수는 클로저의 별도 메모리에 복제된다.
  //
  //
  function closureMaker(fnType, count) { // 잊지말라 파라미터도 로컬 변수이다.
    switch (fnType) {
    case "sum":
        return function() { 
          // 이렇게 클로저를 정의하는 순간 클로저가 사용하는 바깥 함수의 로컬 변수 count는
          // 클로저가 관리하는 별도의 메모리에 복제된다.
          // 따라서 바깥 함수의 실행이 끝나 그 로컬 변수가 사라지더라도 
          // 클로저는 복제된 변수를 계속 사용할 수 있다.
            var sum = 0;     
            for (var i = 1; i <= count; i++) {
                sum += i;
            }
            console.log("합계 =", sum);
        };
    case "factorial":
          return function() {
            var sum = 1;
            for (var i = 1; i <= count; i++) {
                sum *= i;
            }
            console.log("팩토리얼 =", sum);
        };
    default:
        return function() {
          console.log("해당 연산을 지원하지 않습니다.");
      };
    }
  }
  
  var fn1 = closureMaker("sum", 10);
  var fn2 = closureMaker("factorial", 5);
  
  fn1();
  fn2();

//

</pre>
<br>
<br>
<strong>함수 - 클로저(closure)를 객체에 담아 리턴하기</strong>
<br>
<br>
<pre>
  function createBox() { 
    var value;
    
    var box = new Object();
    box.setValue = function(v) {
      // 이 클로저가 사용하는 value 변수는 바깥 함수의 로컬 변수이기 때문에
      // 클로저 메모리로 복사해둔다.
      value = v;
    };
    box.getValue = function() {
      // 함수가 호출될 때 함께 생성된 클로저는 메모리를 공유한다.
      // 따라서 setValue()와 getValue()가 사용하는 value 변수는  
      // 같은 변수이다.
      return value;
    };
    
    return box;
  }
  
  var box1 = createBox();
  var box2 = createBox();
  
  box1.setValue(100);
  box2.setValue(200);
  
  console.log(box1.getValue());
  console.log(box2.getValue());
  
  console.log(box1.value); //
  console.log(box2.value); // 



// 한번 호출에 생성된 쿨로저 들은 메모리를 공유한다 클로저로 복제한 변수는 클로저를
통해서만 접근할 수 있다
</pre>
<br>
<br>
<strong>함수 - 애로우(arrow) 함수</strong>
<br>
<br>
<pre>
  // 익명 함수를 정의할 때 arrow function 문법을 사용할 수 있다.
  // 문법:
  //    (파라미터,파라미터,...) => 문장
  //    (파라미터,파라미터,...) => {문장1; 문장2;}
  //
  //
  // 일반 함수
  function f0() {
     return "안녕";
  }
  console.log(f0());
  
  
  var f1 = function() {
    return "안녕";
  };
  console.log(f1());
  
  // 애로우(arrow ) 함수 : 초간단 함수 정의 문법
  // 1) function 키워드를 제거한다.
  // 2) 대신 파라미터 블록과 코드 블록 사이에 화살표를 추가한다.
  // 3) 다른 언어에서는 람다(lambda) 라고 부른다.
  var f2 = () => {
    return "안녕";
  };
  console.log(f2());
  
  // 3) 한 문장만 있을 때는 중괄호를 제거할 수 있다.
  // 4) 그 한 문장이 리턴 문장일 경우 return을 반드시 생략해야 한다.
  //    그리고 문장의 끝을 나타내는 세미콜론을 제거한다.
  // (한 문장 밖에 없으니까 가능한 한 줄로 표현하라!)
  var f3 = () => "안녕";
  console.log(f3());
  console.log("----------------------------------------");
  
  // 익명함수 정의 후 바로 호출하는 방법
  var f4 = function() {
    return "안녕";
  };
  console.log(f4());
  
  
  // 애로우 함수를 정의 하는 즉시 호출하기 
  var f5 = () => "안녕";
  console.log(f5());

  console.log((() => "안녕")());
  console.log("----------------------------------------");
  
  //

var plus = function(a, b) {
	return a + b;
};
console.log((function(a, b) {
	return a + b;
})(100, 200));

var plus = (a, b) => a + b;
console.log(((a, b) => a + b)(111, 222));


</pre>
<br>
<br>
<strong>함수 - 애로우(arrow) 함수</strong>
<br>
<br>
<pre>
  //일반
  function divide(a, b) {
    console.log(a / b);
  };
  divide(8, 5);
  
  
  //익명
  
  var divide = function(a, b) {
    console.log(a / b);
  };
  divide(8, 5);
  
  //익명한줄
  
  (function(a, b) {
    console.log(a / b);
  })(8, 5);
  
  //에로우
  
  ((a, b) => console.log(a / b))(8, 5);



</pre>
<br>
<br>
<strong>함수 - 애로우(arrow) 함수를 아규먼트로 전달하기</strong>
<br>
<br>
<pre>
  //배열의 forEach 사용하기

  let arr = [100, "홍길동", 3.14, "임꺽정", true];
  
  // 배열에서 값 꺼내기 
  // 1. 
  
  for (let i = 0; i < arr.length; i++) {
    console.log(arr[i]);
  }
  
  console.log("--------------------------");
  
  //2.
  
  arr.forEach(myfunction1);
  
  function myfunction1(value, index) {
    console.log("==>", value, index);
  }
  console.log("--------------------------");
  
  arr.forEach(myfunction2);
  
  function myfunction2(value, index) {
    console.log("-->", value, index);
  }
  
  console.log("--------------------------");
  
  arr.forEach((value, index) => console.log("-->", value, index));
  
</pre>
<br>
<hr>
<br>
<h1>2022-12-09</h1>
<br>
<br>
<strong>closure 리턴</strong>
<br>
<br>
함수를 호출하고 함수를 정의한다 그러면 따로 메모리안에 code segment와 <br>
data segment가 저장된다 이 함수를 부를 때는 이 주소를 보내준다 
<br>
<br>
<strong>함수 - 함수도 객체다</strong>
<br>
<br>
<pre>
  // 함수도 객체이기 때문에 프로퍼티를 추가할 수 있다.
  //
  function f1() {
      console.log("f1().....");
  }
  
  // 함수 = 객체 + 함수코드(파라미터, 리턴 값, 함수 몸체)
  f1(); // "f1 함수 객체에 저장된 함수 코드를 실행하라!"는 의미다.
  
  // 함수는 객체이기 때문에 일반 객체처럼 사용할 수 있다.
  f1.v1 = "홍길동";
  f1.v2 = 100;
  f1.v3 = true;
  f1.hello = function() {
    console.log("Hello!");
  };
  f1.hello2 = () => console.log("Hello2!");
  
  console.log(f1.v1);
  console.log(f1.v2);
  console.log(f1.v3);
  f1.hello();
  f1.hello2();
</pre>
<br>
<br>
함수명 ();<br>
-함수호출(function call)
<br>
f1. 프로퍼티(); <br>
- 앞에는 함수 주소를 주고 () 를 하면 안에 내용을 실행시킨다<br>
예) f1.hello();
<br>
<br>
<strong>자바스크립트 주요 함수 - setTimeout()</strong>
<br>
<br>
<pre>
  // 일정 시간이 경과한 후 특정 함수를 호출하게 할 수 있다.
  // => window.setTimeout(함수, 경과시간);

  // 사용법 1) 일반함수 외부에 호출될 함수를 정의하고 함수를 호출해 사용
  function f1() {
      console.log("f1().....")
  }
  
  console.log("-------------------");
  
  // f1() 함수를 5초 후에 호출해 달라고 등록한다.
  window.setTimeout(f1, 5000);
  
  // 사용법 2) 익명함수 사용
  // 실무에서는 함수를 파라미터로 전달할 때
  // 다음과 같이 익명 함수를 직접 파라미터 자리에 정의하는 방식을 사용한다.
  // window.setTimeout(function() {
  //     console.log("익명함수 호출...")
  // }, 10000);
  
  // 사용법 3) 에로우 함수 사용
  // window.setTimeout(() => console.log("애로우 함수 호출..."), 15000);
  console.log("일단 실행 끝!");
</pre>
<br>
<br>
<pre>
동기실행(synchronize)
-문장에 순서대로 실행이 끝나야 다음문장 실행
  
비동기실행(Asynchronize)
-문장을 실행 하고 다른 문장으로 바로 넘어간다 여기서 문제가 발생할 수 있다
window.setTimeout으로 시간이 걸리는 작업이 있는경우 이 함수작업이 끝난후 
적용을 시키켜야할 함수가 존재한다면  promise 사용으로 생성시점에 적용하지
않는 값들을위한 대리자이다

</pre>
<br>
<br>
<strong>자바스크립트 주요 함수 - setInterval()</strong>
<br>
<br>
<pre>
  // 일정 시간이 경과할 때마다 특정 함수를 반복적으로 호출할 수 있다.
  // => window.setInterval(함수, 경과시간);
  
  // => setInterval() 로 가동시킨 타이머를 멈추기
  // => window.clearInterval(타이머아이디);
  var count = 0;
  function f1() {
      console.log("f1()....." + (++count));
      if (count >= 10) {
       window.clearInterval(timerId); // 지정한 interval 타이머를 멈추게 한다.
      }
  }
  
  // f1() 함수를 2초 마다 호출하라!
  // => setInterval()을 통해 함수를 등록하면 리턴 값으로 등록 번호를 알려준다.
  // => 이 등록번호를 보관해 두었다가, 타이머를 멈추고 싶을 때 사용하면 된다.
  var timerId = window.setInterval(f1, 2000);
</pre>
<br>
<br>
<strong>자바스크립트 주요 함수 - eval()</strong>
<br>
<br>
<pre>
  // 자바스크립트 코드를 실행해주는 코드


  // 텍스트로 된 자바스크립트를 실행하는 함수
  //
  // => "실행" 버튼을 누르면 textarea 상자에 입력한 자바스트립트를 실행시키기
  //
  var ta = document.getElementById("ta");
  
  document.getElementById("btn1").onclick = () => {
    // input, textarea, select 등 입력폼 항목의 값을 꺼낼 때는
    // innerHTML이 아니라 value 프로퍼티를 사용해야 한다.
    var str = ta.value;
  
    // eval(자바스크립트코드)
    // => 이 함수는 파라미터로 주어진 자바스크립트 코드를 실행한다.
    eval(str);
  
    // eval()로 실행한 결과는 그래도 유지된다.
    // 따라서 eval()에서 자바스크립트 코드를 실행할 때
    // window 객체에 name 값을 넣으면
    // eval() 실행이 끝난 다음에도 그대로 유지된다.
    console.log("v1=", window.v1);
  };
</pre>
<br>
<br>
<strong>onclick 함수</strong>
<br>
<br>
태그객체.onclick = 함수주소;
-사용자가 마우스로 태그를 클릭하면 저장된 함수를 호출한다 callback = 이벤트리스너 = 핸들러
<br>
<br>
<strong>자바스크립트 주요 함수 - eval() II</strong>
<br>
<br>
<pre>
  // 객체를 생성하여 리턴 받기
  //
  // => "실행" 버튼을 누르면 textarea 상자에 입력한 자바스트립트를 실행하여
  //    객체를 리턴 받는다.
  // => 물론 입력 값은 자바스크립트 객체 생성 코드여야 한다.
  //
  var ta = document.getElementById("ta");
  
  document.getElementById("btn1").onclick = () => {
    var str = ta.value;
    var obj = eval(str); // JavaScript 객체 생성 코드를 실행한다. JSON과 다르다.
    //var obj = JSON.parse(str); // JSON 형식으로 된 자바스크립트 객체 생성 코드를 실행한다.
    console.log(obj);
  
    // 1) 단일 객체 생성
    // => 주의! 괄호 () 안에 객체 생성 문법인 중괄호{} 를 넣어야 한다.
    //    안 그러면 실행 오류이다!
    /* 입력 값 예)
    ({
    "name": "홍길동",
    "age": 20,
    "tel": "1111-1111"
    })
      */
  
      // 2) 배열 객체 생성
      // => 배열 코드는 괄호 안에 넣을 필요가 없다.
      /* 입력 값 예)
      ["홍길동", "임꺽정",100,true,null]
      */
  };
</pre>
<br>
<br>
<strong>자바스크립트 주요 함수 - JSON.parse(JSON형식문자열)</strong>
<br>
<br>
<pre>
  // 객체를 생성하여 리턴 받기
  //
  // => "실행" 버튼을 누르면 textarea 상자에 입력한 자바스트립트를 실행하여
  //    객체를 리턴 받는다.
  // => 물론 입력 값은 자바스크립트 객체 생성 코드여야 한다.
  //
  var ta = document.getElementById("ta");
  
  document.getElementById("btn1").onclick = () => {
    var str = ta.value;
    var obj = eval(str); // JavaScript 객체 생성 코드를 실행한다. JSON과 다르다.
    //var obj = JSON.parse(str); // JSON 형식으로 된 자바스크립트 객체 생성 코드를 실행한다.
    console.log(obj);
  
    // 1) 단일 객체 생성
    // => 주의! 괄호 () 안에 객체 생성 문법인 중괄호{} 를 넣어야 한다.
    //    안 그러면 실행 오류이다!
    /* 입력 값 예)
    ({
    "name": "홍길동",
    "age": 20,
    "tel": "1111-1111"
    })
      */
  
      // 2) 배열 객체 생성
      // => 배열 코드는 괄호 안에 넣을 필요가 없다.
      /* 입력 값 예)
      ["홍길동", "임꺽정",100,true,null]
      */
  };
</pre>
<br>
<br>
<strong>JSON.parse()</strong>
<br>
<br>
JSON형식의 문자를 javascript 객체를 생성하고 주소를 리턴한다 
<br>
1. javascript 객체리터럴 문법과 유사 => 이 문법을 참고해서 만든 포맷
2. 문자열은 "" 으로 표현
3. 프로퍼티면은 문자열로 표현
4. 함수 표현 안됨 => 값만 표현가능하고 다른객체 표현가능하다 
<br>
<br>
<strong>data 포맷 : binaty vs text</strong>
<br>
<br>
<pre>
  binary
  -바이트 단위로 규칙에 따라 저장한다
  읽을 때 바이트 규칙에 따라 읽는다
  특징
  1. 파일크기가 가장 작은 포맷이다
    - 데이터에 대한 부연 설명(meta data)이 없다
    - 바이트 저장 규칙을 모른다면 데이터를 제대로 읽을 수 없다
  2. 텍스트 편집기로 데이터를 제대로 볼 수 없다
</pre>
<br>
<br>
<pre>
  text
  특징
  1. 텍스트 에디터로 읽고 편집이 가능하다
  2. binary형식에 비해 파일 크기는 커진다

  -csv 방식
  예) 홍길동,20,true

    1. 간결하다
    2. 한줄에 한데이터
    3. 각항목의 정보가 없다 따라서 직접적으로 이해하기 어렵다
    4. 계층구조로 데이터를 다룰수 없다
  -텍스트 표현 규칙에 따라 저장한다

  -XML(extensible markup lenguage)
  예) <name>홍길동</name>

    1. 계층구조의 데이터 표현가능
    2. 각 항목의 의미를 표현가능 하여 특정 조건의 항목을 찾기 쉽다
    3. data보다 metadata가 더 클수있다 따라서 파일 크기가 크다

  -JSON(JAVAscript Object Notation)
  예) ({
    "name": 홍길동,
    "age": 20,
    "working": true
  })

    1. XML보다 더 간결한 metadata
    2. javascript와 유사 포맷이 익숙하다
  
  -YAML(yet another markup lenguage)
  예) name: 홍길동
      age: 20
      working: true
        -school:
          name: 비트초등
          state: 졸업
    
    1. JSON보다 더 간결
    2. 들여쓰기로 계층구조 표현
    
</pre>
<br>
<br>
<strong>자바스크립트 주요 함수 - JSON.stringify(자바스크립트객체)</strong>
<br>
<br>
<pre>
  // 자바스크립트 객체를 JSON 문자열로 바꾸로 싶을 때 사용한다.
  //      자바스크립트 객체  ===변환===> JSON 형식의 문자열
  // 용도:
  // => 웹브라우저에서 단순한 형식(name=aaa&age=20&tel=1111-1111)이 아닌
  //    데이터가 다른 데이터를 포함하는 복잡한 구조의 데이터를 서버에 보내고 싶을 때
  //    JSON 형식의 문자열로 만들어 보낸다.
  // => 서버는 클라이언트가 보낸 JSON 형식의 문자열을 자바 객체로 만들어 사용한다.
  //    물론 JSON 형식의 문자열을 다루는 자바 라이브러리가 많이 있다.
  //    자세한 것은 www.json.org 사이트를 보라!
  //
  var ta = document.getElementById("ta");
  
  document.getElementById("btn1").onclick = () => {
    let obj = new Object();
    obj.name = "홍길동";
    obj["age"] = 20;
    obj['tel'] = '111-2222';
    obj.plus = function(a, b) {return a + b;}; // 함수는 JSON 포맷으로 만들 때 제외된다.
  
    ta.value = JSON.stringify(obj);
  
  
  
  };
</pre>
<br>
<br>
<strong>함수 - 익명 함수와 호출</strong>
<br>
<br>
<pre>
  // 익명 함수를 정의하는 즉시 바로 호출할 수 있다.
  //
  //1) 일반적인 방법
  //=> 함수를 정의한 후 변수에 저장한다.
  //=> 그리고 그 변수 이름으로 호출한다.
  var f1 = function() {
      console.log("방법1....");
  };
  
  f1(); // 함수 호출
  f1(); // 함수를 별도로 정의하면 여러 번 호출할 수 있다.
  f1();
  console.log("------------------------");
  //2) 함수 정의 즉시 호출하기
  //=> (익명함수정의)(파라미터 값);
  //=> (익명함수정의(파라미터 값));
  //=> 딱 한 번만 호출할 때 유용하다.
  (function() {
    console.log("방법2....");
  })();
  
  (function() {
    console.log("방법3....");
  }());
  
  // 괄호를 생략하면 문법 오류이다.
  // function() {
  //   console.log("방법2....");
  // }();
  
</pre>
<br>
<br>
<strong>함수 - 익명 함수와 호출 II : 파라미터 전달하기</strong>
<br>
<br>
<pre>
  // 파라미터가 있는 익명 함수를 정의하고 즉시 호출해 보자! 
  //
  //1) 일반적인 방법
  //=> 함수를 정의한 후 변수에 저장한다. 
  //=> 그리고 그 변수 이름으로 호출한다.
  var f1 = function(a, b) {
      console.log("결과=", (a + b));
  };
  
  f1(100, 200); // 함수 호출
  f1(20, 30); // 함수 호출
  f1(15, 16); // 함수 호출
  console.log("--------------------------------------");
  //2) 함수 정의 즉시 호출하기
  //=> (익명함수정의)(파라미터 값);
  (function(a, b) {
      console.log("결과=", (a + b));
  })(200, 300);
  
  (function(a, b) {
      console.log("결과=", (a + b));
  }(200, 300));
</pre>
<br>
<br>
<strong>설계도 방식 과 프로토타이핑 방식</strong>
<pre>
1. 설계도 방식으로 객체 생성 (예: java,c++,,)
-추가못하는 방식
class Student {
  String name;
  int age;
  boolean working;
}

객체를 생성 

Student obj = new Student();   (stack type dinding)
메모리를 준비하고 주소를 저장
String name;
int age;
boolean working;
만 가능 

2. 프로토타이핑 방식으로 객체 만들기
-객체 원리들을 기반으로 프로퍼티를 추가하는 방법
-설계도 없음
var obj = new Object();
1. 빈객체 생성
2 기본프로퍼티추가 -> 객체라면 반드시 있어야 할 변수나 함수
obj.name = "홍길동"
obj.age = 20;
obj.working = true;
</pre>
<br>
<br>
<strong>객체 - 정의</strong>
<pre>
  //4) 위의 코드보다 더 간결한 방법.
  // => 객체 리터럴 문법을 사용하여 만들기
  var obj4 = {}; 
  console.log(obj4);
</pre>
<strong>과제</strong>
<br>
<br>
todo list 만들기
<br>
디렉토리 구조 
todo.html<br>
js/*.js<br>
css/*.css<br>
images/*.jpg,*.png,*.gif
<br>
<br>
참고해볼 자료
https://woojong92.tistory.com/entry/JS-%EB%B0%94%EB%8B%90%EB%9D%BC-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%A1%9C-ToDo-List-%EB%A7%8C%EB%93%A4%EA%B8%B0-1-%EA%B8%B0%EB%8A%A5%EC%A0%95%EC%9D%98-%EB%B0%8F-HTMLCSS
<br>
<hr>
<br>
<h1>2022-12-12</h1>
<br>
<br>
<strong>객체 생성</strong>
<br>
<br>
Object.create(null) -> 빈객체  =  new
<br>
Object.create(Object.protortype) = new Object() <br>
<br>
-> 1.빈객체 생성 <br>
2. protortype으로 지정된 생성자를 통행 기본 프로퍼티 추가 
<br>
<br>
<strong>생성자 (constructor)</strong>
<br>
<br>
new Object();
<br>
빈객체에 프로퍼티를 준비시키는 것
<br>
<br>
new: 빈객체 생성
Object(): 프로퍼티 추가
<br>
<br>
<strong>hasOwnProperty</strong>
<br>
개발자가 추가시킨 프로퍼티인지 검사
console.log(obj.hasOwnProperty("toString")); -> false
<br>
obj.title = "---";
obj.["content"] = "---";
obj.plus1 = f1;
obj.plus2 = () => {--};
<br>
console.log(obj.hasOwnProperty("title")); -> true
<br>
<br>
<strong>객체가 다른 객체를 포함하는 경우</strong>
<br>
<br>
let obj = new Object();
<br>
var obj2 = new Object();
obj2.v1 = 100;
obj2.v2 = true;
obj2.v3 = "문자열";
obj2.v4 = () => console.log("v4()....");
<br>
obj.other = obj2;
<br>
console.log(obj.other.v1); = 100
<br>
<br>
<strong>객체 - 객체에 소속된 함수가 같은 객체에 소속된 다른 멤버 사용하기</strong>
<br>
<pre>
this
함수가 소속된 객체의 주소를 나타낸다
여기서
this = obj 를 가리킨다
var obj = new Object();

obj.name = "홍길동";
obj.kor = 100;
obj.eng = 90;
obj.math = 80;

// toString()은 이미 객체에 들어 있는 함수이다.
// 다음은 기존 함수를 덮어 쓴다.
obj.toString = function() {
	// 자바와 달리 객체의 프로퍼티 변수를 사용할 때는 반드시 this를 붙여야 한다.생략하면 안된다.
	return name + "," + this.kor + "," + this.eng + "," + this.math;
};

*name은 window 등록된 객체이기때문에 this가 없어도 상관없다 다른 kor등은 window에 없어서 this가 있어야 한다
</pre>
<br>
<br>
<strong>객체 - {}을 이용하여 객체 생성하기 (객체리터럴 문법 object literal)</strong>
<br>
<pre>
  // {}은 기본 객체를 생성하는 단축 문법이다.
  // 즉 new Object()와 같다. 
  
  var obj = {}; //new Object();  
</pre>
<br>
<br>
<strong>객체 - {}을 이용하여 기본 객체에 프로퍼티 추가하기</strong>
<br>
<pre>
  // {}은 기본 객체를 생성할 뿐만 아니라 프로퍼티도 바로 추가할 수 있다.
  //실무에서는 이런 방식 
  var obj = {
    "name": "홍길동",   // json은 "" 을 꼭 사용
    'kor': 100,
    eng: 90,
    math:80,           
    sum: function() {
        return this.kor + this.eng + this.math;
    },
    aver: function() {
        return this.sum() / 3;
    }
  };
  
  console.log(obj.sum(), obj.aver());
  console.log(obj);
  
</pre>
<br>
<br>
<strong>객체 - {}을 이용하여 기본 객체에 함수를 추가하는 또 다른 방법</strong>
<br>
<pre>
  var obj = {
    name: "홍길동",
    kor: 100,
    eng: 90,
    math:80,
    /*
    sum: function() {                   // 예전문법
      return this.kor + this.eng + this.math;
    },
    */
    sum() {                            // 요즘문법
        return this.kor + this.eng + this.math;
    },
    aver() {
        return this.sum() / 3;
    }
  };
  
  console.log(obj.sum(), obj.aver());
  console.log(obj);
</pre>
<br>
<br>
<strong>객체 - {} 문법과 arrow function</strong>
<br>
<pre>
  // arrow fuction을 객체의 프로퍼티로 등록할 때,
  // => arrow function에서 this는 소속된 객체가 아니라 window 객체를 가리킨다.
  // => 그에 비해 일반 함수나 익명 함수에서 사용하는 this는 자신이 소속된 객체를 가리킨다.
  //
  var obj = {
    name: "홍길동",
    kor: 100,
    eng: 90,
    math:80,
    sum: () => this.kor + this.eng + this.math,
    aver: () => this.sum() / 3,
    test1: function() {console.log(this);},
    test2() {console.log(this);},
    test3: () => console.log(this)
  };
  
  // console.log(obj.sum()); // this 즉 window 객체에 kor, eng, math라는 변수가 없기 때문에
                           // 리턴 값은 NaN이다.
  // console.log(obj.aver()); // 마찬가지로 this 즉 window 객체에 sum() 함수가 없기 때문에
                           // 함수 실행 중에 오류가 발생한다.
  
  
  obj.test1();
  obj.test2();
  obj.test3();
  
  // 결론!
  // => 객체의 멤버 함수로 등록할 때는 arrow function을 사용하지 말라!
  // => 물론 객체의 다른 멤버를 사용하지 않는다면 arrow function을 사용해도 된다.
  
</pre>
<br>
<br>
<strong>객체 - 객체 생성과 초기화 I</strong>
<br>
<pre>
  // 1) 낱개의 레퍼런스 변수 선언

  // 자바스크립트는 객체를 생성할 때 기본 객체를 준비한 후
  // 기본 객체에 프로퍼티를 추가하는 방식으로 객체를 초기화시킨다.
  var s1 = new Object();
  s1.name = "홍길동";
  s1.kor = 100;
  s1.eng = 100;
  s1.math = 100;
  s1.sum = s1.kor + s1.eng + s1.math;
  s1.aver = s1.sum / 3;
  
  var s2 = new Object();
  s2.name = "임꺽정";
  s2.kor = 90;
  s2.eng = 90;
  s2.math = 90;
  s2.sum = s2.kor + s2.eng + s2.math;
  s2.aver = s2.sum / 3;
  
  var s3 = new Object();
  s3.name = "유관순";
  s3.kor = 80;
  s3.eng = 80;
  s3.math = 80;
  s3.sum = s3.kor + s3.eng + s3.math;
  s3.aver = s3.sum / 3;
  
  console.log(s1.name, s1.kor, s1.eng, s1.math, s1.sum, s1.aver);
  console.log(s2.name, s2.kor, s2.eng, s2.math, s2.sum, s2.aver);
  console.log(s3.name, s3.kor, s3.eng, s3.math, s3.sum, s3.aver);
</pre>
<br>
<br>
<strong>객체 - 객체 생성과 초기화 II</strong>
<br>
<pre>
  // 2) 레퍼런스 배열 사용

  // 배열을 이용하여 여러 개의 객체를 다루기
  var scores = []; //new Array();
  scores[0] = new Object();
  scores[0].name = "홍길동";
  scores[0].kor = 100;
  scores[0].eng = 100;
  scores[0].math = 100;
  scores[0].sum = scores[0].kor + scores[0].eng + scores[0].math;
  scores[0].aver = scores[0].sum / 3;
  
  scores[1] = {}; // new Object();
  scores[1].name = "임꺽정";
  scores[1].kor = 90;
  scores[1].eng = 90;
  scores[1].math = 90;
  scores[1].sum = scores[1].kor + scores[1].eng + scores[1].math;
  scores[1].aver = scores[1].sum / 3;
  
  scores[2] = {}; // new Object();
  scores[2].name = "임꺽정";
  scores[2].kor = 80;
  scores[2].eng = 80;
  scores[2].math = 80;
  scores[2].sum = scores[2].kor + scores[2].eng + scores[2].math;
  scores[2].aver = scores[2].sum / 3;
  
  for (var score of scores) {
      console.log(score.name, score.kor, score.eng, score.math, score.sum, score.aver);
  }
  
  // 배열을 쓰면 for 문을 통해 더욱 쉽게 자료를 관리할 수 있다
</pre>
<br>
<br>
<strong>객체 - 객체 생성과 초기화 III</strong>
<br>
<pre>
  // 3) 함수를 이용해 객체 생성

  // 함수를 이용하여 객체를 초기화시키기
  // 참고 
  // 팩토리 메서드 패턴(Factory Method): 이렇게 함수를 통해 객체를 생성하는 기법
  // => 객체 생성 과정이 복잡할 경우 직접 객체를 생성하고 초기화 시키기 보다 
  // 함수를 통해 객체를 생성하고 초기화 시키는것이 코드를 더 간결하게 한다
  function createScore(name, kor, eng, math) {
    const obj = new Object();
    obj.name = name;
    obj.kor = kor;
    obj.eng = eng;
    obj.math = math;
    obj.sum = kor + eng + math;
    obj.aver = obj.sum / 3;
    return obj;
  }
  
  var scores = []; // new Array();
  scores[0] = createScore("홍길동", 100, 100, 100);
  scores[1] = createScore("임꺽정", 90, 90, 90);
  scores[2] = createScore("유관순", 80, 80, 80);
  
  for (var score of scores) {
      console.log(score.name, score.kor, score.eng, score.math, score.sum, score.aver);
  }
  
  console.log("---------------------------------------------");
  
  // 아직 부족한 점!
  // => 특정 과목의 점수가 바뀌면 다시 합계와 평균을 계산해야 한다.
  scores[2].kor = 100;
  scores[2].sum = scores[2].kor + scores[2].eng + scores[2].math;
  scores[2].aver = scores[2].sum / 3;
  
  for (var score of scores) {
      console.log(score.name, score.kor, score.eng, score.math, score.sum, score.aver);
  }
</pre>
<br>
<br>
<strong>옵져버 패턴</strong> 
이벤트 리스너와,핸들러를 사용해 설계한것
<br>
<br>
<strong>객체 생성과 초기화 VI</strong>
<br>
<pre>
  // 6) 함수 외부에서 객체를 생성한 후 즉시 초기화시키기

  // new 명령 다음에 바로 함수를 호출한다.
  function createScore(name, kor, eng, math) {
    // new 명령을 실행한 후에 이 함수를 호출하면
    // this 내장 변수에 그 생성된 객체 주소가 저장된다.
    // 이렇게 되면 이 함수 내부에서 객체를 생성할 필요가 없다.
    // this 내장 변수를 사용하여 객체를 사용하면 된다.
    this.name = name;
    this.kor = kor;
    this.eng = eng;
    this.math = math;
    this.sum = function() {
      return this.kor + this.eng + this.math;
    };
    this.aver = function() {
      return this.sum() / 3;
    };
  
    // 이 함수에서 객체를 생성하지 않았기 때문에
    // 객체를 리턴할 필요가 없다.
  }
  
  var scores = []; //new Array();
  scores[0] = new createScore("홍길동", 100, 100, 100);
  scores[1] = new createScore("임꺽정", 90, 90, 90);
  scores[2] = new createScore("유관순", 80, 80, 80);
  
  // 이렇게 new 명령을 통해 생성된
  // 기본 객체를 초기화시키는 함수를 "생성자(constructor)" 라고 부른다.
  
  
  for (var score of scores) {
      console.log(score.name, score.kor, score.eng, score.math,
              score.sum(), score.aver());
  }
  
  // 다음과 같이 생성된 객체를 초기화시키는 것이 아니라
  // 객체를 생성하는 함수는
  // "팩토리 함수(factory)"라 부른다.
  function createScore2(name, kor, eng, math) {
    var obj = new Object();
    obj.name = name;
    obj.kor = kor;
    obj.eng = eng;
    obj.math = math;
    obj.sum = function() {
      return this.kor + this.eng + this.math;
    };
    obj.aver = function() {
      return this.sum() / 3;
    };
    return obj;
  }
  var obj = createScore2("홍길동", 100, 90, 80);
  console.log(obj);
</pre>
<br>
<br>
<strong>객체 - 객체 생성과 초기화 VIII</strong>
<br>
<pre>
  // 8) 객체에 대해 공통으로 사용하는 함수를 공유하기

  function Score(name, kor, eng, math) {
    this.name = name;
    this.kor = kor;
    this.eng = eng;
    this.math = math;
  
    // sum(), aver() 함수는 객체의 데이터(국어,영어,수학 점수)를 다루는 함수다.
    // 즉 객체에 대해 사용하는 함수다.
    // 그런데 객체를 생성할 때 마다 함수를 만들어 저장한다면 메모리가 낭비된다.
    // 해결 방안?
    // => 객체에 대해 공통으로 사용하는 함수는 별도의 보관소에 저장한다.
    /*
    this.sum = function() {
      return this.kor + this.eng + this.math;
    };
    this.aver = function() {
      return this.sum() / 3;
    };
    */
  }
  
  // 객체에 대해 공통으로 사용하는 함수는 생성자 객체에 보관한다.
  // => 생성자 객체에 prototype 객체가 들어 있는데 여기에 보관해야 한다.
  
  // 1) 자바스크립트 함수는 객체이다. 즉 "함수 = 객체 + 함수코드" 이다.
  // 2) 각각의 함수 객체는 prototype 이라는 공용 저장소를 갖고 있다.
  // 3) prototype에 저장된 프로퍼티는 그 함수를 통해 초기화된 모든 객체가 공통으로 사용할 수 있다.
  Score.prototype.sum = function() {
    return this.kor + this.eng + this.math;
  };
  
  Score.prototype.aver = function() {
    return this.sum() / 3;
  };
  
  var scores = []; //new Array();
  scores[0] = new Score("홍길동", 100, 100, 100);
  scores[1] = new Score("임꺽정", 90, 90, 90);
  scores[2] = new Score("유관순", 80, 80, 80);
  
  for (var score of scores) {
      console.log(score);
      console.log(score.name, score.kor, score.eng, score.math,
              score.sum(), score.aver());
      // 객체에서 sum(), aver() 함수를 찾는다.
      // 없으면, 그 객체를 초기화시킨 생성자의 prototype 보관소에서 찾는다.
      // 따라서 위의 sum(), aver() 함수는
      // Score.prototype 보관소에 들어 있는 함수를 호출하는 것이다.
  }
</pre>
<br>
<br>
<strong>생성자1 - 정의하는 방법</strong>
<br>
<br>
<pre>
  // 생성자는 그냥 일반 함수이다.
  // new 명령 다음에 즉시 함수를 호출하면 생성자로서 역할을 한다.
  
  function f1() {
    // 자바스크립트는 생성자를 정의하는 문법이 따로 없다.
    // 일반 함수를 생성자처럼 사용한다.
    // => new 명령을 사용하여 외부에서 빈 객체를 생성한 후,
    // => 일반 함수를 호출하면 생성자가 된다.
  }
  
  // => new 명령 다음에 함수를 호출하면 생성자로서 역할한다.
  var obj1 = new f1();  // 빈객체생성 
  console.log(obj1);
  console.log("-----------------------");
  
  // new 명령없이 호출하면 일반 함수로 취급된다.
  var obj2 = f1();            // undefined 
  console.log(obj2);
</pre>
<br>
<br>
<strong>생성자와 ocject</strong>
<br>
<br>
new f1();
-> 1. new: 빈객체 생성
2. f1() 의 수퍼 생성자 호출 (object)
3. f1() 호출
<br>
obj.toString()
1. 객체에서 찾는다
2. 생성자 f1.protortype에서 찾는다
3. super 생성자 object.protortype에서 찾는다
<pre>
  function f1() {
    // 생성자에 상관없이 모든 객체는 Object() 생성자의 prototype 보관소를 공유한다.
  }
  function f2() {}
  function f3() {}
  
  var obj1 = new f1();
  var obj2 = new f2();
  var obj3 = new f3();
  
  // f1(), f2(), f3() 생성자로 초기화시킨 객체 모두
  // Object.prototype 보관소에 저장된 변수나 함수를 사용할 수 있다.
  console.log(obj1);
  console.log(obj2);
  console.log(obj3);
  console.log("-------------------------------");
  console.log(obj1.toString());  // Object.prototype.toString()
  console.log(obj2.toString());  // Object.prototype.toString();
  console.log(obj3.toString());  // Object.prototype.toString();
  
</pre>
<br>
<br>
<strong>생성자5 - 생성자 상속</strong>
<br>
<br>
<pre>
  function Engine(v, c, cc) {
    // 호출할 상위 생성자를 지정하지 않으면
    // 기본으로 object() 생성자를 호출한다
    // object.call(this);
    this.valve = va;
    this.cylinder = cy;
    this.cc = cc;
  }
  
  var e1 = new Engine(16, 4, 2000);
  console.log(e1);
  
  function Car(va, cy, cc, ca, au) {
    // f1(n); // 일반함수 호출 방법으로는 f2()가 this로 받은 객체 주소를 전달할 방법이 없다
    // 상위 생성자를 명시적으로 호출한다.
    Engine.call(this, va, cy, cc);
  
    this.capacity = ca;  // 수용인원
    this.auto = au; // 미션
  }
  
  var c1 = new Car(16, 4, 2000, 5, true);
  console.log(c1);
  
</pre>
<br>
<br>
<strong>생성자를 체인으로 연결 하듯이 super-sub로  반드는 이유</strong>
<br>
<br>
생성자를 체인 방식으로 연결
- 생성자 재사용 가능
- 기능확장 용이
<br>
<br>
<strong>수퍼 생성자의 protortype 사용하기</strong>
<br>
<br>
object() 
생성자를 통해 만든 객체들이 공동으로 사용할 프로퍼티가 들어있다
<br>
Engine() 
생성자를 통행 만든 객체들이 공동으로 이용할 프로퍼티가 들어있다
<br>
<br>
<strong>수퍼 생성자의 protortype 연결하기</strong>
<br>
<br>
<strong>생성자6 - 생성자 상속과 prototype 연결</strong>
<br>
<br>
<pre>
  // 생성자 정의
  function Engine(valve, cylinder, cc) {
    //Object.call(this);
    this.valve = valve;
    this.cylinder = cylinder;
    this.cc = cc;
  }
  
  function Car(valve, cylinder, cc, capacity, auto) {
    Engine.call(this, valve, cylinder, cc);
  
    this.light = false;
    this.capacity = capacity;
    this.auto = auto;
  }
  // Car.prototype을 상위 생성자인 Engine.prototype과 연결한다.
  Object.setPrototypeOf(Car.prototype, Engine.prototype);
  
  // prototype에 프로퍼티 추가
  Object.prototype.test = function() {
    console.log("Object.test() 호출됨!");
  }; 
  Engine.prototype.print = function() {
    console.log("Engine.prototype.print():");
    console.log("  밸브: " + this.valve);
    console.log("  실린더: " + this.cylinder);
    console.log("  cc: " + this.cc);
  };
  Car.prototype.setLight = function(light) {
    console.log("Car.prototype.setLight():");
    this.light = light;
  };
  
  // Car 객체 생성
  var c1 = new Car(16, 4, 2000, 5, true);
  
  c1.setLight(true);
  // c1.setLight();
  // --> Car.prototype.setLight()
  
  c1.print();
  // c1.print();
  // --> Car.prototype.print()
  //     --> Engine.prototype.print()
  
  c1.test();
  // c1.test();
  // --> Car.prototype.test()
  //     --> Object.prototype.test() 
  
  console.log(c1);
  
</pre>
<br>
<br>
</section>
</main>
</div>
<footer id="footer">

<li><small><a href="https://github.com/96abab/test.io.git">96abab.GitHub.com - test.io</a></small></li>
</footer>
</body>
</html>
