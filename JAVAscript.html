<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JAVAscript</title>
    <link rel="stylesheet" href="stylesheet.css">
    <link rel="icon" href="https://96abab.github.io/test.io/ducklogo.png">
    
</head>
<body>
<div id="container">
<header>
  <h2>JAVAscript</h2>
  <nav>
    <ul id="topMenu">
      <li><a href="https://96abab.github.io/test.io">home</a></li>
      <li><a href="#">menu1</a></li>
      <li><a href="#">menu2</a></li>
    </ul>
  </nav>
</header>
</div>
<aside>
<ul id="sidebar">
  <li><a href="index.html">Home</a></li>
  <br>
  <li><a href="assignment.html">과제</a></li>
  <br>
  <li><a href="tictactoe.html">TICTACTOE</a></li>
  <br>
  <li><a href="cloudOS.html">1.CloudOS(리눅스서버설치)</a></li>
  <br>
  <li><a href="linux.html">2.리눅스 명령어 정리</a></li>
  <br>
  <li><a href="HTML5.html">3.HTML수업</a></li>
  <br>
  <li><a href="CSS.html">4.CSS수업</a></li>
  <br>
  <li><a href="JAVAscript.html">5.JAVAscript</a></li>
</ul>
</aside>
<main class="contents">
<section id="headling">
<h1>2022-12-01</h1>
<br>
<br>
<strong>##프로그램 실행과 프로그래밍</strong>
<br>
<br>
app (컴퓨터가 할 일을 순서대로 기록한 것 = programming)을 읽기OS에 (loading)저장<br>
ram에 저장한 기록을 cpu에 전달하고 명령어 실행하고 다시 ram으로 전달 하면 결과를<br>
OP에서 다시 APP로 전달해 출력한다
<br>
- 위 과정을 프로그램 실행이라고 한다 이때 ram에 저장한 데이터를 읽는 방법이 각각cpu<br>
명령어가 다르기 때문에 주의해야한다 
<br>
<br>
<strong>##CPU 와 RAM , bit</strong>
<br>
<br>
cpu와 ram이  테이터를 주고 받는 선 개수가 bit이다 나머지 선들은 전원과
다른기능들을 담당하고 제조사는 cpu를 통해 명령을 실행시키는 방법을 명
세서로 제공한다
<br>
신호를 보내는 비트 규칙을 instruction set 이라고 부른다
예) 64개=64bit
-cpu 버전이 높아지면 명령규칙 추가된다
-cpu 마다 명령어가 다르다
예) i계열vs제온계열
-cpu 제조사마다 규칙(전기신호)이 다르다
<br>
<br>
<strong>##명령어 작성</strong>
<br>
<br>
1. cpuinstruxtionset 명세서를 보고 직접 명령어(기계어) 작성
<br>
<br>
- cpu bit가 적은 8bit 시절에는 개발자가 직접 작성하기도 했다
<br>
- 보통 2진수를 짧게 표현한 16진수를 사용해서 작성
<br>
- 인간의 문자와 많이 다르기 때문에 작성이 까다롭고 힘들다
<br>
- cpu bit가 36,64 로 늘어나면서 더욱 어려워 졋다
<br>
- cpu마다 명령어(전기신호,비트규칙)가 다르기 때문에 다양한 cpu에서<br>
실행할 수 있는 명령어를 작성하기 매우 힘들다
<br>
<br>
2. 직접 기계어로 작성하는 대신 간결한 영어로 이루어진 명령어 사용 (assembly) <br>
- assembly언어를 기계어로 바꿔주는 프로그램을 compiler 라고 한다
<br>
<br>
- 명령어가 영어단어와 비슷해서 작성이 편하다
<br>
- compiler가 각각의 기계어로 번역해주기 때문에 cpu마다 명령어를<br> 
다르게 작성 할 필요가없다
<br>
<br>
3. C 인간 친화적인 프로그래밍 언어로 명령어 작성하기
<br>
<br>
-명령어를 만들고 각각 compiler 로 기계어로 바꾼후 각 cpu와<br>
 운영 체제에 알맞게 맞춰야한다
 <br>
-예전 프로그램 공유 문화 명령어 소스코드를 그대로 공유하여<br>
 각 cpu에 맞게 컴파일 했다
<br>
-linux는 컴파일러가 기본 내장
<br>
-c컴파일 +OS 적용 명령 사용<br>
DirextX 명령은 windows 전용 따라서 다른 운영체제를 사용하면<br> 
컴파일할 수 없다 
<br>
<br>
<strong>프로그래밍 언어 와  컴파일러</strong>
-언어선택
<br>
프로그래밍언어마다 특장점이 있다<br>
->프로젝트 성격에 따라 언어 선택<br>
-인공지능,머신러닝,딥러닝 : python <br>
web app : haba,php,go <br>
web ui : JAVAscript,typescript
<br>
<br>
<strong>컴파일 방식과 인터프리트 방식</strong>
<br>
컴파일 방식 : c언어를 컴파일러로 os에 맞춰 기계어로 바꿔주고 OS에 저장 cpu에서 명령처리
- 실행할때 기계어 파일만 있으면 된다
- 소스파일 필요없다 -> 소스파일을보호(자산)
- 실행할때 컴파일러 불필요
- 기계어 바로실행 -> 실행속도 빠름
<br>
<br>
인터프리트방식 (viewe) : js를 JAVAscriptinterpreter (컴파일 하지 않음)  
- 실행할때마다 소스 파일 필요 -> 소스파일 공개 -> 자산으로 보호하기 힘들다
- 실행하려면 인터프리트 필요
- 명령어를 해석해서 실행 -> 실행속도 느리다
예) 
<br>
<br>
<strong>JAVAscript (interpreter)Engine</strong>
<br>
chrome에는 webkit html,css렌더링엔진 과 v8 javascript엔진 이 있다 <br>
v8을 이용해 node.js 를 만들엇다 웹 브라우저 없이 JAVAscript실행
<br>
<br>
<strong>JIT compile 과 AOT compile</strong>
<br>
1. plain 인터프리터: 매번 소스를 검사하고 해석하기 때문에 속도가 느리다
<br>
2. JIT (just in time) 컴파일: 실행하려는 일부 코드를 컴파일 -> 컴파일 <br>
할 때 잠깐 느려지지만 이후 실행할때 빨라진다
<br>
3. AOT (ahead of time) 컴파일: 설치 시점에 미리 전체 소스를 컴파일 해둔다 <br>
-> 설치시간이 좀 더 걸린다 -> 실행은 컴파일방식과 같다
<br>
- bytecode ="중간코드" = p-code : 진짜  기계어가 아니라 흡사한 코드
<br>
- 안드로이드를 자바로 개발하면 bytecode로 play store 에 올린다<br> 
다운 받을시 사용자의 cpu에 맞춰 컴파일 한다 
<br>
<br>
<strong>Web browser와 JAVAscript</strong>
<br>
<br>
<h1>2022-12-02</h1>
<br>
<br>
<strong>OS,cpu,ram,HDD,기계어,명령문 관계도</strong>
<br>
<br>
1. 개발자가 명령문 작성 (instruction set)
<br>
- c,java등 인간친화용 언어로 명령문 작성<br>
- compiler 가 기계어로 번역<br>
<br>
2. HDD.SSD등 외장하드에 저장
<br>
3. 일부명령어를 실행하기 위해 ram으로 복사 (loading)
<br>
4. cpu로 보내 각 명령어를 처리<br>
<br>
- l1 명령어 임시 보관
<br>
- l2 data 임시 보관
<br>
- l3 data 멀티디어 , core끼리 공유
<br>
<br>
console.log(값,값,값,,);   <br>
웹브라우저에 개발자 보드 콘송함에를 값을 출력<br>
<br>
-console = 도구 = object (객체)
<br>
-log = 기능 = funcrion (함수)
<br>
-(값,값,값,,) = 기능을 수행하기위한 값 = argument (인자),parameter (파라미터)
<br>
<br>
<strong>변수와 값 할당</strong>
<br>
<br>
변수 선언 (variables)
<br>
갑을 저장할 메모리를 확보하는 명령문<br>
-> var,let,const
<br>
<br>
할당,대입 (assignment)
<br>
메모리에 값을 저장
<br>
-변수명 = 값; <br>
-변수명 = 변수명;<br>
-변수명 = 함수; <br>
= 을 assignment operator
<br>
변수=(변수 ,값,함수...) <br>
변수 (l-value) = 반드시 메모리여야한다 <br>
(변수 ,값,함수...) (r=value) 
<br>
<br>
<strong>for 반복문</strong>
<br>
<br>
<pre>
for (var i = 0; i < size; i++) {
  console.log(i, message);
  if (i == 5) {
    var working = true;
    break;
  }
</pre>
<br>
<br>
var i = 반복문을 실행하는 동안 사용하는 변수 주로 반복문에서 횟수를 제어하기위해 사용 <br>
i < size  = 반복문 횟수 지정 <br>
i++  =  값을 1씩 증가 <br>
<br>
<br>
<strong>function(함수)</strong>
<br>
특정 기능을 수행하도록 짜놓은 명령순을 묶어서 이름을 붙인것 필요할때 재실행 가능<br>
코드 재사용성을 높이는 문법
<br>
<br>
<pre>
function plus(a, b) {        <- 함수 정의 (definition)
  return a + b;
}

plus = 함수 이름
(a, b) = parameter             
a + b; = 실행 완료후 리턴 값

var sum = plus(100,200);       <- 함수사용법 호출 (call)


console.log(plus(10, 20)); 

ok = plus;
console.log(ok(100, 200));

var haha = ok;
console.log(haha(1000, 2000));

ok = "Hello";
ok(100, 200);

    
</pre>
<br>
<br>
<strong>함수레퍼런스</strong>
<br>
함수의 이름은 함수의 주소를 보관하고 있는 변수이다 
<br>
<strong>static type dinfing vs dynamic type dinfing</strong>
<br>
<pre>
dynamic type dinfing (짧은 코드 작은프로젝트) 
값을 넣을때 변수의 유형이 바뀐다 하지만 script 류의 프로그래밍 언어
자유분방하고 프로그래밍이 쉬워 유지보수가 어렵다 

javascript

var a;

a= 100;
a= "hello";
a= true;

static type dinfing (긴코드 큰 프로젝트)
언어 류의 프로그램 언어이고 엄격해 프로그래밍이 까다롭지만 유지보수가 쉽다

int a;

a= 10;
a= 20;
a= "hello"  (X)

인트로 지정해 문자는 불가능
</pre>

<br>
<br>
<pre>
객체 : 덩어리 (변수+함수+객체)

// 1) Object라는 원형 틀을 기반으로 기본 객체를 생성한다.
var obj1 = new Object(); // => HashMap<String,Object> obj1 = new HashMap<>();

// 기본 객체에 프로퍼티를 덧붙인다.
obj1.name = "홍길동"; // => obj1.put("name", "홍길동");
obj1.age = 20; // => obj1.put("age", 20);
obj1.working = true; // => obj1.put("working", true);
obj1.hello = function() {
  console.log("안녕하세요, " + this.name + "님!");
}; // => obj1.put("hello", 함수);

----------------------------------------------------------------
객체를 자바스크립트로 코드화한 것 (object literal)


var obj2 = {
  name:"임꺽정",
  age:30,
  working:true,
  hello:function() {
    console.log("안녕하세요, " + this.name + "님!")
  },
  hello2() {
    console.log("안녕하세요, " + this.name + "님2!")
  }
};
</pre>
<br>
<br>
literal (값을 코드로 표현한것)<br>
<br>
<br>
문자열 -> "abc"
<br>
숫자 -> 10
<br>
논리 -> true,false
<br>
변수의 값이 저장된 적이 없는 상태 -> undefined
<br>
객체 주소가 없는 상태 -> null
<br>
<br>
<strong>DOM API - getElementById()</strong>
<br>
태그를 다루는 프로그램을 짤 때 사용하는 도구
<br>
document <- HTML
<br>
boject <- 객체
<br>
model <- 구조로 만든것
<br>
<br>
DOMM
<br>
tag를 tree구조로 객체화 시킨것 tag를 찾고, 변경하고,추적,삭제하기 쉽도록 한것
<br>
<br>
API
<br>
application<br>
programming<br> 
intorface<br>
app을 프로그래밍 할때 사용하는 도구
<br>
<br>
<strong>객체와 함수(메서드=operator) , 파라미터의 관계</strong>
<br>
<br>
<pre>
document.getElementById("태그 아이디")
 ㄴ객체       ㄴ함수(일하는놈)    ㄴ함수가 기본데이터를 다룰때 사용할 값


예)

학생명단.find("홍길동")

학생명단 = 기본데이터
find = 작업 = 작업자 (operator)
홍길동 = 부가데이터
</pre>
<br>
ECMA스크립트란, Ecma International이 ECMA-262 기술 규격에 따라 정의하고 있는 표준화된<br>
스크립트 프로그래밍 언어를 말한다. 자바스크립트를 표준화하기 위해 만들어졌다. 액션스<br>
크립트와 J스크립트 등 다른 구현체도 포함하고 있다
<br>
ECMA스크립트는 ECMA-262에 의해 표준화된 언어의 이름이다.<br>
자바스크립트와 J스크립트는 모두 ECMA스크립트와의 호환을 목표로 하면서, ECMA 규격에<br>
포함되지 않는 확장 기능을 제공한다.
<br>
<strong>태그 찾기 -> 이벤트리스너 등록</strong>
<pre>
var tag1 = document.getElementById("btn1")

tag1.onclick = function() { // Observer 패턴: 리스너 => 이벤트 리스너 => 이벤트 핸들러 
=> 콜백함수(callback; cb)

  var tag2 = document.getElementById("p1");
  tag2.innerHTML = "비트캠프!";
};
사용자가 tag1을 클릭(onclick) 이라고 저장된 함수를 호출
innerHTML은 해당 함수에 등록된 태그의 내용을 바꿔준다
</pre>
<br>
<br>
<strong>요점 정리 - 5.HTML 태그와 DOM 트리 객체 응용</strong>
<pre>

  var inputNameIndex = 1;
  var btnAddName = document.getElementById("btnAddName");
  var inputNameContainer = document.querySelector("#inputNameContainer");
  var inputNameDiv = document.querySelector(".inputName");

  btnAddName.onclick = function() {
  inputNameIndex++;
  var e = inputNameDiv.cloneNode(ture);
  e.querySelector(".name").innerHTML = "이름" + inputNameIndex;
  e.querySelector("input").name = "name" + inputNameIndex;
  e.querySelector("input").value = "";
  inputNameContainer.appendChild(e);

</pre>
<br>
<br>
<strong>웹페이지 조립</strong>
<br>
<br>
서버에 자원을 요청
<br>
1. server-side rendering <br>
서버에서 HTML을 만들어준다(JSP,thymleaf) 
<br>
<br>
2. client-side rendering <br>
클라이언트에서 HTML을 만든다(reect,)
<br>
<br>
<strong>JSON 포맷</strong>
<br>
<pre>
var obj = {
  "name": "홍길동",
  "age": 20,
  "working": false,
};
</pre>
<br>
javascript의 object literal 을 참조해 만듬
<br>
<br>
과제 : 틱택토 만들기 12-04일 저녁 10시까지

</section>
</main>
</div>
<footer id="footer">

<li><small><a href="https://github.com/96abab/test.io.git">96abab.GitHub.com - test.io</a></small></li>
</footer>
</body>
</html>
