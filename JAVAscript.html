<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JAVAscript</title>
    <link rel="stylesheet" href="stylesheet.css">
    <link rel="icon" href="https://96abab.github.io/test.io/ducklogo.png">
    
</head>
<body>
<div id="container">
<header>
  <h2>JAVAscript</h2>
  <nav>
    <ul id="topMenu">
      <li><a href="https://96abab.github.io/test.io">home</a></li>
      <li><a href="#">menu1</a></li>
      <li><a href="#">menu2</a></li>
    </ul>
  </nav>
</header>
</div>
<aside>
<ul id="sidebar">
  <li><a href="index.html">Home</a></li>
  <br>
  <li><a href="assignment.html">과제</a></li>
  <br>
  <li><a href="tictactoe.html">TICTACTOE</a></li>
  <br>
  <li><a href="cloudOS.html">1.CloudOS(리눅스서버설치)</a></li>
  <br>
  <li><a href="linux.html">2.리눅스 명령어 정리</a></li>
  <br>
  <li><a href="HTML5.html">3.HTML수업</a></li>
  <br>
  <li><a href="CSS.html">4.CSS수업</a></li>
  <br>
  <li><a href="JAVAscript.html">5.JAVAscript</a></li>
</ul>
</aside>
<main class="contents">
<section id="headling">
<hr>
<h1>2022-12-01</h1>
<br>
<br>
<strong>##프로그램 실행과 프로그래밍</strong>
<br>
<br>
app (컴퓨터가 할 일을 순서대로 기록한 것 = programming)을 읽기OS에 (loading)저장<br>
ram에 저장한 기록을 cpu에 전달하고 명령어 실행하고 다시 ram으로 전달 하면 결과를<br>
OP에서 다시 APP로 전달해 출력한다
<br>
- 위 과정을 프로그램 실행이라고 한다 이때 ram에 저장한 데이터를 읽는 방법이 각각cpu<br>
명령어가 다르기 때문에 주의해야한다 
<br>
<br>
<strong>##CPU 와 RAM , bit</strong>
<br>
<br>
cpu와 ram이  테이터를 주고 받는 선 개수가 bit이다 나머지 선들은 전원과
다른기능들을 담당하고 제조사는 cpu를 통해 명령을 실행시키는 방법을 명
세서로 제공한다
<br>
신호를 보내는 비트 규칙을 instruction set 이라고 부른다
예) 64개=64bit
-cpu 버전이 높아지면 명령규칙 추가된다
-cpu 마다 명령어가 다르다
예) i계열vs제온계열
-cpu 제조사마다 규칙(전기신호)이 다르다
<br>
<br>
<strong>##명령어 작성</strong>
<br>
<br>
1. cpuinstruxtionset 명세서를 보고 직접 명령어(기계어) 작성
<br>
<br>
- cpu bit가 적은 8bit 시절에는 개발자가 직접 작성하기도 했다
<br>
- 보통 2진수를 짧게 표현한 16진수를 사용해서 작성
<br>
- 인간의 문자와 많이 다르기 때문에 작성이 까다롭고 힘들다
<br>
- cpu bit가 36,64 로 늘어나면서 더욱 어려워 졋다
<br>
- cpu마다 명령어(전기신호,비트규칙)가 다르기 때문에 다양한 cpu에서<br>
실행할 수 있는 명령어를 작성하기 매우 힘들다
<br>
<br>
2. 직접 기계어로 작성하는 대신 간결한 영어로 이루어진 명령어 사용 (assembly) <br>
- assembly언어를 기계어로 바꿔주는 프로그램을 compiler 라고 한다
<br>
<br>
- 명령어가 영어단어와 비슷해서 작성이 편하다
<br>
- compiler가 각각의 기계어로 번역해주기 때문에 cpu마다 명령어를<br> 
다르게 작성 할 필요가없다
<br>
<br>
3. C 인간 친화적인 프로그래밍 언어로 명령어 작성하기
<br>
<br>
-명령어를 만들고 각각 compiler 로 기계어로 바꾼후 각 cpu와<br>
 운영 체제에 알맞게 맞춰야한다
 <br>
-예전 프로그램 공유 문화 명령어 소스코드를 그대로 공유하여<br>
 각 cpu에 맞게 컴파일 했다
<br>
-linux는 컴파일러가 기본 내장
<br>
-c컴파일 +OS 적용 명령 사용<br>
DirextX 명령은 windows 전용 따라서 다른 운영체제를 사용하면<br> 
컴파일할 수 없다 
<br>
<br>
<strong>프로그래밍 언어 와  컴파일러</strong>
-언어선택
<br>
프로그래밍언어마다 특장점이 있다<br>
->프로젝트 성격에 따라 언어 선택<br>
-인공지능,머신러닝,딥러닝 : python <br>
web app : haba,php,go <br>
web ui : JAVAscript,typescript
<br>
<br>
<strong>컴파일 방식과 인터프리트 방식</strong>
<br>
컴파일 방식 : c언어를 컴파일러로 os에 맞춰 기계어로 바꿔주고 OS에 저장 cpu에서 명령처리
- 실행할때 기계어 파일만 있으면 된다
- 소스파일 필요없다 -> 소스파일을보호(자산)
- 실행할때 컴파일러 불필요
- 기계어 바로실행 -> 실행속도 빠름
<br>
<br>
인터프리트방식 (viewe) : js를 JAVAscriptinterpreter (컴파일 하지 않음)  
- 실행할때마다 소스 파일 필요 -> 소스파일 공개 -> 자산으로 보호하기 힘들다
- 실행하려면 인터프리트 필요
- 명령어를 해석해서 실행 -> 실행속도 느리다
예) 
<br>
<br>
<strong>JAVAscript (interpreter)Engine</strong>
<br>
chrome에는 webkit html,css렌더링엔진 과 v8 javascript엔진 이 있다 <br>
v8을 이용해 node.js 를 만들엇다 웹 브라우저 없이 JAVAscript실행
<br>
<br>
<strong>JIT compile 과 AOT compile</strong>
<br>
1. plain 인터프리터: 매번 소스를 검사하고 해석하기 때문에 속도가 느리다
<br>
2. JIT (just in time) 컴파일: 실행하려는 일부 코드를 컴파일 -> 컴파일 <br>
할 때 잠깐 느려지지만 이후 실행할때 빨라진다
<br>
3. AOT (ahead of time) 컴파일: 설치 시점에 미리 전체 소스를 컴파일 해둔다 <br>
-> 설치시간이 좀 더 걸린다 -> 실행은 컴파일방식과 같다
<br>
- bytecode ="중간코드" = p-code : 진짜  기계어가 아니라 흡사한 코드
<br>
- 안드로이드를 자바로 개발하면 bytecode로 play store 에 올린다<br> 
다운 받을시 사용자의 cpu에 맞춰 컴파일 한다 
<br>
<br>
<strong>Web browser와 JAVAscript</strong>
<br>
<hr>
<br>
<h1>2022-12-02</h1>
<br>
<br>
<strong>OS,cpu,ram,HDD,기계어,명령문 관계도</strong>
<br>
<br>
1. 개발자가 명령문 작성 (instruction set)
<br>
- c,java등 인간친화용 언어로 명령문 작성<br>
- compiler 가 기계어로 번역<br>
<br>
2. HDD.SSD등 외장하드에 저장
<br>
3. 일부명령어를 실행하기 위해 ram으로 복사 (loading)
<br>
4. cpu로 보내 각 명령어를 처리<br>
<br>
- l1 명령어 임시 보관
<br>
- l2 data 임시 보관
<br>
- l3 data 멀티디어 , core끼리 공유
<br>
<br>
console.log(값,값,값,,);   <br>
웹브라우저에 개발자 보드 콘송함에를 값을 출력<br>
<br>
-console = 도구 = object (객체)
<br>
-log = 기능 = funcrion (함수)
<br>
-(값,값,값,,) = 기능을 수행하기위한 값 = argument (인자),parameter (파라미터)
<br>
<br>
<strong>변수와 값 할당</strong>
<br>
<br>
변수 선언 (variables)
<br>
갑을 저장할 메모리를 확보하는 명령문<br>
-> var,let,const
<br>
<br>
할당,대입 (assignment)
<br>
메모리에 값을 저장
<br>
-변수명 = 값; <br>
-변수명 = 변수명;<br>
-변수명 = 함수; <br>
= 을 assignment operator
<br>
변수=(변수 ,값,함수...) <br>
변수 (l-value) = 반드시 메모리여야한다 <br>
(변수 ,값,함수...) (r=value) 
<br>
<br>
<strong>for 반복문</strong>
<br>
<br>
<pre>
for (var i = 0; i < size; i++) {
  console.log(i, message);
  if (i == 5) {
    var working = true;
    break;
  }
</pre>
<br>
<br>
var i = 반복문을 실행하는 동안 사용하는 변수 주로 반복문에서 횟수를 제어하기위해 사용 <br>
i < size  = 반복문 횟수 지정 <br>
i++  =  값을 1씩 증가 <br>
<br>
<br>
<strong>function(함수)</strong>
<br>
특정 기능을 수행하도록 짜놓은 명령순을 묶어서 이름을 붙인것 필요할때 재실행 가능<br>
코드 재사용성을 높이는 문법
<br>
<br>
<pre>
function plus(a, b) {        <- 함수 정의 (definition)
  return a + b;
}

plus = 함수 이름
(a, b) = parameter             
a + b; = 실행 완료후 리턴 값

var sum = plus(100,200);       <- 함수사용법 호출 (call)


console.log(plus(10, 20)); 

ok = plus;
console.log(ok(100, 200));

var haha = ok;
console.log(haha(1000, 2000));

ok = "Hello";
ok(100, 200);

    
</pre>
<br>
<br>
<strong>함수레퍼런스</strong>
<br>
함수의 이름은 함수의 주소를 보관하고 있는 변수이다 
<br>
<strong>static type dinfing vs dynamic type dinfing</strong>
<br>
<pre>
dynamic type dinfing (짧은 코드 작은프로젝트) 
값을 넣을때 변수의 유형이 바뀐다 하지만 script 류의 프로그래밍 언어
자유분방하고 프로그래밍이 쉬워 유지보수가 어렵다 

javascript

var a;

a= 100;
a= "hello";
a= true;

static type dinfing (긴코드 큰 프로젝트)
언어 류의 프로그램 언어이고 엄격해 프로그래밍이 까다롭지만 유지보수가 쉽다

int a;

a= 10;
a= 20;
a= "hello"  (X)

인트로 지정해 문자는 불가능
</pre>

<br>
<br>
<pre>
객체 : 덩어리 (변수+함수+객체)

// 1) Object라는 원형 틀을 기반으로 기본 객체를 생성한다.
var obj1 = new Object(); // => HashMap<String,Object> obj1 = new HashMap<>();

// 기본 객체에 프로퍼티를 덧붙인다.
obj1.name = "홍길동"; // => obj1.put("name", "홍길동");
obj1.age = 20; // => obj1.put("age", 20);
obj1.working = true; // => obj1.put("working", true);
obj1.hello = function() {
  console.log("안녕하세요, " + this.name + "님!");
}; // => obj1.put("hello", 함수);

----------------------------------------------------------------
객체를 자바스크립트로 코드화한 것 (object literal)


var obj2 = {
  name:"임꺽정",
  age:30,
  working:true,
  hello:function() {
    console.log("안녕하세요, " + this.name + "님!")
  },
  hello2() {
    console.log("안녕하세요, " + this.name + "님2!")
  }
};
</pre>
<br>
<br>
literal (값을 코드로 표현한것)<br>
<br>
<br>
문자열 -> "abc"
<br>
숫자 -> 10
<br>
논리 -> true,false
<br>
변수의 값이 저장된 적이 없는 상태 -> undefined
<br>
객체 주소가 없는 상태 -> null
<br>
<br>
<strong>DOM API - getElementById()</strong>
<br>
태그를 다루는 프로그램을 짤 때 사용하는 도구
<br>
document <- HTML
<br>
boject <- 객체
<br>
model <- 구조로 만든것
<br>
<br>
DOMM
<br>
tag를 tree구조로 객체화 시킨것 tag를 찾고, 변경하고,추적,삭제하기 쉽도록 한것
<br>
<br>
API
<br>
application<br>
programming<br> 
intorface<br>
app을 프로그래밍 할때 사용하는 도구
<br>
<br>
<strong>객체와 함수(메서드=operator) , 파라미터의 관계</strong>
<br>
<br>
<pre>
document.getElementById("태그 아이디")
 ㄴ객체       ㄴ함수(일하는놈)    ㄴ함수가 기본데이터를 다룰때 사용할 값


예)

학생명단.find("홍길동")

학생명단 = 기본데이터
find = 작업 = 작업자 (operator)
홍길동 = 부가데이터
</pre>
<br>
ECMA스크립트란, Ecma International이 ECMA-262 기술 규격에 따라 정의하고 있는 표준화된<br>
스크립트 프로그래밍 언어를 말한다. 자바스크립트를 표준화하기 위해 만들어졌다. 액션스<br>
크립트와 J스크립트 등 다른 구현체도 포함하고 있다
<br>
ECMA스크립트는 ECMA-262에 의해 표준화된 언어의 이름이다.<br>
자바스크립트와 J스크립트는 모두 ECMA스크립트와의 호환을 목표로 하면서, ECMA 규격에<br>
포함되지 않는 확장 기능을 제공한다.
<br>
<strong>태그 찾기 -> 이벤트리스너 등록</strong>
<pre>
var tag1 = document.getElementById("btn1")

tag1.onclick = function() { // Observer 패턴: 리스너 => 이벤트 리스너 => 이벤트 핸들러 
=> 콜백함수(callback; cb)

  var tag2 = document.getElementById("p1");
  tag2.innerHTML = "비트캠프!";
};
사용자가 tag1을 클릭(onclick) 이라고 저장된 함수를 호출
innerHTML은 해당 함수에 등록된 태그의 내용을 바꿔준다
</pre>
<br>
<br>
<strong>요점 정리 - 5.HTML 태그와 DOM 트리 객체 응용</strong>
<pre>

  var inputNameIndex = 1;
  var btnAddName = document.getElementById("btnAddName");
  var inputNameContainer = document.querySelector("#inputNameContainer");
  var inputNameDiv = document.querySelector(".inputName");

  btnAddName.onclick = function() {
  inputNameIndex++;
  var e = inputNameDiv.cloneNode(ture);
  e.querySelector(".name").innerHTML = "이름" + inputNameIndex;
  e.querySelector("input").name = "name" + inputNameIndex;
  e.querySelector("input").value = "";
  inputNameContainer.appendChild(e);

</pre>
<br>
<br>
<strong>웹페이지 조립</strong>
<br>
<br>
서버에 자원을 요청
<br>
1. server-side rendering <br>
서버에서 HTML을 만들어준다(JSP,thymleaf) 
<br>
<br>
2. client-side rendering <br>
클라이언트에서 HTML을 만든다(reect,)
<br>
<br>
<strong>JSON 포맷</strong>
<br>
<pre>
var obj = {
  "name": "홍길동",
  "age": 20,
  "working": false,
};
</pre>
<br>
javascript의 object literal 을 참조해 만듬
<br>
<br>
과제 : 틱택토 만들기 12-04일 저녁 10시까지
<br>
<hr>
<br>
<h1>2022-12-05</h1>
<br>
<pre>
ohora>헐.../ohora>


script type="text/plain">
  // script의 type 속성이 "text/javascript"로 설정되어 있지 않으면
  // 웹브라우저는 이 태그의 값을 무시한다.
  // => 화면에 출력하지는 않으면서 특정 목적으로 이용할 때 종종 이런 방식을 사용한다.
  // 예) Handlebars 라이브러리
  console.log("Hello, world!");
  // type 속성의 값으로 보통 MIME 타입을 지정한다.
  // MIME(Multi-purpose Internet Mail Extensions) 타입
  // => 이메일의 콘텐트 타입을 지정하는 용도로 등장하였다.
  // => 현재는 이메일 뿐만아니라 웹 콘텐트의 타입을 지정할 때도 사용된다.
  // => 대중적으로 널리 알려진 포맷에 대해서는 MIME 타입의 이름이 결정되어 있다.
  /script>
</pre>
<br>
<br>
// 웹브라우저는 HTML을 로딩한 후 위에서 아래로 태그가 나온 순서대로 실행한다.<br>
// 실행하다가 script라는 태그를 만나면 "자바스트립트 엔진"을 이용하여 코드를 실행한다. <br>
// script 태그 실행이 완료되면 계속 이어서 다음 태그를 처리한다.
<br>
<br>
<strong>객체와 함수</strong>
<br>
<br>
document.getElementById("btnl") 
<br>
document<br>
객체,함수가 작업할 때 사용하는 기본 데이터
<br>
getElementById<br>
함수,작업을 수행(operator=function=method)
<br>
("btnl")<br>
파라미터,작업을 제어하는 데이터 (parametor=argument)
<br>
<br>
window.alert("hello, world");
<br>
<br>
window<br>
객체, 도구함
<br>
alert<br>
함수, 도구
<br>
("hello, world")<br>
파라미터, 기능 수행에 필요한 데이터
<br>
<br>
<strong>*코드 실행 순서</strong>
<br>
<br>
<strong>인터프리트 방식과 커파일 방식</strong>
<br>
<br>
인터프리터 <br>
명령문을 한줄씩 읽어 인터프리터에서 실행한다 만약 명령문이 잘못작성되었어도 실행<br>
하기전까지 알 수 없다 
<br>
<br>
컴파일 <br>
명령문 전부를 컴파일러가 컴파일하여 기계어로 번역한다 만약 명령문이 잘못되었으면 컴파 <br>
일 과정에서 모두 걸러진다 따라서 문법오류는 없는 상태이다
<br>
<br>
// script 태그 안에 있는 자바스크립트를 실행하는 중에 오류가 발생하면 <br>
// 즉시 script 태그의 실행을 중단하고 다음 태그로 간다. <br>
<br>
<br>
<pre>
예전에는 script 태그를 head 태그 안에 두었다.
그 시절에는 실행할 자바스크립트 코드의 양이 많지 않았기 때문에
HTML 본문을 출력하기 전에 자바스크립트를 두어도 괜찮았다.
그러나 최근에는 사용자의 다양한 행위와 동적인 화면을 지원하기 위해
자바스크립트 코드의 양이 굉장히 많아 졌다.
그래서 head 태그에 있는 자바스크립트를 실행하는 동안
body 태그의 내용은 화면에 출력할 수 없기 때문에
화면 출력이 느려지게 되었다.
이런 이유로 사용자가 지루해 하지 않도록 하기 위해
일단 화면의 일부를 출력한 후 자바스크립트를 실행하도록
script 태그를 body의 맨 끝에 두는 게 요즘 경향이다.

예전에는 스크립트 태그를 head안에 넣엇지만 점점 코드의 양이 많아지면서
body 맨끝에 두는게 요즘 트렌드이다 
</pre>
<br>
<br>
<strong>Promise</strong>
Asynchronous (비동기) <br>
자바스크립트의 비동기 처리란 특정 코드의 연산이 끝날 때까지 코드의 실행을 멈추지 않고 <br>
다음 코드를 먼저 실행하는 자바스크립트의 특성을 의미한다 만약 처리해야할 코드가 많은데 <br>
연산이 끝날 때 까지 기다릴 수는 없기 때문에 나머지 코드부터 먼져 실행한다 <br>
<br>
-script태그는 바디 맨 끝에 두는게 좋다 
<br>
<br>
<pre>
  const express = require('express')
const app = express()
const port = 3000

app.get('/exam05_1', async (req, res) => {
  await new Promise(resolve => setTimeout(resolve, 10000));
  express.send('console.log("exam05_1 ok!");')
})

// 위에서 같이 사용하려면 async라고 지정을 해주고 awsit을 사용해야한다
이 코드가 동일하게 실행하지 않는다는 것을 알려줘야 한다 

app.get('/exam05_2', (req, res) => {
  res.send('consloe.log("exam05_2 ok!");')
})

app.get('/exam05_x', async (req, res) => {
  await new Promise(resolve => setTimeout(resolve, 10000));
  res.send('var rate = 30000;')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})
</pre>
<br>
<br>
자바스크립트의 변수는 "동적 타입 바인딩(dynamic type binding)"이다<br>
변수를 넣으면 그 변수에 맞게 타입이 적용된다
<br>
<br>
script 태그를 실행할 때 변수나 함수가 선언된 위치에 상관없이 선언 문을 먼저 실행한다<br>
// 그래서 변수 선언이나 함수 선언을 끌어 올린다는 의미로 "hoisting"이라는 표현을 쓴다. <br>
hoisting은 현재 태그에 선언된 변수나 함수에 대해서만 수행한다.
<br>
<br>
<strong>var 변수와 블럭</strong>
<br>
<br>
1.global 변수<br>
-window 객체 소속
<br>
2. 함수 변수<br> 
-함수를 실행하는 동안 생성<br>
-함수 내에서만 실행
<br>
<br>
<strong>let 변수 와 블록</strong>
<br> 
<br>
let <br>
블록 영역에 종속 : 블록에 진입 할때 생성 , 블록을 나가면 삭제 
<br> 
<br>
const 
<br>
initializer <br>
-변수 선언과 동시에 값을 할당해야 한다  
<br>
<br>
var v2 = 100; // f1() 함수에서만 사용되는 로컬 변수이다.
<br>
스택 메모리에서 관리하기 때문이다
<br>
->메모리의 스택(stack) 영역은 함수의 호출과 관계되는 <br>
지역 변수와 매개 변수가 저장되는 영역이다
<br>
<br>
함수 안에서 같은 이름에 글로벌 변수를 사용하고 싶다면 window.을 붙이면 로컬에서도 <br>
글로벌 변수를 사용할 수 있다
<br>
<br>
<strong>여러개의 변수를 손쉽게 만드는 문법(배열) 만들기</strong>
<pre>
// 배열 만들기
// 1) new => 빈 객체를 만든다.
// 2) Array() 호출
//    => Object() 호출
//        => 객체에 필요한 최소한의 변수나 함수를 추가한다.
//        Array()를 호출했는데 Object()가 호출되는 이유:
//        => 자바의 상속처럼 Array() 생성자는 Object() 생성자를 상속받기 때문이다.
//        => 그래서 Array()를 호출할 때 상위 생성자인 Object()가 먼저 호출되는 것이다.
//    => 배열 관리에 필요한 변수나 함수를 기본 객체에 추가한다.
var arr = new Array(); // 빈 객체 생성 => Object()로 기본 변수와 함수를 준비 => Array()를 실행하여 배열에 필요한 변수나 함수를 추가

1. new -> 빈 객체 생성
2. Array -> 배열관리에 필요한 변수,함수 추가
3. arr.push() -> 배열의 값 추가 -> length 도 증가 
</pre>
<br>
<br>
<strong>인덱스 0 과 메모리 주소</strong>
<br>
<br>
<pre>
arr 의  217 = 217+0 = [0]
        218 = 217+1 = [1]
        .
        .
</pre>
<br>
메로리 시작 주소를 가지고 배열의 항목을 가리키기 때문에 <br>
인덱스 0 부터 시작한다 
<br>
<br>
<strong>변수 - 배열을 만드는 단축 문법</strong> 
<br>
<br>
var arr = ["aaa", "bbb", true, 100, new Object(), function() {}];
<br>
배열을 대괄호로 묶어준다, 자바스크립트는 타입상관없이 배열을 구성할 수 있다
<br>
<br>
<strong>##틱택토 게임 구현방법을 ppt로 5분안에 설명하시오.</strong>
<br>
<br>
변수 사용
<br>
1.const -> 2.let -> 3.var 순서로 사용 <br>
const로 지정한 값을 바꾸고 싶다면 let을 사용하여 바꾸고 변수들 끼리 공유를 하고싶다면 <br>
var를 사용하여 순서대로 이용하여야 한다
<br>
<hr>
<br>
<h1>2022-12-06</h1>
<br>
<br>
<strong>문법</strong>
literal<br>
값을 표현하는 문법 <br>
예) "aaa", 'aaa', 10 ,3.14 , true,false 등
<br>
variables<br>
값을 저장하는 메모리를 준비하는 문법<br>
예)var/let/const/[]
<br>
제어문
<br>
1. 분기문<br>
-if~else<br>
-switch
<br>
2. 반복문<br>
-whrle<br>
-for
<br>

<br>
<br>
<strong>연산자 - 산술연산자</strong>
<br>
<br>
y = 100
<br>
y<br>
100<br>
1.r-value 를 모두 수행<br>
2. = 연산수행
<br>
++,-- 연산자는 *,/,% 보다 우선한다
<br>
<br>
console.log("100" == 100); //==연산전에 숫자 100을 형변환후 비교 <br>
console.log("100" === 100);//=== 두 피연산자가 같은 타입이고 값이 같을 때 true이다
<br>
<br>
<pre>
console.log("100" == 100); //==연산전에 숫자 100을 형변환후 비교
console.log("100" === 100);//=== 두 피연산자가 같은 타입이고 값이 같을 때 true이다
console.log("100" != 100) //false 두 피연산자를 비교하기전에 100을 "100" 으로 형변환후 비교한다
console.log("100" !== 100)// 두 피연산자의 데이터 타입이 다르기 때문에 값을 비교할 필요가 없이 다르다

console.log("--------------------------");

console.log(100 < 200);
console.log(100 <= 200);
console.log(100 > 200);
console.log(100 >= 200);
console.log("---------------------------");

//문자열을 비교할떄 문자 코드 값을 비교한다

console.log("AB" > "AC");    false
console.log("a" > "A");      true 
console.log("똘" < "똠");    true
console.log("---------------------------");
</pre>
<br>
<br>
<strong>리터럴(literal) - 숫자 진수 표현법</strong>
<br>
<br>
<strong>연산자 - 비트연산자</strong>
<br>
<br>
<pre>
// AND: 두 비트가 1일 때 1, 그외 0
// -두 비트가 1 일 때 1, 그 외 0
// -1 로 설정한 비트의 값은 그대로 통과하는 효과가 있다.
// - 특정비트의 값만 추출 할 때 활용한다

console.log((a & b).toString(2)); // 1100000


console.log("-----------------------------");

// 응용 1
// - 색상 값에서 빨강 색을 제거하기
// - 예) 사진에서 빨강색 제거 
let color = 0xFF00FF; // 보라색
console.log((color & 0x00FFFF).toString(16));// 0000FF

//OR 비트 연산자 
// - 두 비트 중에 한 개라도 1이면 결과는 1, 그 외 0
// -AND 비트 연산자와 반대로 동작
// - 0 비트는 그대로 통과, 1비트는 기존 값 제거
console.log((a | b).toString)


// 응용 
// -특정 색상을 강화하기 
// -예) 빨강색 강화하기
color = 0x283386;
console.log(color.toString(2));
console.log((color | 0x550000)); // 빨강색 강화 : 01010101
//기존 빨강색 : 00101000
//강화 : 01010101
//--------------
//변경된 색상 : 01111101
console.log("-----------------------------");


// XOR(exclusive OR) 비트 연산자
// - 두 비트의 값이 다를 때 1, 같으면 0
console.log((a ^ b).toString(2));
// a: 01100100
// b: 11110000
// ----------
// 10010100
console.log("-----------------------------");


// NOT 비트연산자
console.log((~a).toString(2));
// a : 01100100
//------------------
// ~ : 10011011
console.log("-----------------------------");


// << 비트 이동 연산자
// -왼쪽으로 지정한 비트만큼 이동시킨다
// -오른쪽의 빈자리는 0으로 채운다
// -1 비ㅡㅌ 이동할 때마다 2*한 효과가 있다
// -* 2 연산을 수행하는 것 보다 비트이동 연산자가 실행속도가 빠르다
// - n 비트 이동 = 값 * 2**n
a = 7; // 0000111
console.log((a * 2).toString(2)); //  (14)
console.log((a >> 2).toString(2));// 1110 (14)
console.log((a * 4).toString(2)); //  (28)
console.log((a << 2).toString(2));// 1110 (28)
console.log((a * 8).toString(2)); //  (56)
console.log((a << 3).toString(2));// 111000 (56)
console.log("-----------------------------------");


// >> 비트 이동 연산자
// -오른쪽으로 지정한 비트만큼 이동시킨다
// -왼쪽의 빈자리는 부호비트(양수:0,음수는:1)로 채운다
// -1 비트 이동할 때마다 /2한 효과가 있다
// - / 2 연산을 수행하는 것 보다 비트이동 연산자가 실행속도가 빠르다
// - n 비트 이동 = 값 / 2**n
a = 100; // 01100100
console.log((a / 2).toString(2)); // 50
console.log((a >> 2).toString(2));// 0110010|0 (50)
console.log((a / 4).toString(2)); // 25
console.log((a >> 2).toString(2));// 011001|00 (25)
console.log((a / 8).toString(2)); // 12.5
console.log((a >> 3).toString(2));// 01100|100 (12)
// 50 : 0011 0010
// -50: 1100 1110
a = -100;   // 
console.log(a >> 1);  // -100
console.log((a >> 1).toString(2)); // -50 
console.log("-----------------------------------");


// >> 비트 이동 연산자
// -오른쪽으로 지정한 비트만큼 이동시킨다
// -왼쪽의 빈자리는 0으로 채운다. 음수를 비트이동하면 양수로 바뀐다
// -양수인 경우 1 비트 이동할때마다 /2한 효과가 있다
// -양수인 경우, n 비트 이동 = 값 /2**n
a = 100;
console.log(a >>> 1);
console.log((a >>> 1).toString(2));

a = -100;              // 
console.log(a >>> 1);  // 2147483598
console.log((a >>> 1).toString(2)); 

</pre>
<br>
<br>
<strong>이미지와 바이트 수</strong>
<br>
<br>
1. 흑백 사진 각 비트값 -> 0: 검은색 ,1: 흰색<br>
-> 1픽셀 = 1bit
<br>
<br>
2. 칼라사진 1픽셀크기: RGB 3byte<br>
-> 9픽셀크기 = 27byte
<br>
<br>
3. HD급 = 2,073,600픽셀 = 6,220,800byte<br>
천만화소 를 관리하기 쉽게 압축 <br>
-손실압축 (JPEG)<br>
-비손실압축 (GIF)<br>
압축 해제시 -> 비트맵 -> 출력가능
<br>
<br>
<strong>프로그래밍 트렌드</strong>
<br>
<br>
1. 절차적 프로그래밍 (기능들의 덩어리를 그룹화 하는것)<br>
예)basic,
<br>
<br>
2. function<br>
예)c,code,<br>
명령어를 기능단위로 묶는다<br>
-관리용이<br>
-재사용<br>
-가독성
<br>
<br>
3. class<br>
예)c++,java<br>
클레스로 묶어 코드 덩어리로 만든다<br>
-기능이 많아지고 함수가 많아진다 함수를 역할단위로 묶는다<br>
-관리용이<br>
-재사용<br>
-가독성
<br>
<br>
4. package<br>
클레스가 계속 많아져서 그룹으로 묶음
<br>
<br>
5.module<br>
페키지를 묶은것
<br>
<br>
<strong>Data() 생성자</strong>
<br>
<br>
1. new <br>
2. object <br>
3. data()<br>
=> 객체 생성
<br>
new HTMLButtonElement()
<br>
instanceof<br>
객체를 초기화 시키는지 확인한다
<br>
<hr>
<br>
<h1>2022-12-07</h1>
<br>
<br> 
<strong>반복문 for</strong>
<br>
<br>
<pre>
for (변수선언및초기화; 조건 ;변수값증감) {
  ...
}

배열
const arr = new Array();
</pre>
<br>
Array <br>
빈객체에 용도따라서 필요한 변수와 함수들을 채워넣는 아주 특별한 함수 "생성자(constructor)"<br>
객체가 자신의역할을 제대로 수행할 수 있도록 필요한 값과 함수를 준비하는 일을 한다
<br>
<br>
<strong>배열과 destructuring</strong>
<br>
destructuring 문법을 사용하여 key와 value를 분해하여 받는다.
<br>
<br>
<pre>
let a = ["name", "홍길동"];

let key = a[0];
let value = a[1];
//
key = name
value = 홍길동
->
let [key, value] = ["name", "홍길동"]
</pre>
<br>
<br>
<strong>구조 분해(destructuring) - 배열</strong>
<br>
<br>
<pre>
  // 값을 분해하여 여러 변수에 받을 수 있다.
  //
  var arr = ["홍길동", "1111-2222", true, 20];
  console.log(arr);
  
  // 보통 한 개의 변수에 한 개의 값을 받는다.
  var n = arr[0];
  var t = arr[1];
  var w = arr[2];
  var a = arr[3];
  console.log(n, t, w, a);
  console.log("----------------");
  
  // 배열의 값을 분해해서 받을 수 있다.
  var [name, tel, working, age] = arr;
  console.log(name, tel, working, age);
  console.log("----------------");
  
  // 배열 개수 보다 적은 변수를 선언하면 그 변수 개수만큼만 분해해서 받는다.
  var [name2, tel2] = arr;
  console.log(name2, tel2);
  
</pre>
<br>
<br>
<strong>구조 분해(destructuring) - 객체</strong>
<br>
<br>
<pre>
  var obj = new Object();
obj.name = "홍길동";
obj.age = 20;
obj.tel = "1111-1111";
obj.working = true;

// 객체에서 값을 여러 변수에 분리하여 담을 때는 
// 객체의 프로퍼티 이름과 같은 이름으로 변수를 선언한다.
// => 분해 변수의 이름과 일치하는 프로퍼티 값을 넣어준다.
var {tel, name, age, gender} = obj;
console.log(name);
console.log(age);
console.log(tel);
console.log(gender); // 객체에 지정된 이름의 프로퍼티가 없다면 undefined 이다.

</pre>
<br>
<br>
<strong>구조 분해(destructuring) - 객체 II</strong>
<pre>
  var obj = new Object();
  obj.name = "홍길동";
  obj.age = 20;
  obj.tel = "1111-1111";
  obj.working = true;
  
  // 객체에서 특정 프로퍼티 값을 분리하여 받은 후에
  // 나머지 값을 별도의 객체에 담아서 받고 싶다면
  // {변수1, 변수2, ...나머지값받을변수}
  var {age, tel, ...other} = obj;
  console.log(age);
  console.log(tel);
  console.log(other);
  console.log(other.name);
  console.log(other.working);
</pre>
<br>
<br>
<strong>구조 분해(destructuring) - 함수 리턴 값</strong>
<br>
<br>
<pre>

function f1() {
  return ["홍길동", 100, 90, 80, 270, 90];
}

var r1 = f1();
console.log(r1);
console.log(r1[0], r1[1], r1[2], r1[3]);



// 함수의 리턴 값이 배열이기 때문에
// 배열을 값을 destructuring 하는 문법은 같다.
var [name, kor, eng, math] = f1();
console.log(name, kor, eng, math);
console.log("-----------------------");

// 배열의 중간 값을 건너 뛰고 변수에 받을 수 있다.
var [name,,,,sum,aver] = f1();
console.log(name, sum, aver);
</pre>
<br>
<br>
<strong>구조 분해(destructuring) - 함수 리턴 값 II</strong>
<br>
<br>
<pre>
  function f2() {
    var obj = new Object(); 
    obj.name = "홍길동"; 
    obj.age = 20;
    obj.tel = "1111-1111";
    obj.working = true;
    return obj;
  } 
  
  // 보통 다음과 같이 함수가 리턴한 객체를 통째로 받는다.
  // 실제 객체 주소를 받는다.
  var r2 = f2();
  console.log(r2);
  console.log("------------------------");
  
  // 리턴 받은 객체에서 값을 꺼낼 때 
  // 프로퍼티와 일치하는 이름의 변수를 선언하면 된다.
  var {tel, age} = f2();
  console.log(tel, age);
</pre>
<br>
<br>
<strong>변수 -const</strong>
<br>
<br>
<pre>
// var 로 선언한 변수는 값을 변경할 수 있다.
var v1 = 100;
v1 = 200;
console.log(v1);

// const로 선언한 변수는 값을 변경할 수 없다.
const v2 = 100;
//v2 = 200; // 예외 발생!
console.log(v2);

// const 변수는 선언할 때 값을 할당해야 한다.
// const v3; // 예외 발생!
// v3 = 100;
// console.log(v3);
console.log("---------------------------");

const v4 = "오호라";
console.log(v4);
console.log(window.v4); // const 변수는 window 객체에 보관되지 않는다.
</pre>
<br>
<br>
<strong>변수 - const 객체</strong>
<br>
<br>
<pre>
  var v1 = new Object();
  v1.name = "홍길동";
  v1.age = 20;
  v1.tel = "1111-2222";
  console.log(v1);
  
  v1 = new Object();
  console.log(v1);
  
  // const 변수에 객체를 할당한다면,
  // => 실제로 객체의 주소가 할당되는 것이다.
  // 변수를 다른 객체의 주소로 변경할 수 없지만,
  // => 그 변수가 가리키는 객체에 대해서는 변경할 수 있다.
  // 즉 const 로 선언한 변수는 변수의 값만 못 바꾼다는 것이다.
  const v2 = new Object();
  v2.name = "홍길동";
  v2.age = 20;
  v2.tel = "1111-2222";
  console.log(v2);
  
  // const 변수의 값은 변경할 수 없다.
  v2 = new Object(); // 예외 발생!
  
  // 그러나 const 변수가 가리키는 객체의 프로퍼티는 바꿀 수 있다.
  v2.name = "임꺽정";
  v2.working = true;
  console.log(v2);  
</pre>
<br>
<br>
<strong>변수 - let</strong>
<br>
<br>
<pre>
  var v1 = "홍길동";
  {
    var v1 = "임꺽정"; // 기존 변수의 값을 변경한다.
    var v2 = 20; // 새 글로벌 변수를 추가한다.
  }
  console.log(v1, v2);
  console.log("--------------------");
  
  var v3 = "홍길동";
  {
    // let으로 선언한 변수는 사용 범위가 블록으로 한정(block-scoped)된다.
    let v3 = "임꺽정"; // 새 로컬 변수이다. 글로벌 변수가 아니다.
    let v4 = 30; // 새 로컬 변수이다. 글로벌 변수가 아니다.
    console.log(v3, v4);
    
  }
  console.log(v3); // OK
  //console.log(v4); // let으로 선언한 변수는 그 블록을 벗어나면 사용할 수 없다.
  console.log("--------------------");
  
  let v4 = "오호라";
  
  console.log(v4); 
  console.log(window.v4); // let 으로 선언한 변수는 window 객체에 보관되지 않는다.
</pre>
<br>
<br>
<strong>변수 - let II</strong>
<br>
<br>
<pre>
  // if, for 등의 블록에서 var로 선언한 변수는 글로벌 변수이다.
  for (var i = 0; i < 5; i++) {
    console.log(i);
  }
  console.log("==>", i);
  console.log("==>", window.i);
  
  console.log("--------------------")
  
  for (let x = 0; x < 5; x++) {
    console.log(x);
  }
  // for 블록 안에서 let으로 선언한 변수는
  // for 블록을 벗어나면 자동으로 제거되기 때문에 사용할 수 없다.
  console.log("==>", x);
</pre>
<br>
<hr>
<br>
<h1>2022-12-08</h1>
<br>
<br>
<strong>function</strong>
<br>
<br>
<pre>
function 함수명 (파라미터, . . . ) {
   ㄴ> 
  명령문;
  return 표현식(expresstion: 값을 리턴하는 문장);
  // 리터럴: "aaa", 20 ,true...
     변수 : a,score,sum...
     식 : a+"hello", a*2...
}

함수호출(함수 실행시키는 명령)
함수명(값,값,...)
값 = 아규먼트(argument)

function f4(a, b) { // 파라미터도 있고, 리턴 값도 있는 함수
	return a + b;
}

console.log(f4(10, 20));
console.log("----------------");
// 10 + 20 =30
</pre>
<br>
<br>
<strong>아규먼트와 파라미터</strong>
<br>
<br>
<strong>함수 - 함수 아규먼트와 함수 내장 변수 arguments</strong>
<br>
<br>
<pre>
// 자바스크립트의 함수는 함수를 호출할 때 전달한 값들을 보관하는 배열과 유사한 변수를 내장하고 있다.
// => 그 내장 변수의 이름은 "arguments" 이다.

function f1(a) {
	console.log("a =", a);
	console.log(arguments); // arguments 에는 넘어 오는 모든 값이 저장되어 있다.
}

f1();
console.log("----------------");

f1(100);
console.log("----------------");

f1(100, 200, 300, 400);
console.log("----------------");

function f2(a) {
	for (var i = 0; i < arguments.length; i++) {
		console.log(arguments[i]);
	}
}
f2(100, 200, 300, 400);
console.log("----------------");

function f3(a) {
  for (var value of arguments) {
    console.log(value);
  }
}

f3(100, 200, 300, 400);
console.log("----------------");

function f4(a) {
  for (var i in arguments) {
    console.log(arguments[i]);
  }
}

f4(100, 200, 300, 400);
console.log("----------------");
</pre>
<br>
<br>
<strong>함수 - 함수와 window 객체</strong>
<br>
<br>
<pre>
  // 함수도 var 변수와 같이 자동으로 window 객체에 소속된다.
  function f1(str) { 
    console.log(str);
  }
  
  window.f1("안녕1");
  f1("안녕2"); // window. 을 생략할 수 있다.
  
  // 함수나 변수나 객체 입장에서는 그냥 프로퍼티이다.
  // 따라서 프로퍼티 값을 가리키는 다음 문법을 그대로 사용할 수 있다.
  // => 객체["프로퍼티명"]
  // => 객체['프로퍼티명']
  // 
  window["f1"]("안녕3"); // f1 이름으로 저장된 함수 주소를 가져와서 호출한다.
  
  // 함수의 주소를 값처럼 다룰 수 있다.
  // 즉 다른 변수에 저장하여 사용할 수 있다.
  var ohora = window.f1; 
  ohora("안녕4"); // 함수 주소를 갖고 있는 변수는 함수처럼 사용할 수 있다.
</pre>
<br>
<br>
<strong>함수 - 함수와 레퍼런스</strong>
<br>
<br>
<pre>
function f1() {---}
f1 ()
f2 = f1;

두 함수는 주소가같고 함수도 객체이기 때문에 객체처럼 사용가능

</pre>
<br>
<br>
<strong>함수 - 익명 함수</strong>
<br>
<br>
<pre>
  // 예) a 변수에 문자열을 저장하면 문자열을 다루는 함수를 사용할 수 있다.

  let a = "가나다";
  console.log(a.indexOf("나"));
  
  // 예) a 변수에 배열을 저장하면 배열을 다루는 함수를 사용할 수 있다
  a = ["100", "200", "300", "400", "500"];
  let a2 = a.slice(1, 3);
  console.log(a2);
  
  
  // 즉 변수에 어떤 타입의 값을 저장하느냐에 따라
  // 그변수에 묶이는 함수가 달라짐
  // 이걸 다이나믹 함수라고한다

</pre>
<br>
<br>
<strong>함수 -  함수 호이스팅(hoisting)</strong>
<br>
<br>
<pre>
  script>
    // 함수도 변수처럼 함수 정의를 맨 먼저 실행한다.
    // => 즉 script 태그를 실행할 때 함수 정의가 있으면 제일 먼저 실행한다.
    // => 이렇게 함수를 정의한 코드를 맨 위로 끌어올린다 하여 "함수 호이스팅(hoisting)"이라 한다.
    //
    
    // 함수를 정의하기 전에 사용한다.
    // 그런데도 오류가 발생하지 않는 이유는 함수 정의가 먼저 실행되기 때문이다.
    f1();
    
    function f1() {
      console.log("안녕!");
    }
    
    /script>
    
    script>
    // 이전 스크립트 태그에서 정의한 함수나 변수가 window 객체에 보관되는 글로벌 함수나 변수라면,
    // 그 이후의 스크립트 태그 안에서 그대로 사용할 수 있다.
    f1();
    
    f2(); // 실행오류!
    // 현재 스크립트 태그가 아닌 다음 스크립트 태그에서 정의한 함수는
    // 호이스팅 대상이 아니다.
    // 호이스팅은 그 script 태그를 실행할 때 수행된다.
    // 따라서 아래에 f2() 함수는 아직 정의된 상태가 아니기 때문에 호출할 수 없다.
    /script>

</pre>
<br>
<br>
<strong>함수 -함수 호이스팅(hoisting)과 익명 함수</strong>
<br>
<br>
<pre>
  // 변수 선언과 그 변수의 값을 초기화시키는 할당문이 함께 있을 경우
  // 호이스팅 대상은 변수 선언만이 그 대상이 된다.
  //
  console.log(v1); // 아래에 선언된 v1 변수가 호이스팅 되기 때문에 사용할 수는 있다.
  
  var v1 = "홍길동"; // 변수 선언은 호이스팅 규칙에 따라 먼저 실행된다.
                   // 그러나 값을 할당하는 = 연산자는 현재 위치에 도달할 때 실행된다.
  console.log(v1);
  
  // 위의 규칙을 그대로 적용하여 다음을 이해해 보라!
  f1(); // 실행 오류! 
  
  var f1 = function() { // 위의 경우와 마찬가지로 현재 위치에 도달했을 때 익명 함수가 정의되어 그 주소가 f1에 저장된다.
      console.log("안녕!");
  };
  
  f1(); //OK! 현재 f1 변수에는 익명 함수의 주소가 들어 있다.

</pre>
<br>
<br>
<strong>함수 -아규먼트로 함수를 전달하기</strong>
<br>
<br>
<pre>
  // 함수는 객체이기 때문에 주소를 주고 받을 수 있다.
  // 
  
  // 함수 객체를 아규먼트로 넘길 때 
  // 보통 파라미터 이름을 fn 또는 cb(callback)로 한다.
  // "콜백(callback) 함수"
  // => 직접 호출하는 것이 아니라 다른 함수에게 파라미터 값으로 전달하여 
  //    호출되도록 만드는 함수.
  // 
  function play(cb) {
      console.log("계산 결과 =", cb(100, 200));  // 콜백 함수
  }
  
  function plus(a, b) {return a + b;}
  function minus(a, b) {return a - b;}
  
  play(plus); // 호출될 함수를 파라미터로 넘긴다. 그러면 play()가 호출해 줄 것이다.
  play(minus);
  
  // 생각해 볼 문제?
  // 다음은 콜백 메서드인가? 아닌가?
  function play2(v1, v2, op) {
    if (op == "+") {
      console.log(plus(v1, v2)); // 파라미터로 받은 함수를 호출하는 것이 아니기 때문에 콜백 함수가 아니다.
    } else if (op == "-") {
      console.log(minus(v1, v2)); // 파라미터로 받은 함수를 호출하는 것이 아니기 때문에 콜백 함수가 아니다.
    } else {
      console.log("해당 연산을 지원하지 않습니다.");
    }
  }
  
  play2(100, 200, "+");
  play2(100, 200, "-");
  
</pre>
<br>
<br>
<strong>함수 - 함수 리턴하기</strong>
<br>
<br>
<pre>
  // 함수는 객체이기 때문에 주소를 주고 받을 수 있다.
  //
  
  // 함수 안에서 함수를 만들어 리턴할 수 있다.
  function createInterestCalculator(type) {
      switch (type) {
      case "보통예금":
        return function(money, month) {return money + (money * 0.0011 * month);};
      case "정기예금":
        return function(money, month) {return money + (money * 0.0014 * month);};
      default:
        return function(money, month) {return money;};
      }
  }
  
  // createInterestCalculator() 함수가 리턴하는 것은 내부에서 정의한 함수의 주소이다.
  // => 이렇게 함수 안에서 정의한 함수를 '클로저(closure)'라 부른다.
  var fn = createInterestCalculator("정기예금"); 
  
  console.log("100억 7달 =", fn(10000000000, 7));
  
</pre>
<br>
<br>
<strong>함수 - 클로저(closure)와 바깥 함수의 로컬 변수</strong>
<br>
<br>
<pre>
  // 함수 안에 정의된 함수를 보통 클로저(closure)라 부른다.
  // => inner function, nested function 이라고도 표현한다.
  // => 클로저의 핵심 개념 
  //    closure에서 바깥 함수의 로컬 변수를 사용할 때, 
  //    바깥 함수의 호출이 끝나면 해당 로컬 변수가 제거되기 때문에
  //    클로저는 존재하지 않는 변수를 사용하는 상황이 발생한다.
  //    그래서 이런 경우를 방지하고자, 
  //    클로저에서 사용하는 바깥 함수의 로컬 변수는 클로저의 별도 메모리에 복제된다.
  //
  //
  
  function createGreeting(name) {
    var message = name + "님 반갑습니다!";
    
    // 클로저 만들기
    var f = function() {
      console.log(message); // 클로저에서 바깥 함수의 변수를 사용하기
      // 클로저가 바깥 함수의 로컬 변수를 사용하면,
      // 내부적으로 클로저 메모리에 같은 이름으로 그 값을 복제해 둔다.
      // 따라서 바깥 함수의 호출이 끝나 로컬 변수가 사라지더라도 영향을 받지 않는다. 
    };
    
    return f;
  }
  
  var test1 = createGreeting("홍길동");
  var test2 = createGreeting("임꺽정");
  
  test1();
  test2();


*closure
함수를 만들 당시 로컬변수로 변수를 지정하면 변수 수행후 로컬변수는 사라사라 진다

-> 바깥 함수의 로컬변수를 사용할때 발생하는 문제 해결법

closure를 만들때 클로저가 사용하는 바깥 함수의 로컬 변수가 있다면, 클로저의 별도
메모리에 복제해 두기때문에 바깥 함수의 message가 없어도 상관없다
매번 함수를 호출 할때마다 새로운 클로저를 생성한다
</pre>
<br>
<br>
<strong>함수 - 클로저(closure)와 바깥 함수의 로컬 변수2</strong>
<br>
<br>
<pre>
  // 함수 안에 정의된 함수를 보통 클로저(closure)라 부른다.
  // => inner functoin, nested function 이라고도 표현한다.
  // => 클로저의 핵심 개념 
  //    closure에서 바깥 함수의 로컬 변수를 사용할 때, 
  //    바깥 함수의 호출이 끝나면 해당 로컬 변수가 제거되기 때문에
  //    클로저는 존재하지 않는 변수를 사용하는 상황이 발생한다.
  //    그래서 이런 경우를 방지하고자, 
  //    클로저에서 사용하는 바깥 함수의 로컬 변수는 클로저의 별도 메모리에 복제된다.
  //
  //
  function closureMaker(fnType, count) { // 잊지말라 파라미터도 로컬 변수이다.
    switch (fnType) {
    case "sum":
        return function() { 
          // 이렇게 클로저를 정의하는 순간 클로저가 사용하는 바깥 함수의 로컬 변수 count는
          // 클로저가 관리하는 별도의 메모리에 복제된다.
          // 따라서 바깥 함수의 실행이 끝나 그 로컬 변수가 사라지더라도 
          // 클로저는 복제된 변수를 계속 사용할 수 있다.
            var sum = 0;     
            for (var i = 1; i <= count; i++) {
                sum += i;
            }
            console.log("합계 =", sum);
        };
    case "factorial":
          return function() {
            var sum = 1;
            for (var i = 1; i <= count; i++) {
                sum *= i;
            }
            console.log("팩토리얼 =", sum);
        };
    default:
        return function() {
          console.log("해당 연산을 지원하지 않습니다.");
      };
    }
  }
  
  var fn1 = closureMaker("sum", 10);
  var fn2 = closureMaker("factorial", 5);
  
  fn1();
  fn2();

//

</pre>
<br>
<br>
<strong>함수 - 클로저(closure)를 객체에 담아 리턴하기</strong>
<br>
<br>
<pre>
  function createBox() { 
    var value;
    
    var box = new Object();
    box.setValue = function(v) {
      // 이 클로저가 사용하는 value 변수는 바깥 함수의 로컬 변수이기 때문에
      // 클로저 메모리로 복사해둔다.
      value = v;
    };
    box.getValue = function() {
      // 함수가 호출될 때 함께 생성된 클로저는 메모리를 공유한다.
      // 따라서 setValue()와 getValue()가 사용하는 value 변수는  
      // 같은 변수이다.
      return value;
    };
    
    return box;
  }
  
  var box1 = createBox();
  var box2 = createBox();
  
  box1.setValue(100);
  box2.setValue(200);
  
  console.log(box1.getValue());
  console.log(box2.getValue());
  
  console.log(box1.value); //
  console.log(box2.value); // 



// 한번 호출에 생성된 쿨로저 들은 메모리를 공유한다 클로저로 복제한 변수는 클로저를
통해서만 접근할 수 있다
</pre>
<br>
<br>
<strong>함수 - 애로우(arrow) 함수</strong>
<br>
<br>
<pre>
  // 익명 함수를 정의할 때 arrow function 문법을 사용할 수 있다.
  // 문법:
  //    (파라미터,파라미터,...) => 문장
  //    (파라미터,파라미터,...) => {문장1; 문장2;}
  //
  //
  // 일반 함수
  function f0() {
     return "안녕";
  }
  console.log(f0());
  
  
  var f1 = function() {
    return "안녕";
  };
  console.log(f1());
  
  // 애로우(arrow ) 함수 : 초간단 함수 정의 문법
  // 1) function 키워드를 제거한다.
  // 2) 대신 파라미터 블록과 코드 블록 사이에 화살표를 추가한다.
  // 3) 다른 언어에서는 람다(lambda) 라고 부른다.
  var f2 = () => {
    return "안녕";
  };
  console.log(f2());
  
  // 3) 한 문장만 있을 때는 중괄호를 제거할 수 있다.
  // 4) 그 한 문장이 리턴 문장일 경우 return을 반드시 생략해야 한다.
  //    그리고 문장의 끝을 나타내는 세미콜론을 제거한다.
  // (한 문장 밖에 없으니까 가능한 한 줄로 표현하라!)
  var f3 = () => "안녕";
  console.log(f3());
  console.log("----------------------------------------");
  
  // 익명함수 정의 후 바로 호출하는 방법
  var f4 = function() {
    return "안녕";
  };
  console.log(f4());
  
  
  // 애로우 함수를 정의 하는 즉시 호출하기 
  var f5 = () => "안녕";
  console.log(f5());

  console.log((() => "안녕")());
  console.log("----------------------------------------");
  
  //

var plus = function(a, b) {
	return a + b;
};
console.log((function(a, b) {
	return a + b;
})(100, 200));

var plus = (a, b) => a + b;
console.log(((a, b) => a + b)(111, 222));


</pre>
<br>
<br>
<strong>함수 - 애로우(arrow) 함수</strong>
<br>
<br>
<pre>
  //일반
  function divide(a, b) {
    console.log(a / b);
  };
  divide(8, 5);
  
  
  //익명
  
  var divide = function(a, b) {
    console.log(a / b);
  };
  divide(8, 5);
  
  //익명한줄
  
  (function(a, b) {
    console.log(a / b);
  })(8, 5);
  
  //에로우
  
  ((a, b) => console.log(a / b))(8, 5);



</pre>
<br>
<br>
<strong>함수 - 애로우(arrow) 함수를 아규먼트로 전달하기</strong>
<br>
<br>
<pre>
  //배열의 forEach 사용하기

  let arr = [100, "홍길동", 3.14, "임꺽정", true];
  
  // 배열에서 값 꺼내기 
  // 1. 
  
  for (let i = 0; i < arr.length; i++) {
    console.log(arr[i]);
  }
  
  console.log("--------------------------");
  
  //2.
  
  arr.forEach(myfunction1);
  
  function myfunction1(value, index) {
    console.log("==>", value, index);
  }
  console.log("--------------------------");
  
  arr.forEach(myfunction2);
  
  function myfunction2(value, index) {
    console.log("-->", value, index);
  }
  
  console.log("--------------------------");
  
  arr.forEach((value, index) => console.log("-->", value, index));
  
</pre>
<br>
<hr>
<br>
<h1>2022-12-09</h1>
<br>
<br>
<strong>closure 리턴</strong>
<br>
<br>
함수를 호출하고 함수를 정의한다 그러면 따로 메모리안에 code segment와 <br>
data segment가 저장된다 이 함수를 부를 때는 이 주소를 보내준다 
<br>
<br>
<strong>함수 - 함수도 객체다</strong>
<br>
<br>
<pre>
  // 함수도 객체이기 때문에 프로퍼티를 추가할 수 있다.
  //
  function f1() {
      console.log("f1().....");
  }
  
  // 함수 = 객체 + 함수코드(파라미터, 리턴 값, 함수 몸체)
  f1(); // "f1 함수 객체에 저장된 함수 코드를 실행하라!"는 의미다.
  
  // 함수는 객체이기 때문에 일반 객체처럼 사용할 수 있다.
  f1.v1 = "홍길동";
  f1.v2 = 100;
  f1.v3 = true;
  f1.hello = function() {
    console.log("Hello!");
  };
  f1.hello2 = () => console.log("Hello2!");
  
  console.log(f1.v1);
  console.log(f1.v2);
  console.log(f1.v3);
  f1.hello();
  f1.hello2();
</pre>
<br>
<br>
함수명 ();<br>
-함수호출(function call)
<br>
f1. 프로퍼티(); <br>
- 앞에는 함수 주소를 주고 () 를 하면 안에 내용을 실행시킨다<br>
예) f1.hello();
<br>
<br>
<strong>자바스크립트 주요 함수 - setTimeout()</strong>
<br>
<br>
<pre>
  // 일정 시간이 경과한 후 특정 함수를 호출하게 할 수 있다.
  // => window.setTimeout(함수, 경과시간);

  // 사용법 1) 일반함수 외부에 호출될 함수를 정의하고 함수를 호출해 사용
  function f1() {
      console.log("f1().....")
  }
  
  console.log("-------------------");
  
  // f1() 함수를 5초 후에 호출해 달라고 등록한다.
  window.setTimeout(f1, 5000);
  
  // 사용법 2) 익명함수 사용
  // 실무에서는 함수를 파라미터로 전달할 때
  // 다음과 같이 익명 함수를 직접 파라미터 자리에 정의하는 방식을 사용한다.
  // window.setTimeout(function() {
  //     console.log("익명함수 호출...")
  // }, 10000);
  
  // 사용법 3) 에로우 함수 사용
  // window.setTimeout(() => console.log("애로우 함수 호출..."), 15000);
  console.log("일단 실행 끝!");
</pre>
<br>
<br>
<pre>
동기실행(synchronize)
-문장에 순서대로 실행이 끝나야 다음문장 실행
  
비동기실행(Asynchronize)
-문장을 실행 하고 다른 문장으로 바로 넘어간다 여기서 문제가 발생할 수 있다
window.setTimeout으로 시간이 걸리는 작업이 있는경우 이 함수작업이 끝난후 
적용을 시키켜야할 함수가 존재한다면  promise 사용으로 생성시점에 적용하지
않는 값들을위한 대리자이다

</pre>
<br>
<br>
<strong>자바스크립트 주요 함수 - setInterval()</strong>
<br>
<br>
<pre>
  // 일정 시간이 경과할 때마다 특정 함수를 반복적으로 호출할 수 있다.
  // => window.setInterval(함수, 경과시간);
  
  // => setInterval() 로 가동시킨 타이머를 멈추기
  // => window.clearInterval(타이머아이디);
  var count = 0;
  function f1() {
      console.log("f1()....." + (++count));
      if (count >= 10) {
       window.clearInterval(timerId); // 지정한 interval 타이머를 멈추게 한다.
      }
  }
  
  // f1() 함수를 2초 마다 호출하라!
  // => setInterval()을 통해 함수를 등록하면 리턴 값으로 등록 번호를 알려준다.
  // => 이 등록번호를 보관해 두었다가, 타이머를 멈추고 싶을 때 사용하면 된다.
  var timerId = window.setInterval(f1, 2000);
</pre>
<br>
<br>
<strong>자바스크립트 주요 함수 - eval()</strong>
<br>
<br>
<pre>
  // 자바스크립트 코드를 실행해주는 코드


  // 텍스트로 된 자바스크립트를 실행하는 함수
  //
  // => "실행" 버튼을 누르면 textarea 상자에 입력한 자바스트립트를 실행시키기
  //
  var ta = document.getElementById("ta");
  
  document.getElementById("btn1").onclick = () => {
    // input, textarea, select 등 입력폼 항목의 값을 꺼낼 때는
    // innerHTML이 아니라 value 프로퍼티를 사용해야 한다.
    var str = ta.value;
  
    // eval(자바스크립트코드)
    // => 이 함수는 파라미터로 주어진 자바스크립트 코드를 실행한다.
    eval(str);
  
    // eval()로 실행한 결과는 그래도 유지된다.
    // 따라서 eval()에서 자바스크립트 코드를 실행할 때
    // window 객체에 name 값을 넣으면
    // eval() 실행이 끝난 다음에도 그대로 유지된다.
    console.log("v1=", window.v1);
  };
</pre>
<br>
<br>
<strong>onclick 함수</strong>
<br>
<br>
태그객체.onclick = 함수주소;
-사용자가 마우스로 태그를 클릭하면 저장된 함수를 호출한다 callback = 이벤트리스너 = 핸들러
<br>
<br>
<strong>자바스크립트 주요 함수 - eval() II</strong>
<br>
<br>
<pre>
  // 객체를 생성하여 리턴 받기
  //
  // => "실행" 버튼을 누르면 textarea 상자에 입력한 자바스트립트를 실행하여
  //    객체를 리턴 받는다.
  // => 물론 입력 값은 자바스크립트 객체 생성 코드여야 한다.
  //
  var ta = document.getElementById("ta");
  
  document.getElementById("btn1").onclick = () => {
    var str = ta.value;
    var obj = eval(str); // JavaScript 객체 생성 코드를 실행한다. JSON과 다르다.
    //var obj = JSON.parse(str); // JSON 형식으로 된 자바스크립트 객체 생성 코드를 실행한다.
    console.log(obj);
  
    // 1) 단일 객체 생성
    // => 주의! 괄호 () 안에 객체 생성 문법인 중괄호{} 를 넣어야 한다.
    //    안 그러면 실행 오류이다!
    /* 입력 값 예)
    ({
    "name": "홍길동",
    "age": 20,
    "tel": "1111-1111"
    })
      */
  
      // 2) 배열 객체 생성
      // => 배열 코드는 괄호 안에 넣을 필요가 없다.
      /* 입력 값 예)
      ["홍길동", "임꺽정",100,true,null]
      */
  };
</pre>
<br>
<br>
<strong>자바스크립트 주요 함수 - JSON.parse(JSON형식문자열)</strong>
<br>
<br>
<pre>
  // 객체를 생성하여 리턴 받기
  //
  // => "실행" 버튼을 누르면 textarea 상자에 입력한 자바스트립트를 실행하여
  //    객체를 리턴 받는다.
  // => 물론 입력 값은 자바스크립트 객체 생성 코드여야 한다.
  //
  var ta = document.getElementById("ta");
  
  document.getElementById("btn1").onclick = () => {
    var str = ta.value;
    var obj = eval(str); // JavaScript 객체 생성 코드를 실행한다. JSON과 다르다.
    //var obj = JSON.parse(str); // JSON 형식으로 된 자바스크립트 객체 생성 코드를 실행한다.
    console.log(obj);
  
    // 1) 단일 객체 생성
    // => 주의! 괄호 () 안에 객체 생성 문법인 중괄호{} 를 넣어야 한다.
    //    안 그러면 실행 오류이다!
    /* 입력 값 예)
    ({
    "name": "홍길동",
    "age": 20,
    "tel": "1111-1111"
    })
      */
  
      // 2) 배열 객체 생성
      // => 배열 코드는 괄호 안에 넣을 필요가 없다.
      /* 입력 값 예)
      ["홍길동", "임꺽정",100,true,null]
      */
  };
</pre>
<br>
<br>
<strong>JSON.parse()</strong>
<br>
<br>
JSON형식의 문자를 javascript 객체를 생성하고 주소를 리턴한다 
<br>
1. javascript 객체리터럴 문법과 유사 => 이 문법을 참고해서 만든 포맷
2. 문자열은 "" 으로 표현
3. 프로퍼티면은 문자열로 표현
4. 함수 표현 안됨 => 값만 표현가능하고 다른객체 표현가능하다 
<br>
<br>
<strong>data 포맷 : binaty vs text</strong>
<br>
<br>
<pre>
  binary
  -바이트 단위로 규칙에 따라 저장한다
  읽을 때 바이트 규칙에 따라 읽는다
  특징
  1. 파일크기가 가장 작은 포맷이다
    - 데이터에 대한 부연 설명(meta data)이 없다
    - 바이트 저장 규칙을 모른다면 데이터를 제대로 읽을 수 없다
  2. 텍스트 편집기로 데이터를 제대로 볼 수 없다
</pre>
<br>
<br>
<pre>
  text
  특징
  1. 텍스트 에디터로 읽고 편집이 가능하다
  2. binary형식에 비해 파일 크기는 커진다

  -csv 방식
  예) 홍길동,20,true

    1. 간결하다
    2. 한줄에 한데이터
    3. 각항목의 정보가 없다 따라서 직접적으로 이해하기 어렵다
    4. 계층구조로 데이터를 다룰수 없다
  -텍스트 표현 규칙에 따라 저장한다

  -XML(extensible markup lenguage)
  예) <name>홍길동</name>

    1. 계층구조의 데이터 표현가능
    2. 각 항목의 의미를 표현가능 하여 특정 조건의 항목을 찾기 쉽다
    3. data보다 metadata가 더 클수있다 따라서 파일 크기가 크다

  -JSON(JAVAscript Object Notation)
  예) ({
    "name": 홍길동,
    "age": 20,
    "working": true
  })

    1. XML보다 더 간결한 metadata
    2. javascript와 유사 포맷이 익숙하다
  
  -YAML(yet another markup lenguage)
  예) name: 홍길동
      age: 20
      working: true
        -school:
          name: 비트초등
          state: 졸업
    
    1. JSON보다 더 간결
    2. 들여쓰기로 계층구조 표현
    
</pre>
<br>
<br>
<strong>자바스크립트 주요 함수 - JSON.stringify(자바스크립트객체)</strong>
<br>
<br>
<pre>
  // 자바스크립트 객체를 JSON 문자열로 바꾸로 싶을 때 사용한다.
  //      자바스크립트 객체  ===변환===> JSON 형식의 문자열
  // 용도:
  // => 웹브라우저에서 단순한 형식(name=aaa&age=20&tel=1111-1111)이 아닌
  //    데이터가 다른 데이터를 포함하는 복잡한 구조의 데이터를 서버에 보내고 싶을 때
  //    JSON 형식의 문자열로 만들어 보낸다.
  // => 서버는 클라이언트가 보낸 JSON 형식의 문자열을 자바 객체로 만들어 사용한다.
  //    물론 JSON 형식의 문자열을 다루는 자바 라이브러리가 많이 있다.
  //    자세한 것은 www.json.org 사이트를 보라!
  //
  var ta = document.getElementById("ta");
  
  document.getElementById("btn1").onclick = () => {
    let obj = new Object();
    obj.name = "홍길동";
    obj["age"] = 20;
    obj['tel'] = '111-2222';
    obj.plus = function(a, b) {return a + b;}; // 함수는 JSON 포맷으로 만들 때 제외된다.
  
    ta.value = JSON.stringify(obj);
  
  
  
  };
</pre>
<br>
<br>
<strong>함수 - 익명 함수와 호출</strong>
<br>
<br>
<pre>
  // 익명 함수를 정의하는 즉시 바로 호출할 수 있다.
  //
  //1) 일반적인 방법
  //=> 함수를 정의한 후 변수에 저장한다.
  //=> 그리고 그 변수 이름으로 호출한다.
  var f1 = function() {
      console.log("방법1....");
  };
  
  f1(); // 함수 호출
  f1(); // 함수를 별도로 정의하면 여러 번 호출할 수 있다.
  f1();
  console.log("------------------------");
  //2) 함수 정의 즉시 호출하기
  //=> (익명함수정의)(파라미터 값);
  //=> (익명함수정의(파라미터 값));
  //=> 딱 한 번만 호출할 때 유용하다.
  (function() {
    console.log("방법2....");
  })();
  
  (function() {
    console.log("방법3....");
  }());
  
  // 괄호를 생략하면 문법 오류이다.
  // function() {
  //   console.log("방법2....");
  // }();
  
</pre>
<br>
<br>
<strong>함수 - 익명 함수와 호출 II : 파라미터 전달하기</strong>
<br>
<br>
<pre>
  // 파라미터가 있는 익명 함수를 정의하고 즉시 호출해 보자! 
  //
  //1) 일반적인 방법
  //=> 함수를 정의한 후 변수에 저장한다. 
  //=> 그리고 그 변수 이름으로 호출한다.
  var f1 = function(a, b) {
      console.log("결과=", (a + b));
  };
  
  f1(100, 200); // 함수 호출
  f1(20, 30); // 함수 호출
  f1(15, 16); // 함수 호출
  console.log("--------------------------------------");
  //2) 함수 정의 즉시 호출하기
  //=> (익명함수정의)(파라미터 값);
  (function(a, b) {
      console.log("결과=", (a + b));
  })(200, 300);
  
  (function(a, b) {
      console.log("결과=", (a + b));
  }(200, 300));
</pre>
<br>
<br>
<strong>설계도 방식 과 프로토타이핑 방식</strong>
<pre>
1. 설계도 방식으로 객체 생성 (예: java,c++,,)
-추가못하는 방식
class Student {
  String name;
  int age;
  boolean working;
}

객체를 생성 

Student obj = new Student();   (stack type dinding)
메모리를 준비하고 주소를 저장
String name;
int age;
boolean working;
만 가능 

2. 프로토타이핑 방식으로 객체 만들기
-객체 원리들을 기반으로 프로퍼티를 추가하는 방법
-설계도 없음
var obj = new Object();
1. 빈객체 생성
2 기본프로퍼티추가 -> 객체라면 반드시 있어야 할 변수나 함수
obj.name = "홍길동"
obj.age = 20;
obj.working = true;
</pre>
<br>
<br>
<strong>객체 - 정의</strong>
<pre>
  //4) 위의 코드보다 더 간결한 방법.
  // => 객체 리터럴 문법을 사용하여 만들기
  var obj4 = {}; 
  console.log(obj4);
</pre>
<strong>과제</strong>
<br>
<br>
todo list 만들기
<br>
디렉토리 구조 
todo.html<br>
js/*.js<br>
css/*.css<br>
images/*.jpg,*.png,*.gif
<br>
<br>
참고해볼 자료
https://woojong92.tistory.com/entry/JS-%EB%B0%94%EB%8B%90%EB%9D%BC-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%A1%9C-ToDo-List-%EB%A7%8C%EB%93%A4%EA%B8%B0-1-%EA%B8%B0%EB%8A%A5%EC%A0%95%EC%9D%98-%EB%B0%8F-HTMLCSS
<br>
<hr>
<br>
<h1>2022-12-12</h1>
<br>
<br>
<strong>객체 생성</strong>
<br>
<br>
Object.create(null) -> 빈객체  =  new
<br>
Object.create(Object.protortype) = new Object() <br>
<br>
-> 1.빈객체 생성 <br>
2. protortype으로 지정된 생성자를 통행 기본 프로퍼티 추가 
<br>
<br>
<strong>생성자 (constructor)</strong>
<br>
<br>
new Object();
<br>
빈객체에 프로퍼티를 준비시키는 것
<br>
<br>
new: 빈객체 생성 <br>
Object(): 프로퍼티 추가
<br>
<br>
<strong>hasOwnProperty</strong>
<br>
개발자가 추가시킨 프로퍼티인지 검사<br>
console.log(obj.hasOwnProperty("toString")); -> false
<br>
obj.title = "---";<br>
obj.["content"] = "---";<br>
obj.plus1 = f1;<br>
obj.plus2 = () => {--};
<br>
console.log(obj.hasOwnProperty("title")); -> true
<br>
<br>
<strong>객체가 다른 객체를 포함하는 경우</strong>
<br>
<br>
let obj = new Object();
<br>
var obj2 = new Object();<br>
obj2.v1 = 100;<br>
obj2.v2 = true;<br>
obj2.v3 = "문자열";<br>
obj2.v4 = () => console.log("v4()....");
<br>
obj.other = obj2;
<br>
console.log(obj.other.v1); = 100
<br>
<br>
<strong>객체 - 객체에 소속된 함수가 같은 객체에 소속된 다른 멤버 사용하기</strong>
<br>
<pre>
this
함수가 소속된 객체의 주소를 나타낸다
여기서
this = obj 를 가리킨다
var obj = new Object();

obj.name = "홍길동";
obj.kor = 100;
obj.eng = 90;
obj.math = 80;

// toString()은 이미 객체에 들어 있는 함수이다.
// 다음은 기존 함수를 덮어 쓴다.
obj.toString = function() {
	// 자바와 달리 객체의 프로퍼티 변수를 사용할 때는 반드시 this를 붙여야 한다.생략하면 안된다.
	return name + "," + this.kor + "," + this.eng + "," + this.math;
};

*name은 window 등록된 객체이기때문에 this가 없어도 상관없다 다른 kor등은 window에 없어서 this가 있어야 한다
</pre>
<br>
<br>
<strong>객체 - {}을 이용하여 객체 생성하기 (객체리터럴 문법 object literal)</strong>
<br>
<pre>
  // {}은 기본 객체를 생성하는 단축 문법이다.
  // 즉 new Object()와 같다. 
  
  var obj = {}; //new Object();  
</pre>
<br>
<br>
<strong>객체 - {}을 이용하여 기본 객체에 프로퍼티 추가하기</strong>
<br>
<pre>
  // {}은 기본 객체를 생성할 뿐만 아니라 프로퍼티도 바로 추가할 수 있다.
  //실무에서는 이런 방식 
  var obj = {
    "name": "홍길동",   // json은 "" 을 꼭 사용
    'kor': 100,
    eng: 90,
    math:80,           
    sum: function() {
        return this.kor + this.eng + this.math;
    },
    aver: function() {
        return this.sum() / 3;
    }
  };
  
  console.log(obj.sum(), obj.aver());
  console.log(obj);
  
</pre>
<br>
<br>
<strong>객체 - {}을 이용하여 기본 객체에 함수를 추가하는 또 다른 방법</strong>
<br>
<pre>
  var obj = {
    name: "홍길동",
    kor: 100,
    eng: 90,
    math:80,
    /*
    sum: function() {                   // 예전문법
      return this.kor + this.eng + this.math;
    },
    */
    sum() {                            // 요즘문법
        return this.kor + this.eng + this.math;
    },
    aver() {
        return this.sum() / 3;
    }
  };
  
  console.log(obj.sum(), obj.aver());
  console.log(obj);
</pre>
<br>
<br>
<strong>객체 - {} 문법과 arrow function</strong>
<br>
<pre>
  // arrow fuction을 객체의 프로퍼티로 등록할 때,
  // => arrow function에서 this는 소속된 객체가 아니라 window 객체를 가리킨다.
  // => 그에 비해 일반 함수나 익명 함수에서 사용하는 this는 자신이 소속된 객체를 가리킨다.
  //
  var obj = {
    name: "홍길동",
    kor: 100,
    eng: 90,
    math:80,
    sum: () => this.kor + this.eng + this.math,
    aver: () => this.sum() / 3,
    test1: function() {console.log(this);},
    test2() {console.log(this);},
    test3: () => console.log(this)
  };
  
  // console.log(obj.sum()); // this 즉 window 객체에 kor, eng, math라는 변수가 없기 때문에
                           // 리턴 값은 NaN이다.
  // console.log(obj.aver()); // 마찬가지로 this 즉 window 객체에 sum() 함수가 없기 때문에
                           // 함수 실행 중에 오류가 발생한다.
  
  
  obj.test1();
  obj.test2();
  obj.test3();
  
  // 결론!
  // => 객체의 멤버 함수로 등록할 때는 arrow function을 사용하지 말라!
  // => 물론 객체의 다른 멤버를 사용하지 않는다면 arrow function을 사용해도 된다.
  
</pre>
<br>
<br>
<strong>객체 - 객체 생성과 초기화 I</strong>
<br>
<pre>
  // 1) 낱개의 레퍼런스 변수 선언

  // 자바스크립트는 객체를 생성할 때 기본 객체를 준비한 후
  // 기본 객체에 프로퍼티를 추가하는 방식으로 객체를 초기화시킨다.
  var s1 = new Object();
  s1.name = "홍길동";
  s1.kor = 100;
  s1.eng = 100;
  s1.math = 100;
  s1.sum = s1.kor + s1.eng + s1.math;
  s1.aver = s1.sum / 3;
  
  var s2 = new Object();
  s2.name = "임꺽정";
  s2.kor = 90;
  s2.eng = 90;
  s2.math = 90;
  s2.sum = s2.kor + s2.eng + s2.math;
  s2.aver = s2.sum / 3;
  
  var s3 = new Object();
  s3.name = "유관순";
  s3.kor = 80;
  s3.eng = 80;
  s3.math = 80;
  s3.sum = s3.kor + s3.eng + s3.math;
  s3.aver = s3.sum / 3;
  
  console.log(s1.name, s1.kor, s1.eng, s1.math, s1.sum, s1.aver);
  console.log(s2.name, s2.kor, s2.eng, s2.math, s2.sum, s2.aver);
  console.log(s3.name, s3.kor, s3.eng, s3.math, s3.sum, s3.aver);
</pre>
<br>
<br>
<strong>객체 - 객체 생성과 초기화 II</strong>
<br>
<pre>
  // 2) 레퍼런스 배열 사용

  // 배열을 이용하여 여러 개의 객체를 다루기
  var scores = []; //new Array();
  scores[0] = new Object();
  scores[0].name = "홍길동";
  scores[0].kor = 100;
  scores[0].eng = 100;
  scores[0].math = 100;
  scores[0].sum = scores[0].kor + scores[0].eng + scores[0].math;
  scores[0].aver = scores[0].sum / 3;
  
  scores[1] = {}; // new Object();
  scores[1].name = "임꺽정";
  scores[1].kor = 90;
  scores[1].eng = 90;
  scores[1].math = 90;
  scores[1].sum = scores[1].kor + scores[1].eng + scores[1].math;
  scores[1].aver = scores[1].sum / 3;
  
  scores[2] = {}; // new Object();
  scores[2].name = "임꺽정";
  scores[2].kor = 80;
  scores[2].eng = 80;
  scores[2].math = 80;
  scores[2].sum = scores[2].kor + scores[2].eng + scores[2].math;
  scores[2].aver = scores[2].sum / 3;
  
  for (var score of scores) {
      console.log(score.name, score.kor, score.eng, score.math, score.sum, score.aver);
  }
  
  // 배열을 쓰면 for 문을 통해 더욱 쉽게 자료를 관리할 수 있다
</pre>
<br>
<br>
<strong>객체 - 객체 생성과 초기화 III</strong>
<br>
<pre>
  // 3) 함수를 이용해 객체 생성

  // 함수를 이용하여 객체를 초기화시키기
  // 참고 
  // 팩토리 메서드 패턴(Factory Method): 이렇게 함수를 통해 객체를 생성하는 기법
  // => 객체 생성 과정이 복잡할 경우 직접 객체를 생성하고 초기화 시키기 보다 
  // 함수를 통해 객체를 생성하고 초기화 시키는것이 코드를 더 간결하게 한다
  function createScore(name, kor, eng, math) {
    const obj = new Object();
    obj.name = name;
    obj.kor = kor;
    obj.eng = eng;
    obj.math = math;
    obj.sum = kor + eng + math;
    obj.aver = obj.sum / 3;
    return obj;
  }
  
  var scores = []; // new Array();
  scores[0] = createScore("홍길동", 100, 100, 100);
  scores[1] = createScore("임꺽정", 90, 90, 90);
  scores[2] = createScore("유관순", 80, 80, 80);
  
  for (var score of scores) {
      console.log(score.name, score.kor, score.eng, score.math, score.sum, score.aver);
  }
  
  console.log("---------------------------------------------");
  
  // 아직 부족한 점!
  // => 특정 과목의 점수가 바뀌면 다시 합계와 평균을 계산해야 한다.
  scores[2].kor = 100;
  scores[2].sum = scores[2].kor + scores[2].eng + scores[2].math;
  scores[2].aver = scores[2].sum / 3;
  
  for (var score of scores) {
      console.log(score.name, score.kor, score.eng, score.math, score.sum, score.aver);
  }
</pre>
<br>
<br>
<strong>옵져버 패턴</strong> 
이벤트 리스너와,핸들러를 사용해 설계한것
<br>
<br>
<strong>객체 생성과 초기화 VI</strong>
<br>
<pre>
  // 6) 함수 외부에서 객체를 생성한 후 즉시 초기화시키기

  // new 명령 다음에 바로 함수를 호출한다.
  function createScore(name, kor, eng, math) {
    // new 명령을 실행한 후에 이 함수를 호출하면
    // this 내장 변수에 그 생성된 객체 주소가 저장된다.
    // 이렇게 되면 이 함수 내부에서 객체를 생성할 필요가 없다.
    // this 내장 변수를 사용하여 객체를 사용하면 된다.
    this.name = name;
    this.kor = kor;
    this.eng = eng;
    this.math = math;
    this.sum = function() {
      return this.kor + this.eng + this.math;
    };
    this.aver = function() {
      return this.sum() / 3;
    };
  
    // 이 함수에서 객체를 생성하지 않았기 때문에
    // 객체를 리턴할 필요가 없다.
  }
  
  var scores = []; //new Array();
  scores[0] = new createScore("홍길동", 100, 100, 100);
  scores[1] = new createScore("임꺽정", 90, 90, 90);
  scores[2] = new createScore("유관순", 80, 80, 80);
  
  // 이렇게 new 명령을 통해 생성된
  // 기본 객체를 초기화시키는 함수를 "생성자(constructor)" 라고 부른다.
  
  
  for (var score of scores) {
      console.log(score.name, score.kor, score.eng, score.math,
              score.sum(), score.aver());
  }
  
  // 다음과 같이 생성된 객체를 초기화시키는 것이 아니라
  // 객체를 생성하는 함수는
  // "팩토리 함수(factory)"라 부른다.
  function createScore2(name, kor, eng, math) {
    var obj = new Object();
    obj.name = name;
    obj.kor = kor;
    obj.eng = eng;
    obj.math = math;
    obj.sum = function() {
      return this.kor + this.eng + this.math;
    };
    obj.aver = function() {
      return this.sum() / 3;
    };
    return obj;
  }
  var obj = createScore2("홍길동", 100, 90, 80);
  console.log(obj);
</pre>
<br>
<br>
<strong>객체 - 객체 생성과 초기화 VIII</strong>
<br>
<pre>
  // 8) 객체에 대해 공통으로 사용하는 함수를 공유하기

  function Score(name, kor, eng, math) {
    this.name = name;
    this.kor = kor;
    this.eng = eng;
    this.math = math;
  
    // sum(), aver() 함수는 객체의 데이터(국어,영어,수학 점수)를 다루는 함수다.
    // 즉 객체에 대해 사용하는 함수다.
    // 그런데 객체를 생성할 때 마다 함수를 만들어 저장한다면 메모리가 낭비된다.
    // 해결 방안?
    // => 객체에 대해 공통으로 사용하는 함수는 별도의 보관소에 저장한다.
    /*
    this.sum = function() {
      return this.kor + this.eng + this.math;
    };
    this.aver = function() {
      return this.sum() / 3;
    };
    */
  }
  
  // 객체에 대해 공통으로 사용하는 함수는 생성자 객체에 보관한다.
  // => 생성자 객체에 prototype 객체가 들어 있는데 여기에 보관해야 한다.
  
  // 1) 자바스크립트 함수는 객체이다. 즉 "함수 = 객체 + 함수코드" 이다.
  // 2) 각각의 함수 객체는 prototype 이라는 공용 저장소를 갖고 있다.
  // 3) prototype에 저장된 프로퍼티는 그 함수를 통해 초기화된 모든 객체가 공통으로 사용할 수 있다.
  Score.prototype.sum = function() {
    return this.kor + this.eng + this.math;
  };
  
  Score.prototype.aver = function() {
    return this.sum() / 3;
  };
  
  var scores = []; //new Array();
  scores[0] = new Score("홍길동", 100, 100, 100);
  scores[1] = new Score("임꺽정", 90, 90, 90);
  scores[2] = new Score("유관순", 80, 80, 80);
  
  for (var score of scores) {
      console.log(score);
      console.log(score.name, score.kor, score.eng, score.math,
              score.sum(), score.aver());
      // 객체에서 sum(), aver() 함수를 찾는다.
      // 없으면, 그 객체를 초기화시킨 생성자의 prototype 보관소에서 찾는다.
      // 따라서 위의 sum(), aver() 함수는
      // Score.prototype 보관소에 들어 있는 함수를 호출하는 것이다.
  }
</pre>
<br>
<br>
<strong>생성자1 - 정의하는 방법</strong>
<br>
<br>
<pre>
  // 생성자는 그냥 일반 함수이다.
  // new 명령 다음에 즉시 함수를 호출하면 생성자로서 역할을 한다.
  
  function f1() {
    // 자바스크립트는 생성자를 정의하는 문법이 따로 없다.
    // 일반 함수를 생성자처럼 사용한다.
    // => new 명령을 사용하여 외부에서 빈 객체를 생성한 후,
    // => 일반 함수를 호출하면 생성자가 된다.
  }
  
  // => new 명령 다음에 함수를 호출하면 생성자로서 역할한다.
  var obj1 = new f1();  // 빈객체생성 
  console.log(obj1);
  console.log("-----------------------");
  
  // new 명령없이 호출하면 일반 함수로 취급된다.
  var obj2 = f1();            // undefined 
  console.log(obj2);
</pre>
<br>
<br>
<strong>생성자와 ocject</strong>
<br>
<br>
new f1();
-> 1. new: 빈객체 생성
2. f1() 의 수퍼 생성자 호출 (object)
3. f1() 호출
<br>
obj.toString()<br>
1. 객체에서 찾는다<br>
2. 생성자 f1.protortype에서 찾는다<br>
3. super 생성자 object.protortype에서 찾는다
<pre>
  function f1() {
    // 생성자에 상관없이 모든 객체는 Object() 생성자의 prototype 보관소를 공유한다.
  }
  function f2() {}
  function f3() {}
  
  var obj1 = new f1();
  var obj2 = new f2();
  var obj3 = new f3();
  
  // f1(), f2(), f3() 생성자로 초기화시킨 객체 모두
  // Object.prototype 보관소에 저장된 변수나 함수를 사용할 수 있다.
  console.log(obj1);
  console.log(obj2);
  console.log(obj3);
  console.log("-------------------------------");
  console.log(obj1.toString());  // Object.prototype.toString()
  console.log(obj2.toString());  // Object.prototype.toString();
  console.log(obj3.toString());  // Object.prototype.toString();
  
</pre>
<br>
<br>
<strong>생성자5 - 생성자 상속</strong>
<br>
<br>
<pre>
  function Engine(v, c, cc) {
    // 호출할 상위 생성자를 지정하지 않으면
    // 기본으로 object() 생성자를 호출한다
    // object.call(this);
    this.valve = va;
    this.cylinder = cy;
    this.cc = cc;
  }
  
  var e1 = new Engine(16, 4, 2000);
  console.log(e1);
  
  function Car(va, cy, cc, ca, au) {
    // f1(n); // 일반함수 호출 방법으로는 f2()가 this로 받은 객체 주소를 전달할 방법이 없다
    // 상위 생성자를 명시적으로 호출한다.
    Engine.call(this, va, cy, cc);
  
    this.capacity = ca;  // 수용인원
    this.auto = au; // 미션
  }
  
  var c1 = new Car(16, 4, 2000, 5, true);
  console.log(c1);
  
</pre>
<br>
<br>
<strong>생성자를 체인으로 연결 하듯이 super-sub로  반드는 이유</strong>
<br>
<br>
생성자를 체인 방식으로 연결<br>
- 생성자 재사용 가능<br>
- 기능확장 용이
<br>
<br>
<strong>수퍼 생성자의 protortype 사용하기</strong>
<br>
<br>
object() <br>
생성자를 통해 만든 객체들이 공동으로 사용할 프로퍼티가 들어있다
<br>
Engine() <br>
생성자를 통행 만든 객체들이 공동으로 이용할 프로퍼티가 들어있다
<br>
<br>
<strong>수퍼 생성자의 protortype 연결하기</strong>
<br>
<br>
<strong>생성자6 - 생성자 상속과 prototype 연결</strong>
<br>
<br>
<pre>
  // 생성자 정의
  function Engine(valve, cylinder, cc) {
    //Object.call(this);
    this.valve = valve;
    this.cylinder = cylinder;
    this.cc = cc;
  }
  
  function Car(valve, cylinder, cc, capacity, auto) {
    Engine.call(this, valve, cylinder, cc);
  
    this.light = false;
    this.capacity = capacity;
    this.auto = auto;
  }
  // Car.prototype을 상위 생성자인 Engine.prototype과 연결한다.
  Object.setPrototypeOf(Car.prototype, Engine.prototype);
  
  // prototype에 프로퍼티 추가
  Object.prototype.test = function() {
    console.log("Object.test() 호출됨!");
  }; 
  Engine.prototype.print = function() {
    console.log("Engine.prototype.print():");
    console.log("  밸브: " + this.valve);
    console.log("  실린더: " + this.cylinder);
    console.log("  cc: " + this.cc);
  };
  Car.prototype.setLight = function(light) {
    console.log("Car.prototype.setLight():");
    this.light = light;
  };
  
  // Car 객체 생성
  var c1 = new Car(16, 4, 2000, 5, true);
  
  c1.setLight(true);
  // c1.setLight();
  // --> Car.prototype.setLight()
  
  c1.print();
  // c1.print();
  // --> Car.prototype.print()
  //     --> Engine.prototype.print()
  
  c1.test();
  // c1.test();
  // --> Car.prototype.test()
  //     --> Object.prototype.test() 
  
  console.log(c1);
  
</pre>
<br>
<hr>
<br>
<h1>2022-12-13</h1>
<br>
<br>
<strong>객체 - constructor와 생성자</strong>
<br>
<br>
<pre>
  // 자바스크립트 객체는 자신을 초기화시킨 생성자 정보를 갖고 있다.

  function Score(name, kor, eng, math) {
    this.name = name;
    this.kor = kor;
    this.eng = eng;
    this.math = math;
  }
  
  function Member(id, pwd) {
    this.id = id;
    this.pwd = pwd;
  } 
  
  function Board(title, content) {
    this.title = title;
    this.content = content;
  }
  
  var obj1 = new Score("홍길동", 100, 100, 100);
  var obj2 = new Member("hong", "1111");
  var obj3 = new Board("제목", "내용");
  
  console.log(obj1);
  console.log(obj2);
  console.log(obj3);
  console.log("----------------------------");
  
  // 객체를 초기화시킨 생성자를 알아내기
  // => constructor 프로퍼티를 사용하라!
  console.log(obj1.constructor)
  console.log(obj2.constructor)
  console.log(obj3.constructor)
  console.log("----------------------------");
  // 생성자의 이름?
  console.log(obj1.constructor.name)
  console.log(obj2.constructor.name)
  console.log(obj3.constructor.name)
  console.log("----------------------------");
</pre>
<br>
<br>
<strong>객체 - 캡슐화와 클로저 복제 변수</strong>
<br>
<br>
<pre>
  // 자바스크립트는 접근 범위를 제어하는 문법(private, protected, public, (default))이 없다.
  // 다만 클로저 메모리를 이용하여 흉내 낼 수 있다.
  // 클로저를 이용하는 경우에는 prototype 저장소에 함수를 저장하면 안 된다.
  // 객체가 아닌 클로저에 값을 저장해야 하기 때문에
  // 객체마다 함수를 추가함으로 메모리 낭비가 있다. 
  function Score(name, kor, eng, math) {
      // 외부에서 name, kor, eng, math 값에 접근하지 못하도록 
      // 객체에 저장하지 않는다.
      
      // 함수에서 사용하는 kor, eng, math 변수는 
      // 바깥 함수의 로컬 변수이다. 
      // 바깥 함수의 호출이 끝나더라도 해당 변수를 사용해야 하기 때문에 
      // 클로저는 별도의 메모리에 복제해 둔다.
      // 함수 호출이 있을때 마다 다른 클로저 메모리를 복제
      
      this.getName = function() {return name}
      this.setName = function(n) {name = n}
      
      this.getKor = function() {return kor}
      this.setKor = function(k) {kor = k} 
      
      this.getEng = function() {return eng}
      this.setEng = function(e) {eng = e}
      
      this.getMath = function() {return math}
      this.setMath = function(m) {math = m}
      
      this.sum = function() {
          return kor + eng + math
      }
      this.aver = function() { 
          return this.sum() / 3
      }
  }
  
  var s1 = new Score("홍길동", 100, 100, 100);
  
  console.log(s1);
  console.log(s1.name) // s1 객체에 name이라는 프로퍼티가 없다. undefined
  console.log(s1.getName(), s1.sum(), s1.aver())
  
  
  s1.setName("임꺽정")
  s1.setKor(90)
  console.log(s1.getName(), s1.sum(), s1.aver())
  // setName()에서 사용한 name 변수와 getName()에서 사용한 name 변수가 같다.
  // 결론!
  // 바깥 함수를 한 번 호출할 때 생성한 모든 클로저(closure)들은
  // 바깥 함수의 로컬 변수 복제본을 공유한다.
  // 
  // 객체에 저장된 값을 직접 접근하지 못하도록 막는 방법
  // -> 클로저 메모리에 저장하도록 유도한다 클로저를 통해서만 조회 및 변경하도록 만든다
</pre>
<br>
<br>
<strong>객체 - 프로퍼티의 소속과 사용법</strong>
<br>
<br>
<pre>
  // 생성자 정의
  function Score(name, kor, eng, math) {
    this.name = name;
    this.kor = kor;
    this.eng = eng;
    this.math = math;
  }
  
  // 1) 객체 소속 프로퍼티
  var score1 = new Score("홍길동", 100, 100, 100);
  score1.sum = function() {
    return this.kor + this.eng + this.math;
  };
  score1.aver = function() {
    return this.sum() / 3;
  };
  console.log(score1.sum(), score1.aver());
  // 다음 sum()과 aver() 함수는 score1 객체에만 소속된다.
  
  var score2 = new Score("임꺽정", 90, 90, 90);
  console.log(score2.sum(), score2.aver());
  // score2에 소속된 함수 중에 sum()과 aver()가 없기 때문에 오류가 발생한다.
</pre>
<br>
<br>
<strong>객체 - 프로퍼티의 소속과 사용법</strong>
<br>
<br>
<pre>
  // 생성자 정의
  function Score(name, kor, eng, math) {
    this.name = name;
    this.kor = kor;
    this.eng = eng;
    this.math = math;
  }
  
  // 2) 함수의 prototype 소속 프로퍼티
  Score.prototype.sum = function() {
    return this.kor + this.eng + this.math;
  };
  Score.prototype.aver = function() {
    return this.sum() / 3;
  };
  
  // 함수의 prototype 소속 프로퍼티는
  // 그 함수가 초기화시킨 객체에 대해 사용할 수 있다.
  
  var score1 = new Score("홍길동", 100, 100, 100);
  console.log(score1.sum(), score1.aver());
  //1. score1.sum()
  //2.-> score.prototype.sum()
  
  var score2 = new Score("임꺽정", 90, 90, 90);
  console.log(score2.sum(), score2.aver());
  //1. score2.sum()
  //2.-> score.prototype.sum()
</pre>
<br>
<br>
<pre>함수 프로퍼티와 prototype 프로퍼티</pre>
<br>
특정 객체에 대해 작업하지 않는 함수를
묶을 때는 객체에 바로 저장한다
사용법) math.random()   // 객체명.함수명() //변경되지 않는다
<br>
math{
  random()
  min()
  max()
  sin()
}
<br>
특정 객체의 값을 사용해서 작업을 수행하는 함수를 묶을 때는 
생성자의 prototype에 저장한다
사용법) S1.sum() // 객체명.함수명() // 대상 객체에 따라 변경
Score.prototype {
  sum()
  aver()
}
<br>
<br>
<strong>객체 - 프로퍼티의 소속과 사용법</strong>
<br>
<br>
<pre>
  // 생성자 정의
  function Score(name, kor, eng, math) {
    this.name = name;
    this.kor = kor;
    this.eng = eng;
    this.math = math;
  }
  
  // 2) 함수의 prototype 소속 프로퍼티
  Score.prototype.sum = function() {
    return this.kor + this.eng + this.math;
  };
  Score.prototype.aver = function() {
    return this.sum() / 3;
  };
  
  // 함수의 prototype 소속 프로퍼티는
  // 그 함수가 초기화시킨 객체에 대해 사용할 수 있다.
  
  var score1 = new Score("홍길동", 100, 100, 100);
  console.log(score1.sum(), score1.aver());
  //1. score1.sum()
  //2.-> score.prototype.sum()
  
  var score2 = new Score("임꺽정", 90, 90, 90);
  console.log(score2.sum(), score2.aver());
  //1. score2.sum()
  //2.-> score.prototype.sum()
</pre>
<br>
<br>
<strong>함수의 소속</strong>
<br>
<br>
<pre>
1. 객체에 직접 소속
예) Math.random();
사용법) 객체.함수명(); // 그룹으로서역할

2. 생성자의 prototype에 소속
예)s1.sum();
사용법) var obj = new 생성자();
obj.함수명(); // 함수가 사용하는 데이터
</pre>
<br>
<br>
<strong>생성자와 인스턴스(instance)</strong>
 Score()
 -> 객체 생성 
 new Score() = Score의 인스턴스 즉 Score() 생성자를 통해 초기화된 객체

 * 자바 "Score 클래스(설계도)"
 <br>
 <br>
 <strong>HTMLDocument(Document())와 Document</strong>
 <br>
 <br>
 <pre>
Document()
-> HTMLDocument() 생성
-> DOMTree 
-태그정보 -> 객체 -> 부모자식관계로 맺고 트리구조로 관리


// 자바스크립트는 태그를 다루는 도구를 제공한다.
// 그 도구를 "DOM(Document Object Model) API"라 부른다.
//
// document 객체
// => 웹브라우저에서 기본으로 제공하는 객체이다.
// => 태그를 찾고, 생성하고, 제어하는 함수를 갖고 있다.
// => var document = new HTMLDocument();
//

// document의 타입은?
// => 즉 document 객체를 초기화시킨 생성자는?
console.log(document.constructor.name);

// document 객체를 통해 사용할 수 있는 함수나 변수는?
// => HTMLDocument 생성자가 추가한 함수나 변수이다.
// => 어떤 함수와 변수가 있는지 알고 싶다면 문서 보세요.
// => HTMLDocument 생성자의 문서를 보라!
// => 상속 관계
//    Document() --> Node() ---> EventTarget() ---> Object()

console.log(document);

console.log(Document.prototype);

// Document()의 함수
console.log(document.createElement); // document ---> Document.prototype

// Node()의 함수
console.log(document.appendChild); // document ---> Document.prototype ---> Node.prototype

// EventTarget()의 함수
console.log(document.addEventListener); // document ---> Document.prototype ---> Node.prototype ---> EventTarget.prototype

// Object()의 함수
console.log(document.toString); // document ---> Document.prototype ---> Node.prototype ---> EventTarget.prototype ---> Object.prototype

 </pre>
 <br>
 <br>
 <br>
<br>
<strong>DOM API - id 값으로 태그 찾기</strong>
<br>
<br>
<pre>
  // 생성자 정의
  function Score(name, kor, eng, math) {
    this.name = name;
    this.kor = kor;
    this.eng = eng;
    this.math = math;
  }
  
  // 2) 함수의 prototype 소속 프로퍼티
  Score.prototype.sum = function() {
    return this.kor + this.eng + this.math;
  };
  Score.prototype.aver = function() {
    return this.sum() / 3;
  };
  
  // 함수의 prototype 소속 프로퍼티는
  // 그 함수가 초기화시킨 객체에 대해 사용할 수 있다.
  
  var score1 = new Score("홍길동", 100, 100, 100);
  console.log(score1.sum(), score1.aver());
  //1. score1.sum()
  //2.-> score.prototype.sum()
  
  var score2 = new Score("임꺽정", 90, 90, 90);
  console.log(score2.sum(), score2.aver());
  //1. score2.sum()
  //2.-> score.prototype.sum()
</pre>
<br>
<br>
<pre>DOM API</pre>
<br>
<br>
<pre>
DOM API 명세서
프로그램에 상관없이 사용법이 같다

 -JAVA
 -> 구현 (implements)
 자바언어로 DOM API 규격에 따라 클래스와 메서드를 만들엇다

 -javascript
 -> javascript 언어로 DOMAPI규격에 따라 메서드와 객체을 만들엇다

</pre>
<br>
<br>
<strong>Document.prototype.getElementById()</strong>
<br>
<br>
<pre>
  document.getElementById("header4")
  = <h1 id="header4" class="g2">제목2</h1>
  h1 -> HTMLHeadingElement

  생성자로 초기화시킨 객체 = "인스턴스"
</pre>
<br>
<br>
<strong>HTMLHeadingElement() 생성과 체인과 객체의 관계</strong>
<br>
<br>
<pre>
 1. object() + (생성자들의 prototype)
 - 프로퍼티 주가
 2. EventTarget() +         
 3. Node() +
 4. Element() +
 5. HTMLElement() +
 6. HTMLHeadingElement() +

 document.getElementById("header4")
 = e1 상위 생성자들의 protortype을 call할 수 있다
</pre>
<br>
<br>
<strong>DOM API - CSS selector 문법으로 태그 찾기</strong>
<br>
<br>
<pre>
  
  <!-- <h1>DOM API - CSS selector 문법으로 태그 찾기</h1>
  <h1 id="header1" class="g1">제목1</h1>
  <h2 id="header2" class="g1">제목1.1</h2>
  <h2 id="header3" class="g1 g3">제목1.2</h2>
  
  <h1 id="header4" class="g2">제목2</h1>
  <h2 id="header5" class="g2 g3 g1">제목2.1</h2>
  <h2 id="header6" class="g2 g3">제목2.2</h2> -->
  
  ///////////////////////////////////
  // querySelector("CSS selector 문법")
  // => Element 객체 리턴
  // => 만약 여러 개를 찾았다 할 지라도 그 중 첫 번째 것만 리턴한다.
  //
  // 1) 아이디로 찾기
  var e = document.querySelector("#header3"); // $("#header3")
  console.log(e);
  console.log("---------------------");
  
  // 2) 태그 이름으로 찾기
  // => 조건에 해당하는 태그가 여러 개일지라도 그 중 첫 번째 것만 리터한다.
  e = document.querySelector("h2"); // $("h2")
  console.log(e);
  console.log("---------------------");
  
  //3) 분류명으로 찾기
  //=> 조건에 해당하는 태그가 여러 개일지라도 그 중 첫 번째 것만 리터한다.
  e = document.querySelector(".g2"); // $(".g2")
  console.log(e);
  console.log("---------------------");
  
  //4) CSS selector 문법을 사용하기 때문에 복잡한 조건을 기술할 수 있다.
  //=> 조건에 해당하는 태그가 여러 개일지라도 그 중 첫 번째 것만 리터한다.
  e = document.querySelector(".g2.g3"); // $(".g2.g3")
  console.log(e);
  console.log("---------------------");
  
  //5) 조건에 해당하는 태그를 찾지 못했다면?
  // => 리턴 값은 null이다.
  e = document.querySelector(".g2.g3.g1"); // $(".g2.g3.g1")
  console.log(e);
</pre>
<br>
<br>
<strong>DOM API -  HTMLCollection과 NodeList</strong>
<br>
<br>
<pre>

  var list1 = document.getElementsByTagName("li"); // 수정 내용을 반영한다
var list2 = document.querySelectorAll("li");  // 태그를 수정하더라도 처음 받은 값 그대로 리턴한다

</pre>
<br>
<br>
<strong>DOM API -  HTMLCollection과 NodeList</strong>
<br>
<br>
<pre>
  // Element.innerHTML : DOMString
  // => Element() 생성자가 추가한 프로퍼티이다.
  // => 태그의 콘텐트를 HTML 코드 그대로 리턴한다.
  //
  var e = document.querySelector("article:first-child > p");
  console.log(e)
  console.log(e.innerHTML)
  console.log("----------------------")
  // 결과: 자바스크립트는 b>프론트-엔드/b>를 개발할 때 사용하는 프로그래밍 언어입니다

  // Node.textContent
  // => Node() 생성자가 추가한 프로퍼티이다.
  // => 태그의 콘텐트에서 HTML 코드를 제거한 후 텍스트만 리턴한다.
  console.log(e.textContent)
  console.log("----------------------")
  // 결과: 자바스크립트는 프론트-엔드를 개발할 때 사용하는 프로그래밍 언어입니다.
</pre>
<br>
<br>
<strong>DOM API - 태그의 콘텐트 설정하기 I</strong>
<br>
<br>
<pre>
  document.querySelector('#btn1').onclick = function() {
    // Element.innerHTML : DOMString // HTML문법을 그래도 쓰고싶을 때
    // => Element() 생성자가 추가한 프로퍼티이다.
    // => HTML 코드로 태그의 콘텐트를 설정할 수 있다.
    // => HTML 태그가 그대로 렌더링 된다.
    //// HTML문법을 그래도 쓰고싶을 때
    var e = document.querySelector("article:first-child > p");
    e.innerHTML = "오호라 <b>비트캠프</b>입니다.<br> 반갑습니다.";
  
    // Node.textContent
    // => Node() 생성자가 추가한 프로퍼티이다.
    // => 텍스트를 설정할 때 사용한다. 텍스트 안에 HTML 코드는 그냥 일반 텍스트로 취급한다.
    //    즉 텍스트 안에 있는 HTML 코드는 웹브라우저가 인식하지 않는다.
    //// 전부 텍스트로 하고싶을 때
    e = document.querySelector("article:last-child > p");
    e.textContent = "우헤헤 <b>비트캠프</b>입니다.<br> 반갑습니다.";
  
    // HTMLElement.innerText
    // => Node() 생성자가 추가한 프로퍼티이다.
    // => 텍스트를 설정할 때 사용한다. 텍스트 안에 HTML 코드는 그냥 일반 텍스트로 취급한다.
    //    즉 텍스트 안에 있는 HTML 코드는 웹브라우저가 인식하지 않는다.
    //// 전부 텍스트로 쓰고싶을때
    e = document.querySelector("article:last-child > p");
    e.innerText = "우헤헤 <b>비트캠프</b>입니다.<br> 반갑습니다.";
  };
</pre>
<br>
<br>
<strong>DOM API - 태그의 속성(attribute) 변경하기</strong>
<br>
<br>
<pre>
  // 태그의 속성 바꾸기
  //
  var e = document.querySelector("article:nth-child(2) a");
  console.log(e.href)
  
  document.querySelector('#btn1').onclick = function() {
    // 1) 방법1
    // => 원래 태그에 있던 속성 값을 바꿀 때!
    //      태그객체.속성명 = "값"
    // e.href = "http://www.daum.net";
  
    // 2) 방법2
    // => 원래 태그에 있던 속성 값을 바꿀 때
    //      태그객체.setAttribute("속성명", "값")
    // => 이 메서드를 사용하면 개발자가 임의로 추가한 프로퍼티 값도 바꿀 수 있다.
    //    즉 원래 태그 객체에 없던 프로퍼티 값도 설정할 수 있다.
    e.setAttribute("href", "http://www.google.com");
  };
</pre>
<br>
<br>
<strong>DOM API - 태그에 속성(attribute)을 추가하기</strong>
<br>
<br>
<pre>

  // 2) 방법2
  // "data-xxxx" 형식으로 이름을 짓는 것이 관례다.
  e.setAttribute("data-no2", 300);
  console.log(e.getAttribute("data-no2"));

</pre>
<br>
<br>
<strong>DOM API - 태그 추가하기</strong>
<br>
<br>
<pre>

  // 2) 방법2
  // "data-xxxx" 형식으로 이름을 짓는 것이 관례다.
  e.setAttribute("data-no2", 300);
  console.log(e.getAttribute("data-no2"));

</pre>
<br>
<br>
<strong>DOM API - 태그 삭제하기</strong>
<br>
<br>
<pre>

  // 태그를 삭제하기
  //
  document.querySelector('#btn1').onclick = function() {
    // 방법1) 부모 태그를 알고 있다면 removeChild()를 이용하여 삭제한다.
    // => 삭제할 태그를 찾는다.
    var e = document.querySelector("article:first-child");
  
    // => 부모 태그를 찾는다.
    var parent = document.querySelector("section");
  
    // => 부모 태그에서 자식 태그를 제거한다.
    parent.removeChild(e);
  }
</pre>
<br>
<br>
<strong>DOM API - 태그 삭제하기</strong>
<br>
<br>
<pre>

// 태그를 삭제하기
//
document.querySelector('#btn1').onclick = function() {
  // 방법1) 부모 태그를 알고 있다면 removeChild()를 이용하여 삭제한다.
  // => 삭제할 태그를 찾는다.
  var e = document.querySelector("article:first-child");

  // => 부모 태그를 찾는다.
  var parent = document.querySelector("section");

  // => 부모 태그에서 자식 태그를 제거한다.
  parent.removeChild(e);
}


  // 태그를 삭제하기 II
// 
document.querySelector('#btn1').onclick = function() {
// 방법2) 부모 태그를 모른다면 찾은 태그에서 부모 태그를 알아낸다.
// => 삭제할 태그를 찾는다.
var e = document.querySelector("article:first-child");

// => 부모 태그를 알아낸다.
// => Node.parentElement 또는 Node.parentNode를 사용한다.
var parent = e.parentElement;

// => 부모 태그에서 자식 태그를 제거한다.
parent.removeChild(e);
};
</pre>
<br>
<br>
<strong>과제</strong>
15퍼즐 만들기 <br>
4*4 에서 1칸을 비워서 움직일 수 있게 <br>
섞기버튼 구현<br>
<br>
2022-12-15-09:00 까지 
<br>
<hr>
<br>
<h1>2022-12-14</h1>
<br>
<br>
<strong>이벤트 - 리스너 등록하기</strong>
<br>
<br>
<pre>

  // 이벤트(event)
  // => 사용자나 시스템에 의해 태그의 상태가 바뀌는 것을 가리킨다.
  // => 각 태그 별로 발생하는 이벤트가 정해져 있다.
  // => 물론 개발자가 임의의 이벤트를 발생시킬 수 있다.
  //
  // 리스너(listener) = 이벤트 핸들러(event handler)
  // => 이벤트가 발생할 때 호출되는 메서드이다.
  // => HTML 태그나 자바스크립트 코드에서 이벤트에 대해 함수를 등록해야 한다.
  //
  // click 이벤트
  // => 사용자가 태그를 클릭할 때 발생한다.
  //
  // click 이벤트에 대해 리스너를 등록하는 방법
  // 1) HTML 태그의 onclick 속성에 자바스크립트 코드를 넣는다.
  //    => 사용자가 태그를 클릭하면 이 속성에 등록된 자바스크립트 코드가 실행된다.
  //    => 이 방식은 태그 안에 자바스크립트 코드가 섞여 있기 때문에
  //       유지보수할 때 힘들다.
  //    => HTML 태그는 태그대로, 자바스크립트 코드는 코드대로 분리되어 있어야
  //       유지보수가 쉽다.
  //    => 태그 안에 자바스크립트 코드를 넣어야 하기 때문에 긴 코드를 넣기가 불편한다.
  //
  // 2) 태그 객체의 onclick 프로퍼티에 함수를 등록한다.
  //    => 사용자가 태그를 클릭하면 onclick이라는 이름으로 등록된 함수를 호출한다.
  //    => HTML 태그와 자바스크립트 코드가 분리되어 있어서 유지보수하기 쉽다.
  //    => 이 방식은 이벤트에 대해 한 개의 리스너만 등록할 수 있다.
  //
  // 3) 태그 객체의 addEventListener()를 이용하여 호출될 함수를 등록한다.
  //    => 사용자가 태그를 클릭하면 해당 이벤트에 등록된 함수가 호출된다.
  //    => 이 또한 HTML 태그와 자바스크립트 코드가 분리되어 있어서 유지보수에 좋다.
  //    => 특히 여러 개의 리스너를 등록할 수 있다.
  

  /////////////////////////////////////

  // 방법1:

  button id="btn1-2" onclick="btn1Click();">버튼1-2/button
  function btn1Click() {
    var msg = document.getElementById('input1')
     if (msg.value == 'ok') {
      console.log('하하하');
     } else (console.log('시무룩'))
   }

  // 방법2:

  //var btn2 = document.getElementById("btn2");
  var btn2 = document.querySelector("#btn2"); 
  btn2.onclick = () => {
    var str = "Hello2c!";
    window.alert(str);
    console.log(this); // arrow function에서 this는 window 객체이다.
  };
  

  // 방법3:
  // => addEventListener(이벤트명, 리스너);
  // => 주의!
  //    클릭 이벤트의 이름은 "onclick"(속성이름)이 아니라, "click"(함수)이다.
  //

  var btn3 = document.querySelector("#btn3");

  btn3.addEventListener("click", () => {
    var str = "Hi3!!";
    window.alert(str);
    console.log(this); // this는 window 객체이다.
  });
</pre>
<br>
<br>
<strong>이벤트 - 각 태그 객체에 따로따로 이벤트 리스너를 등록해야 한다.</strong>
<br>
<br>
<pre>
  button class="btn1">btn1-버튼1/button>
  button class="btn1">btn1-버튼2/button>
  button class="btn1">btn1-버튼3/button>

  var el = document.querySelectorAll(".btn1");

  // 들어있는 모든 객체를 함수로 만들어서 보여줌 메모리 차지 많음

  // for (var e of el) {
    // 	e.onclick = function() {
    // 		console.log(this);
    // 	}
    // }
    
      // 하나만 하고 싶다면 아래처럼 메모리 사용 적음

    function f1() {
      console.log(this);
    }
    for (var e of el) {
        e.onclick = f1
    }
</pre>
<br>
<br>
<strong>이벤트 - 이벤트 정보 다루기 I</strong>
<br>
<br>
<pre>
  (button) id="btn1" onclick="console.log(event)">버튼1 (button)

  event
  
  PointerEvent {

  // => altKey : Alt 키 누름 여부
  // => ctrlKey : Ctrl 키 누름 여부
  // => button : 누른 버튼 번호
  // => offsetX/Y : 버튼 영역을 기준으로 X/Y 좌표
  // => clientX/Y : 웹브라우저 내용창을 기준으로 X/Y 좌표
  // => screenX/Y : 바탕화면 영역을 기준으로 X/Y 좌표
]

// 태그 객체의 onclick 프로퍼티에 리스너 등록하고 이벤트 정보 추출
document.getElementById("btn1").onclick = function(e) {
	console.log(
			e.altKey, e.ctrlKey, e.button,
			e.offsetX, e.offsetY,
			e.clientX, e.clientY,
			e.screenX, e.screenY)
};

// addEventListener() 사용
document.getElementById("btn1").addEventListener("click", function(e) {
	console.log(
		e.altKey, e.ctrlKey, e.button,
		e.offsetX, e.offsetY,
		e.clientX, e.clientY,
		e.screenX, e.screenY)
});

</pre>
<br>
<br>
<strong>이벤트 -이벤트가 발생된 태그 알아내기</strong>
<br>
<br>
<pre>
  (button) id="btn1" data-no="100">버튼1 (button)

  // 리스너가 일반 함수나 익명 함수일 경우,
  // this가 가리키는 객체가 이벤트가 발생된 객체이다.
  //
  document.getElementById("btn1").addEventListener("click", function(e) {
    console.log(this);
  
    // 이벤트가 발생한 객체의 속성 값 알아내기
    // => 개발자가 임의로 추가한 속성인 경우 반드시 getAttribute()를 사용해야 한다.
    console.log(this.getAttribute("data-no"));
    
    // 개발자가 태그에 임의로 추가한 속성은 다음과 같이 일반적인 방법으로 꺼낼 수 없다. 
    console.log(this["data-no"]); // undefined
    
    // 태그에 원래 있던 속성이라면 일반적인 문법으로 접근할 수 있다.
    console.log(this.id);
  });
</pre>
<br>
<br>
<strong>이벤트 -이벤트가 발생된 태그 알아내기</strong>
<br>
<br>
<pre>
  // 방법1 

  (button) id="btn1" data-no="100">버튼1 (button)

  // 리스너가 일반 함수나 익명 함수일 경우,
  // this가 가리키는 객체가 이벤트가 발생된 객체이다.
  //
  document.getElementById("btn1").addEventListener("click", function(e) {
    console.log(this);
  
    // 이벤트가 발생한 객체의 속성 값 알아내기
    // => 개발자가 임의로 추가한 속성인 경우 반드시 getAttribute()를 사용해야 한다.
    console.log(this.getAttribute("data-no"));
    
    // 개발자가 태그에 임의로 추가한 속성은 다음과 같이 일반적인 방법으로 꺼낼 수 없다. 
    console.log(this["data-no"]); // undefined
    
    // 태그에 원래 있던 속성이라면 일반적인 문법으로 접근할 수 있다.
    console.log(this.id);
  });

  // 방법2

  // arrow function인 경우
  // this는 window 객체를 가리킨다.
  //
  document.getElementById("btn1").addEventListener("click", (e) => {
  console.log(this); // window 객체이다.

  // 그럼 arrow function(자바에서는 Lambda라 부른다)에서는
  // 이벤트가 발생된 객체를 알 수 없는가?
  // => 있다!
  //    이벤트 객체에 이벤트가 발생된 태그의 주소가 들어 있다.
  console.log(e.target);

  // 이벤트가 발생한 객체의 속성 값 알아내기
  console.log(e.target.getAttribute("data-no"));
});

  // 방법 3

  // 여러 개의 태그에 같은 리스너를 등록했을 경우
// 리스너가 호출될 때 어떤 태그인지 알아내는 방법!

var el = document.querySelectorAll(".b1");
var p = document.querySelector("#message");


	p.style.width = "200px";
	p.style.height = "100px";
	
	// 스타일 이름에 공백이나 특수 문자가 포함된 경우 
	// 자바스크립트에서 프로퍼티 이름을 사용할 수 없다.
	//p.style.background-color = "gray"; // 프로퍼티 이름 중간에 - 문자가 있으면 안된다.
	
	// 그래서 다음과 같이 대괄로 문법으로 스타일을 설정해야 한다. 
	p.style["background-color"] = "gray";
	
	// 웹브라우저 API는 
	// 개발자들이 스타일 이름을 프로퍼티 이름 규칙에 따라 사용할 수 있도록
  // 스타일 이름을 변경한 프로퍼티를 제공한다.
  // 예) background-color ===> backgroundColor 
  // 예) border-top-width ===> borderTopWidth
  // 따라서 다음과 같이 배경색을 지정할 수 있다.
	// p.style.backgroundColor = "yellow"; 
  
	p.style.color = "green";
	p.style.border = "5px dashed red";
	
	
	var btnClick = function(event) {
	p.innerHTML = this.getAttribute("data-no");
}; 

for (var e of el) {
	  e.addEventListener("click", btnClick);
}
</pre>
<br>
<br>
<strong>이벤트 -이벤트 단계</strong>
<br>
<br>
<pre>
  // 이벤트가 발생하면 다음 3단계로 전달 된다.

  // 1) capture phase
  //    => 부모 태그에서 자식 태그로 내려가는 단계
  
  // 2) target phase
  //    => 이벤트가 발생된 목적지에 도달한 단계
  
  // 3) bubble phase
  //    => 다시 목적지에서 부모 태그로 올라가는 단계

  // 세번째 파라미터를 true로 설정하면,
  // 캡쳐단계와 타겟 단계에서만 호출 
  // 즉 부모태그부터 자식태그순
  // false 로 설정시 (기본)
  // 자식부터 부모순 


// 일반적인 방법으로 이벤트 리스너를 등록하면,
// 이벤트가 발생했을 때
// target과 bubble 단계에서 호출된다.
// => 따라서 #btn1이나 #btn2를 클릭하면,
//    버튼에 등록된 함수 뿐만 아니라
//    그 부모들에 등록된 함수가 있다면 그 함수들도 호출된다.
document.getElementById("btn1").addEventListener("click", function(e) {
	console.log("버튼1...");
});

document.getElementById("btn2").addEventListener("click", function(e) {
    console.log("버튼2...");
});

document.getElementById("d2").addEventListener("click", function(e) {
    console.log("d2...");
});

document.getElementById("d1").addEventListener("click", function(e) {
    console.log("d1...");
});

document.body.addEventListener("click", function(e) {
    console.log("body...");
});

event 발생 
-> 1. 캡쳐단계 무시
2. 타겟단계 리스너 호출
3. 버블단계 리스너 호출   
</pre>
<br>
<br>
<strong>이벤트 -이벤트 전파 막기</strong>
<br>
<br>
<pre>
  // 1.

  // => 이벤트 bubbling을 막는다.
  // => 단 target에 등록된 함수는 모두 호출된다.
  e.stopPropagation();


  // 2.

  target에 등록된 함수라도 즉시 현 함수에서 실행을 마감한다.
  e.stopImmediatePropagation()
</pre>
<br>
<br>
<strong>이벤트 -이벤트 전파 기능을 이용하기</strong>
<br>
<br>
<pre>
  // 부모 태그에 리스너를 등록하면 
  // 훨씬 더 광범위하게 클릭 이벤트를 처리할 수 있다.
  // 즉 자식 태그의 이벤트를 부모 태그에서 처리할 수 있다. 
  // 어떻게? 부모로 이벤트가 전파되는 기능을 이용하는 것이다.
  var el = document.querySelectorAll("tbody tr");
  
  for (var e of el) {
    e.addEventListener("click", function(e) {
      // e.target 은 이벤트가 발생한 객체를 가리킨다.
      // console.log(e.target);
      // console.log(e.target.getAttribute("data-no") + " 번 게시물의 제목을 눌렀음!");
      
      // 리스너가 등록된 태그를 가리키고 싶다면,
      // e.currentTarget 프로퍼티의 값을 사용하라!
      console.log(e.currentTarget);
      console.log(e.currentTarget.getAttribute("data-no") + " 번 게시물의 제목을 눌렀음!");
      console.log("-------------------------------");
  
  
  
      // 자바스크립트에서 다른 페이지로 이동시킨다
      window.location.href = ("https://www.naver.com/board?no="+ e.currentTarget.getAttribute("data-no"));
</pre>
<br>
<br>
<strong>객체와 인스턴스</strong>
<br>
<br>
<pre>
  New MouseEvent()
  -> MouseEvent 인스턴스(instance)
    함수를 통해서 초기화된 객체

  var f = funcrion() {-----};

</pre>
<br>
<br>
<strong>이벤트 -프로그래밍으로 이벤트 발생시키기</strong>
<br>
<br>
<pre>
  // 사용자의 행위가 아닌 프로그래밍으로 특정 이벤트를 발생시킬 수 있다.
  //
  //
  document.getElementById("btn1").addEventListener("click", function(e) {
    // #btn1을 눌렀을 때 #btn2에 click 이벤트 발생시키기
    // 1) MouseEvent 만들기
    var myEvent = new MouseEvent("click");
  
    // 2) 위에서 생성한 이벤트 객체를 #btn2에 보낸다.
    document.getElementById("btn2").dispatchEvent(myEvent); // dispatch 전달하다
  });
  
  document.getElementById("btn2").addEventListener("click", function(e) {
      console.log("버튼2...");
  });
</pre>
<br>
<br>
<strong>이벤트 -a 태그의 기본 동작을 중단시키기</strong>
<br>
<br>
<pre>

  (a id="link6" href="http://www.daum.net")a 태그의 기본 동작 취소 6(/a)
  
  function f1() {
    alert("OK!");
    return false
  };
  
  document.querySelector("#link3").onclick = function() {
    alert("OK!");
    return false; // false를 리턴하면 a 태그의 기본 동작을 취소한다.
  };
  
  document.querySelector("#link4").onclick = function(e) {
    e.preventDefault(); // a 태그의 기본 동작을 비활성화시킨다. 리스너 호출이 끝난 후 서버에 요청하지 않는다.
    alert("OK!");
  };
  
  document.querySelector("#link5").addEventListener("click", function() {
    alert("OK!");
    return false; // addEventListener()로 함수를 등록하면
                  // return 값으로 a 태그의 기본 동작을 취소할 수 없다.
  });
  
  document.querySelector("#link6").addEventListener("click", function(e) {
    // addEventListener()로 함수를 등록한다면
    // Event.preventDefault()를 사용하여 a 태그의 기본 동작을 취소해야 한다.
    e.preventDefault();
    alert("OK!");
  });
</pre>
<br>
<br>
<strong>이벤트 -form의 submit 버튼 만들기</strong>
<br>
<br>
<pre>

  <!-- 
    <form action="https://www.daum.net">
    <input type="text" name="title">
    <button>전송1</button>
  </form>
  
  <form action="https://www.daum.net">
    <input type="text" name="title">
    <button type="submit">전송2</button>
  </form>
  
  <form action="https://www.daum.net">
    <input type="text" name="title">
    <input type="submit" value="전송3">
  </form>
   -->
</pre>
<br>
<br>
<strong>이벤트 -form 데이터 검증</strong>
<br>
<br>
<pre>

  // 1 

  form id="form1" action="http://www.daum.net">
    이름(*): input type="text" id="name1" name="username">
      button>전송/button>
    /form>
    hr>
    <!-- submit은 name을 주지 않으면 ?로 나온다 -->

    script>
    "use strict"
    
    document.querySelector("#form1").onsubmit = () => {
      // submit 타입의 버튼을 클릭하면 onsubmit 으로 등록한 함수가 호출된다.
      // 여기에서 입력 폼 값을 검증하는 일을 한다.
      //
      var name = document.querySelector("#name1");
      if (name.value == "") {
        alert("필수 입력 항목이 비어 있습니다.");
        return false; // false를 리턴하면 입력 폼의 값을 서버에 제출하지 않는다.
                      // 즉 HTTP 요청을 수행하지 않는다.
      }
    
      // true를 리턴하거나 아무것도 리턴하지 않으면 원래대로
      // 입력 폼의 값을 서버에 제출한다. 즉 HTTP 요청을 수행한다.
    


      // 2

      form id="form2" action="http://www.daum.net">
        이름(*): input type="text" id="name2" name="username">
          button id="btn2" type="button">전송/button>
        /form>
        
        
        
        script>
        "use strict"
        
        
        
        document.querySelector("#btn2").onclick = () => {
          var name = document.querySelector("#name2");
          if (name.value == "") {
            alert("필수 입력 항목이 비어 있습니다.");
            return; // submit 버튼이 아니라 일반 버튼이기 때문에 false를 리턴할 필요가 없다.
          }
        
          // 일반 버튼을 클릭했을 때 입력 폼의 값을 서버에 제출하려면
          // form 태그 객체에 대해 submit() 함수를 호출하라!
          //
          document.querySelector("#form2").submit();
        }
        

        // 3

        form id="form3" action="http://www.daum.net">
          이름(*): input type="text" id="name3" name="username">
            button>전송/button>
          /form>
          
          script>
        
          
          
          
          document.querySelector("#form3").addEventListener("submit", (e) => {
            console.log("okok!");
            var name = document.querySelector("#name3");
            if (name.value.length < 2) { //최소글자수
              alert("2자 이상을 입력하세요.");
              //return false; // addEventListener()로 등록한 경우 return false는 안 먹힌다.
              e.preventDefault();
              return;
            }
          });
</pre>
<br>
<hr>
<br>
<h1>2022-12-15</h1>
<br>
<br>
<strong>웹페이지 와 어플리케이션</strong>
<br>
<br>
<pre>
client(web browser)가 server(wbe server)에 요청을 하면
HTML파일,CSS파일,JS파일등 필요한 파일들을 다운 받는다
그후 HTML 문서에 연결된 자원들을 추가로 가져온다
</pre>
<br>
<br>
<strong>웹페이지 바꾸기</strong>
<br>
<br>
<pre>
client가 URL을 요청하면 각각의 URL에 관한 모든 정보를 받아오고
URL이 바뀔때마다 전부 다시 받아와야한다 그렇기 때문에 동일한 U
RL 이라도 다시 받는다
</pre>
<br>
<br>
<strong>AJAX(Asynchronous JavaScript And XML)</strong>
<br>
<br>
<pre>
현재 APP 의 실행을 유지한 상태에서 서버에 자원을 요청하는 기술

cross-domain 제약 
-다른 URL과 공유할 수 없는 기술
->
해결방법
-CORS(Cross-Origin Resource Sharing) - 교차 출처 리소스 공유
*Access-Control-Allow-Origin


let xhr = new XMLHttpRequest();
xhr.open("GET", "a.html", false);

html요청메서드
-post,head,put,delete...

요청하는 자원의 URL
-a.html

비동기 여부
-false

xhr.send();

HTTP서버에 요청 정보 보낸다
-서버가 응답하면 리턴 한다 (synchronus)
-서버응답과 상관없이 즉시 리턴한다(Asynchronous)

</pre>
<br>
<br>
<strong>nodeJS 와 Express</strong>
<br>
<br>
<pre>
1.nodeJS 실행 
2.app.js생성및 실행
3.미니 웹서버
Express

APP에 Express라이브러리 장착하는법
app 폴더에 nodeJS용 라이브러리 다운로드 

->$npm install express --save

 노드 app 디렉토리 

app.js 는 진입점(entry point)

package.json 
-nodeJS App 설정파일
app설명,제작자,라이센스등

node.

</pre>
<br>
<br>
<strong>npm intall</strong>
<br>
<br>
<pre>
$npm install 

1. 작업폴더에서 package.json 파일을 찾는다

2. package.json 파일에 등록된 라이브러리들을 모두 다운

-node_modules폴더가 없으면 생성
-라이브러리가 없으면 다운
  설정된 조건에 따라 버전을 검사해서 적절한 
  버전을 다운

패키지명이 없다면 


있다면 
-node_modules폴더가 없으면 생성
-라이브러리가 없으면 다운
  설정된 조건에 따라 버전을 검사해서 적절한 
  버전을 다운

npm 사용

1.npm init
2.npm install 라이브러리 -- save
--> 처음 한번 수행 하며 필요할때마다 여러번 반복
3.npm install
git repo. 에서 프로젝트를 가져온후 한번만 실행


req(요청) 및 res(응답)는 Node가 제공하는 동일한 오브젝트이며,
따라서 req.pipe(), req.on('data', callback) 그리고 Express의 
관여가 필요 없는 다른 모든 항목을 호출할 수 있습니다.
</pre>
<br>
<br>
<strong>AJAX - XMLHttpRequest()</strong>
<br>
<br>
<pre>
  // XMLHttpRequest()
  // => 동기/비동기 HTTP 요청을 할 때 사용한다.
  // => 전체 페이지를 갱신하지 않고 페이지의 일부만 갱신하는 용도로 쓴다.
  // => 서버는 요청에 대한 응답으로 HTML 일부 코드나 XML, JSON 데이터를 전송한다.
  // => 이런 기법을 AJAX(Asynchronous JavaScript And XML)이라 부른다.
  
  // 버튼을 클릭할 때 서버에 HTTP 요청하여 응답 결과를 textarea 태그에 출력한다.
  var ta = document.querySelector("#ta");     // 공통으로 사용하므로 미리 선언
  
  document.querySelector("#btn1").onclick = () => {
  
      //1) AJAX 객체 준비 
      var xhr = new XMLHttpRequest();        // 사용할 때 용도가 달라지므로 다시 생성
      
      //2) 서버에 소켓 연결(동기 방식으로 요청)
      // => 1번 파라미터: HTTP 요청 method. ex) GET, POST, HEAD ...
      // => 2번 파라미터: 요청 URL
      // => 3번 파라미터: 비동기 여부
      xhr.open("GET", "http://127.0.0.1:3000/exam01-1", false); // false 로 동기방식
      
      //3) 서버에 HTTP(규칙에 따라) 요청을 보낸다.
      // => 동기 방식으로 연결되었을 경우 서버에서 응답할 때까지 리턴하지 않는다.
      xhr.send();
      
      //4) 서버가 응답한 콘텐트(pay load = message-body)를 꺼낸다.
      ta.value = xhr.responseText;
  };

  //app.js


  //express 라이브러리 로딩하기
  const express = require('express');
  const port = 3000; // 웹서버 포트 번호
  //express() 를 호출하여 웹서버를 준비한다
  const app = express();
  
  // 클라이언트 요청에 대해 호출될 메서드를 등록
  app.get(                // get요청이 들어왔을 때 호출될 메서드 지정
    '/exam01-1',          // 요청 URL
    (req, res) => {       // 핸들러:요청이 들어왔을때 호출
     
      res.set('Access-Control-Allow-Origin', '*');
      res.set('Content-Type', 'text/plain;charset=UTF-8');
      res.send("Hello");
    }
  ); 
  
  // 웹서버 실행하기 
  app.listen(
    3000,           // 포트 번호 지정
    () => {         // 서버가 시작되었을 때 호출될 함수 = 리스너 = 핸들러
      console.log(`${port}번 포트에서 서버 시작`);
    } 
  );

</pre>
<br>
<hr>
<br>
<h1>2022-12-16</h1>
<br>
<br>
<strong>일반요청</strong>
<br>
<br>
<pre>
<!-- <button id="btn">요청</button><br>
<textarea id="nomal" cols="30" rows="10"></textarea>

<script>
  "use strict"

  document.querySelector("#btn").onclick = () => {

    // 웹브라우저가 지정한 URL로 요청 수행
    window.location.href = "http://www.naver.com";
  };
</script> -->
</pre>
<br>
<br>
<pre>
UI component
제목
버튼등 

UI component 생성명령코드 (HTML) 
h1
button

serialization
데이터를 문자,바이트,배열로 변환하는것

객체 -> JSON.stringify(obj) -> JSON문자열


deserialization
문자,바이트,배열을 데이터로 변환하는것
</pre>
<br>
<br>
<strong>CORS(origin을 건너서 자원 공유) Policy 을 우회하는 방법</strong>
<br>
<br>
<pre>
해결방안
1. origin서버에 AJAX요청 (origin이 proxy역할)
2. origin이 cross server 에 요청 (CORS정책과 상관없다)
3. client에 전달


<strong>Query String 값 꺼내기</strong>


client ->  http://localhost:3000/proxy?url=http://www.naver.com

server -> app.get('/proxy', (req, res) => {

}

</pre>
<br>
<br>
<strong>AJAX 활용</strong>
<br>
<br>
<pre>
1. 화면의 일부를 가져오기 
  1) AJAX요청
  2) 서버가 응답
  3) HTML코드를 화면에 삽입(일부 화면 갱신)

2. 데이터 가져오기 
  1) AJAX요청
  2) 서버가 응답
  3) JSON또는 XML 로 HTML 생성
  4) 화면 일부 갱신

<strong>AJAX의 응답 결과가 JSON또는 XML 데이터인 이유?</strong>


  "use srtict"
  var nomal1 = document.querySelector("#nomal1"); // 요청 결과를 textarea에 출력
  document.querySelector("#btn2").onclick = () => { 
    var xhr = new XMLHttpRequest(); // AJAX 객체 준비
    xhr.open("GET", "btn2", false); // 서버 소켓연결 ("HTTP요청", "URL", "비동기여부 (false = 비동기)")
    xhr.send();  // 서버에 HTTP요청을 보낸다
    nomal.value = xhr.responseText; // 서버가 응답한 콘텐트를 꺼낸다
  };
  // XMLHttpRequest()
// => 동기/비동기 HTTP 요청을 할 때 사용한다.
// => 전체 페이지를 갱신하지 않고 페이지의 일부만 갱신하는 용도로 쓴다.
// => 서버는 요청에 대한 응답으로 HTML 일부 코드나 XML, JSON 데이터를 전송한다.
// => 이런 기법을 AJAX(Asynchronous JavaScript And XML)이라 부른다.


1. HTML코드를 응답할 때 문제점
  1) AJAX요청
  2) 서버가 응답
  3) HTML코드 삽입

* 안드로이드에 같은 과정으로 실행시 HTML코드 삽입 불가
-> JAVA,KOTLIN으로 만든 앱화면에 HTML코드로 변경 불가
android UI component로 변환하여 삽입

* 아이폰도 같은 과정시 HTML코드 삽입 불가
-> Object,swift HTML 코드 변경 불가


멀티 디바이스에 대응할 수 있다 는 장점이 있다 
</pre>
<strong>AJAX - AJAX의 제약</strong>
<br>
<br>
<pre>
  // AJAX 요청의 제약
  // => HTML을 다운로드 받은 서버로만 AJAX로 HTTP 요청을 할 수 있다.
  // => 이유? 보안 때문이다.
  //    - 웹브라우저는 서버로부터 HTML을 다운로드 받으면 HTML에 들어있는 JavaScript를 자동으로 실행한다.
  //    - HTML페이지는 반드시 신뢰할 수 있는 것은 아니다.
  //      페이지의 링크를 이리저리 따라가다 보면 임의의 사용자가 만든 페이지에 방문할 수 있고,
  //      그 사용자가 신뢰할 수 있는 사용자인지 알 수 없다. 
  //    - 이런 상황에서 누군가 게시글 속에 다른 사이트에 AJAX 요청을 하는 자바스크립트 코드를 넣었다고 가정해 보자.
  //      그 게시글을 보는 사용자는 자신의 의도와 상관없이 특정 사이트에 대해 AJAX 요청을 할 것이다.
  //      이 요청이 동시에 많은 사람들에 의해 수행된다면 요청 받는 서버는 느려질 것이다.
  //      이것이 DDOS 공격이다.
  //    - 즉 본인의 의사와 상관없이 DDOS 공격에 참여자가 될 수 있다.
  //    - 이런 상황을 방지하고자 HTML을 보낸 서버로만 AJAX 요청을 하도록 제한하고 있다.
  //    - 실제는 요청을 하고 응답까지 받는데 다만 응답헤더에 허락한다는 키워드가 없으면 
  //      웹브라우저는 응답 결과를 리턴하지 않는다.
  //    - 현재는 요청을 제한하기 위함이 아니라, 
  //      허락하지 않은 응답 결과에 대해 가져가지 말도록 제한하는데 의미를 둔다.    
  //
  // 버튼을 클릭할 때 서버에 HTTP 요청하여 응답 결과를 textarea 태그에 출력한다.
  var ta = document.querySelector("#ta");
  
  document.querySelector("#btn1").onclick = () => {
      var xhr = new XMLHttpRequest();
      xhr.open("GET", "http://www.zdnet.co.kr", false);
      xhr.send();
      ta.value = xhr.responseText;
      
      // 이 HTML 문서는 www.zdnet.co.kr 에서 다운로드 받은 것이 아니기 때문에
      // 웹브라우저는 응답받은 결과를 리턴하지 않는다.
      // => 실행하면 다음과 같은 오류가 뜬다.
      // No 'Access-Control-Allow-Origin' header is present on the requested resource.
</pre>
<br>
<br>
<strong>AJAX - AJAX의 제약 해소</strong>
<br>
<br>
<pre>
// AJAX 요청에 대해 응답을 하는 서버 쪽에서 다음과 같은 응답 헤더를 포함한다면 
// 웹브라우저는 응답결과를 리턴해 줄 것이다.
//      Access-Control-Allow-Origin: 허락할 도메인
//
// 버튼을 클릭할 때 서버에 HTTP 요청하여 응답 결과를 textarea 태그에 출력한다.
var url = document.querySelector("#url");
var ta = document.querySelector("#ta");

document.querySelector("#btn1").onclick = () => {
    var xhr = new XMLHttpRequest();
    xhr.open("GET", url.value, false);
    xhr.send();
    ta.value = xhr.responseText;
};
</pre>
<br>
<br>
<strong>AJAX - 프록시 기법으로 AJAX의 제약 해소</strong>
<br>
<br>
<pre>
  // AJAX로 요청하는 서버를 자신이 통제할 수 있다면,
  // 언제든 응답 헤더에 "Access-Control-Allow-Origin"을 붙여 
  // 다른 사이트에서 AJAX 요청을 할 수 있도록 허락할 수 있다.
  // 문제는 자신이 통제할 수 없는 서버는 어떻게 처리할 것인가?
  // => 프록시 기법을 사용한다.
  // => 웹브라우저는 HTML을 다운로드 받은 서버에 AJAX 요청을 하고,
  //    그 서버는 중간에서 실제 목적지 서버로 요청을 대행한다.
  //    목적지 서버로부터 받은 응답을 그대로 AJAX 요청자에게 전달한다.
  //
  // 버튼을 클릭할 때 서버에 HTTP 요청하여 응답 결과를 textarea 태그에 출력한다.
  var url = document.querySelector("#url");
  var ta = document.querySelector("#ta");
  
  document.querySelector("#btn1").onclick = () => {
      var xhr = new XMLHttpRequest();
      xhr.open("GET", "test3?url=" + url.value, false);
      xhr.send();
      ta.value = xhr.responseText;
  };
</pre>
<br>
<br>
<strong>AJAX - 동기 요청의 한계</strong>
<br>
<br>
<pre>
  // 동기 요청의 문제점
  // => 서버에서 응답을 할 때까지 send() 메서드는 리턴하지 않는다.
  // => 따라서 작업 시간이 오래 걸리는 경우 send() 메서드가 리턴하지 않아서  
  //    다른 작업을 수행하지 못하는 상황이 발생한다.
  
  var ta = document.querySelector("#ta");
  
  document.querySelector("#btn1").onclick = () => {
      var xhr = new XMLHttpRequest();
  
      // 클라이언트 쪽의 반응을 확인해 보기 위해 
      // test3.jsp는 일부로 응답시간을 지연시킬 것이다. 
      xhr.open("GET", "test5", false);
      xhr.send();
      // 서버에서 응답할 때 까지 send()는 리턴하지 않기 때문에 
      // 다음 라인을 실행할 수 없다. 
      // 즉 그 이후의 사용자 행위에 응답하지 못하는 상황이 발생한다.
      // 일종의 "벽돌" 화면이 된다. 
      // 해결 방법? 다음 예제를 보라!
      ta.value = xhr.responseText;
  };
</pre>
<br>
<br>
<strong>AJAX - 동기 요청의 한계를 해결하자!</strong>
<br>
<br>
<pre>
// 동기 요청의 문제점 해결
// => 웹브라우저는 서버에 요청을 별도의 스레드에서 실행하게 하고,
//    서버 응답에 상관없이 즉시 다음 작업을 수행한다.
// => 이것을 "비동기(asynchronous) 요청"이라 부른다.
//
var ta = document.querySelector("#ta");

document.querySelector("#btn1").onclick = () => {
    var xhr = new XMLHttpRequest();
    
    // 비동기 요청을 하려면 3번 파라미터를 true로 설정해야 한다.
    xhr.open("GET", "test5", true);
    xhr.send();
    console.log("send() 리턴함.");
    // 별도의 스레드를 통해 요청을 수행시키고 
    // 다음 작업을 즉시 실행한다.
    // 따라서 다음과 같은 코드를 조심해야 한다.
    // 왜? 
    // 서버가 응답하기 전에 다음 코드를 실행한다면,
    // responseText 변수에는 아직 서버가 응답한 결과가 들어있지 않기 때문에 
    // 결과를 제대로 출력할 수 없을 것이다.
    ta.value = xhr.responseText;
    
    // 해결책?
    // => 서버에서 응답을 완료했을 때 결과를 꺼내라!
    // => 다음 예제를 보라!
 
};


// 동기 요청의 문제점 해결 2
// => 웹브라우저는 서버에 요청을 별도의 스레드에서 실행하게 하고,
//    서버의 응답에 상관없이 즉시 다음 작업을 수행한다.
// => 이것을 "비동기(asynchronous) 요청"이라 부른다.
//
var ta = document.querySelector("#ta");

document.querySelector("#btn1").onclick = () => {
    var xhr = new XMLHttpRequest();
    
    // 비동기 요청을 하려면 3번 파라미터를 true로 설정해야 한다.
    xhr.open("GET", "test5", true);
    xhr.send();
    console.log("send() 리턴함.");
    
    // 지금 바로 responseText 변수의 값을 꺼내봐야 소용없다. 
    // 서버에서 아직 응답하지 않았기 때문이다.
    // => 서버에서 일부로 10초 정도 응답을 지연시켰다.
    // 
    // 해결책?
    // => 서버에서 응답하는데 걸리는 시간(예: 10초)이 지난 후에
    //    (넉넉하게 잡아서 13초 후에) responseText 변수의 값을 꺼낸다.
    // => 타임아웃에 함수를 등록해서 13초가 지난 후에 호출되면 
    //    responseText 변수의 값을 꺼내게 한다.
    window.setTimeout(() => {
      console.log("13초가 지났다.")
      console.log("xhr.responseText 변수의 값을 꺼내 보자!")
      ta.value = xhr.responseText;
    }, 13000);
    
    // 이 해결 방식의 문제점은
    // 서버의 응답 시간이 13초보다 늦어지면 
    // 이전과 같이 응답 데이터를 가져올 수 없다. 
    // 또는 응답시간이 빨라지더라도 
    // 무조건 13초를 기다렸다가 값을 꺼낸다는 것이다.
    // 
    // 해결책!
    // => 다음 예제에서...
    // 
};
</pre>
<br>
<br>
<strong>AJAX - onreadystatechange</strong>
<br>
<br>
<pre>
// onreadystatechange
// => 비동기로 AJAX 요청을 하게 되면 
//    작업 상태가 바뀔 때 마다 onreadystatechange로 등록한 
//    메서드가 호출된다.
// => 작업 상태는 메서드가 호출될 때 마다 readyState 값을 검사해 보면 알 수 있다. 
// => readyState의 값:
//    0 : XMLHttpRequest 준비
//    1 : open() 호출됨 => 서버에 연결됨. 
//    2 : send() 호출됨 => 서버에 요청을 보낸 후 응답 상태와 헤더 값을 받음.
//    3 : 서버에서 콘텐트를 받고 있는 중. 
//        아직 responseText에는 완전한 데이터가 들어 있지 않음.
//        서버에서 받은 일부 데이터가 들어 있을 수는 있음.
//    4 : 서버에서 콘텐트를 모두 받음. 즉 응답이 완료됨.
//       
//
var ta = document.querySelector("#ta");

document.querySelector("#btn1").onclick = () => {
    var xhr = new XMLHttpRequest();

    // 서버에서 응답이 왔을 때 호출될 메서드를 등록한다.
    // 서버에 연결하기 전에 등록해야 한다.
    // 즉 open()을 호출하기 전에 등록해야 한다.
    xhr.onreadystatechange = () => {
        console.log("현재 요청 상태: ", xhr.readyState);
    };
    
    xhr.open("GET", "test5", true);
    console.log("open() 리턴함.");
    
    xhr.send();
    console.log("send() 리턴함.");
    
    // 비동기로 요청할 때는 서버에서 응답이 왔을 때 값을 꺼내도록 한다.
    // 서버에서 응답이 왔는지 알아내는 방법은?
    // => 현재의 요청 상태를 보고 받는 것이다.
    // => 위의 onreadystatechange() 함수 등록을 참고하라!
};

//////////////////////////////////////

var ta = document.querySelector("#ta");

document.querySelector("#btn1").onclick = () => {
    var xhr = new XMLHttpRequest();

    xhr.onreadystatechange = () => {
        console.log("readyState=", xhr.readyState);
        // 실제 우리가 관심을 두는 것은 서버가 응답을 완료했는지 여부이다.
        // 응답이 완료되었을 때 우리는 서버가 보낸 값을 꺼내 사용한다.
        if (xhr.readyState == 4) {
        	ta.value = xhr.responseText;
        }
    };
    
    xhr.open("GET", "test5", true);
    xhr.send();
    console.log("send() 리턴함.");
</pre>
<br>
<br>
<strong>AJAX - 이벤트 발생시키기</strong>
<br>
<br>
<pre>
// 서버에서 실행 오류가 발생했을 때 
// 입력 폼을 초기화시키기
// => 프로그램에서 리셋 버튼에 대해 click 이벤트를 발생시킨다. 
//
var a = document.querySelector("#a");
var b = document.querySelector("#b");
var r = document.querySelector("#r");

document.querySelector("#btn1").onclick = () => {
    var xhr = new XMLHttpRequest();

    xhr.onreadystatechange = () => {
        if (xhr.readyState == 4) {
        	// 서버의 실행이 정상적인지 여부에 따라 처리를 분리하기
        	if (xhr.status == 200) {
        	  // a와 b 값을 정상적으로 입력했을 때 서버는 정상적으로 실행한다. 
        	  r.value = xhr.responseText;
        	  
        	} else {
        	  // a 또는 b 값이 숫자가 아닐 때 서버는 오류를 응답한다.
        	  // HTTP 응답 상태코드 값은 500이 될 것이다.
        	  // 
        	  alert("실행 오류 입니다!");
        	  
        	  // 오류 안내창을 닫으면 reset 버튼을 자동으로 누르게 해보자!
        	  // => reset 버튼에 대해 click 이벤트를 프로그램에서 발생시킨다.
        	  
        	  // 먼저 클릭 이벤트 객체를 만든다.
        	  var e = new MouseEvent("click");
        	  
        	  // 그리고 클릭 이벤트 객체를 reset 버튼에 보낸다.
        	  // => 그러면 reset 버튼에 대해 click 이벤트가 발생된다.
        	  document.querySelector("#btn2").dispatchEvent(e);
        	}
        }
    };
    
    xhr.open("GET", "test6?a=" + a.value + "&b=" + b.value, true);
    xhr.send();
    console.log("send() 리턴함.");
};
</pre>
<br>
<br>
<strong>AJAX - 응용 I : HTML 일부분 가져오기 + 익명함수 즉시 호출</strong>
<br>
<br>
<pre>
<!-- <div id="footer"></div>
<script>
"use strict"
// 웹페이지를 만들 때 AJAX를 이용하여 여러 조각을 붙여서 만들 수 있다.
//       
var header = document.querySelector("#header"),
    footer = document.querySelector("#footer");

(function() { // 머리말 가져오기
  var xhr = new XMLHttpRequest();
  xhr.onreadystatechange = () => {
      if (xhr.readyState == 4) {
          if (xhr.status == 200) {
              header.innerHTML = xhr.responseText;
          }
      }
  };
  xhr.open("GET", "test5.jsp", true);
  xhr.send();
})();

(function() { // 꼬리말 가져오기
  var xhr = new XMLHttpRequest();
  xhr.onreadystatechange = () => {
      if (xhr.readyState == 4) {
          if (xhr.status == 200) {
              footer.innerHTML = xhr.responseText;
          }
      }
  };
  xhr.open("GET", "footer.html", true);
  xhr.send();
}()); -->
</pre>
<br>
<br>
<strong>AJAX - 응용 II : 서버에서 JSON 데이터 받아오기</strong>
<br>
<br>
<pre>
  // 웹페이지를 만들 때 AJAX를 이용하여 여러 조각을 붙여서 만들 수 있다.
  //       
  var tbody = document.querySelector("tbody");
  
  document.querySelector("#btn1").onclick = () => {
      var xhr = new XMLHttpRequest();
      xhr.onreadystatechange = () => {
          if (xhr.readyState == 4) {
              if (xhr.status == 200) {
  
                  console.log(xhr.responseText);
  
                  // 서버에서 받은 JSON 문자열을 자바스크립트 객체로 변환한다.
                  var arr = JSON.parse(xhr.responseText);
                  console.log(arr);
                  
                  // 배열을 반복하여 값을 꺼낸다.
                  for (var b of arr) {
                    // tr 태그를 만든다.
                    var tr = document.createElement("tr");
                    
                    // tr 태그에 게시물 데이터를 넣는다.
                    tr.innerHTML = "<td>" + b.no + "</td>" + 
                       "<td>" + b.title + "</td>" + 
                       "<td>" + b.writer + "</td>" +
                       "<td>" + b.viewCnt + "</td>";
                    
                    // tr 태그를 tbody의 자식 태그로 붙인다.
                    tbody.appendChild(tr);
                  }
              }
          }
      };
      xhr.open("GET", "test6.jsp", true);
      xhr.send();
  };

/////////////
"test6.jsp"

<%@ page language="java" contentType="text/plain; charset=UTF-8"
    pageEncoding="UTF-8"%>
<% response.setHeader("Access-Control-Allow-Origin", "*");%>
[
  {"no":1, "title":"제목입니다1", "writer":"홍길동", "viewCnt":100},
  {"no":2, "title":"제목입니다2", "writer":"임꺽정", "viewCnt":200},
  {"no":3, "title":"제목입니다3", "writer":"유관순", "viewCnt":300},
  {"no":4, "title":"제목입니다4", "writer":"안중근", "viewCnt":400},
  {"no":5, "title":"제목입니다5", "writer":"윤봉길", "viewCnt":500}
]

</pre>
<br>
<hr>
<br>
<h1>2022-12-19</h1>
<br>
<br>
<strong>jQuery 만들기</strong>
<br>
<br>
<pre>
vanillajs vs jQuery

javaScript Built-in API
-DOM API
-AJAX API


app에서 직접 call (vanillajs)
-



간접 call (jQuery)

-코드가 간결하다

-cross-browser문제 해결
-> 브라우저간 차이를 없애줌, 웹 브라우저마다 명령을 다르게 실행



*jQuery 리턴 값

jQuery -> return .파라미터명()


.append
예) : (a).append(b);


(a) 라는 부모 태그에 (b)라는 자식을 붙여 넣는다
-부모태그를 찾아 자식 태그를 하나하나 붙여 넣는다

.appendTo()
- 자식 태그에 부모태그를 붙여준다


method chaining

-메서드가 객체를 반환하게 되면, 메서드의 반환 값인 객체를 통해 또 다른 함수를 호출할 수 있습니다.
 이러한 프로그래밍 패턴을 메서드 체이닝(Method Chaining) 이라 부릅니다.

-> 함수가 끝날때 마다 return this로 다시 리턴을 해줘서 반복해서 사용할 수 있게 만든다
직관성이 좋고 간단하다 하지만 디버깅 하기 어렵다
</pre>
<br>
<br>
<strong>jQuery - 1. 태그 찾기</strong>
<br>
<br>
<pre>
(HTML)

  var tbody = $("tbody")[0];

  document.querySelector("#btn1").onclick = () => {
      var xhr = new XMLHttpRequest();
      xhr.onreadystatechange = () => {
          if (xhr.readyState == 4) {
              if (xhr.status == 200) {
  
                  console.log(xhr.responseText);
  
                  var arr = JSON.parse(xhr.responseText);
                  console.log(arr);
                  
                  for (var b of arr) {
                    var tr = document.createElement("tr");
                    
                    tr.innerHTML = "<td>" + b.no + "</td>" + 
                       "<td>" + b.title + "</td>" + 
                       "<td>" + b.writer + "</td>" +
                       "<td>" + b.viewCnt + "</td>";
                    
                    tbody.appendChild(tr);
                  }
              }
          }
      };
      xhr.open("GET", "http://localhost:3000/exam04-3", true);
      xhr.send();
  };


////////////////////////////////////////////////////
(JS)

//1. 태그 찾기
function jQuery(selector) {
  return document.querySelectorAll(selector);
}

var $ = jQuery;
</pre>
<br>
<br>
<strong>jQuery 만들기 - 2. 태그 만들기</strong>
<br>
<br>
<pre>
(HTML)

var tbody = $("tbody")[0];

document.querySelector("#btn1").onclick = () => {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange = () => {
        if (xhr.readyState == 4) {
            if (xhr.status == 200) {

                console.log(xhr.responseText);

                var arr = JSON.parse(xhr.responseText);
                console.log(arr);
                
                for (var b of arr) {
                	var tr = $("<tr>");
                	
                	tr.innerHTML = "<td>" + b.no + "</td>" + 
                	   "<td>" + b.title + "</td>" + 
                	   "<td>" + b.writer + "</td>" +
                	   "<td>" + b.viewCnt + "</td>";
                	
                	tbody.appendChild(tr);
                }
            }
        }
    };
    xhr.open("GET", "http://localhost:3000/exam04-3", true);
    xhr.send();
};


////////////////////////////////////////////
(JS)
  //2. 태그 만들기
function jQuery(selector) {
  if (selector.startsWith("<")) {
    return document.createElement(selector.substring(1, selector.length - 1));
  } else {
    return document.querySelectorAll(selector);
  }
}

var $ = jQuery;
</pre>
<br>
<br>
<strong>jQuery 만들기 - 3. append()</strong>
<br>
<br>
<pre>
(HTML)

var tbody = $("tbody")[0];

document.querySelector("#btn1").onclick = () => {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange = () => {
        if (xhr.readyState == 4) {
            if (xhr.status == 200) {

                console.log(xhr.responseText);

                var arr = JSON.parse(xhr.responseText);
                console.log(arr);
                
                for (var b of arr) {
                	var tr = $("<tr>");
                	
                	tr.innerHTML = "<td>" + b.no + "</td>" + 
                	   "<td>" + b.title + "</td>" + 
                	   "<td>" + b.writer + "</td>" +
                	   "<td>" + b.viewCnt + "</td>";
                	
                	tbody.append(tr);
                }
            }
        }
    };
    xhr.open("GET", "http://localhost:3000/exam04-3", true);
    xhr.send();
};
////////////////////////
(JS)

//3. append() 
function jQuery(selector) {
  if (selector.startsWith("<")) {
    let e = document.createElement(selector.substring(1, selector.length - 1));
    e.append = function(child) {
      e.appendChild(child);
    };
    return e;
  } else {
    let el = document.querySelectorAll(selector);
    for (let e of el) {
      e.append = function(child) {
        e.appendChild(child);
      };
    }
    return el;
  }
}

var $ = jQuery;

</pre>
<br>
<br>
<strong>jQuery 만들기 - 7 appendTo()</strong>
<br>
<br>
<pre>
(HTML)

var tbody = $("tbody");

$("#btn1").on('click', () => {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange = () => {
        if (xhr.readyState == 4) {
            if (xhr.status == 200) {
                var arr = JSON.parse(xhr.responseText);
                for (var b of arr) {
                	var tr = $("<tr>");
                	tr.html("<td>" + b.no + "</td>" + 
                	   "<td>" + b.title + "</td>" + 
                	   "<td>" + b.writer + "</td>" +
                	   "<td>" + b.viewCnt + "</td>");
                	tr.appendTo(tbody);
                }
            } else {
                alert('데이터 요청 오류!')
            }
        }
    };
    xhr.open("GET", "http://localhost:3000/exam04-3", true);
    xhr.send();
});

////////////////////////
(JS)


//7. appendTo()
function jQuery(selector) {
  let el = []; // 생성한 태그나 찾은 태그를 담는 배열

  if (selector.startsWith("<")) {
    el[0] = document.createElement(selector.substring(1, selector.length - 1));

  } else {
    let nodeList = document.querySelectorAll(selector);
    for (let e of nodeList) {
      el.push(e);
    }
  }

  el.append = function(childBox) {
    // 자식 태그를 복제해서 각 부모 태그에 붙인다.
    for (let parent of el) {

      // 자식들이 들어있는 상자에서 자식을 한 개씩 꺼내 복제하여 각 부모의 자식으로 붙인다.
      for (let child of childBox) {
        parent.appendChild(child.cloneNode(true));
      }
    }

    // 자식 태그는 제거한다.
    for (let child of childBox) {
      if (child.parentElement != null || child.parentElement != undefined) {
        child.parentElement.removeChild(child);
      }
    }
  };

  el.appendTo = function(parents) {
    // 자식 태그를 복제해서 각 부모 태그에 붙인다.
    for (let parent of parents) {

      // 자식들이 들어있는 상자에서 자식을 한 개씩 꺼내 복제하여 각 부모의 자식으로 붙인다.
      for (let child of el) {
        parent.appendChild(child.cloneNode(true));
      }
    }

    // 자식 태그는 제거한다.
    for (let child of el) {
      if (child.parentElement != null || child.parentElement != undefined) {
        child.parentElement.removeChild(child);
      }
    }
  };

  el.html = function(content) {
    for (let e of el) {
      e.innerHTML = content;
    }
  };

  el.on = function(eventName, listener) {
    for (let e of el) {
      e.addEventListener(eventName, listener);
    }
  };

  return el;
}

var $ = jQuery;
</pre>
<br>
<br>
<strong>jQuery 만들기 - 8. Method Chaining</strong>
<br>
<br>
<pre>
(HTML)

var tbody = $("tbody");

$("#btn1").on('click', () => {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange = () => {
        if (xhr.readyState == 4) {
            if (xhr.status == 200) {
                var arr = JSON.parse(xhr.responseText);
                for (var b of arr) {
                	$("<tr>")
                    .html("<td>" + b.no + "</td>" + 
                            "<td>" + b.title + "</td>" + 
                            "<td>" + b.writer + "</td>" +
                            "<td>" + b.viewCnt + "</td>")
                    .appendTo(tbody);
                }
            } else {
                alert('데이터 요청 오류!')
            }
        }
    };
    xhr.open("GET", "http://localhost:3000/exam04-3", true);
    xhr.send();
});
////////////////////////
(JS)


//8. Method Chaining
function jQuery(selector) {
  let el = []; // 생성한 태그나 찾은 태그를 담는 배열

  if (selector.startsWith("<")) {
    el[0] = document.createElement(selector.substring(1, selector.length - 1));

  } else {
    let nodeList = document.querySelectorAll(selector);
    for (let e of nodeList) {
      el.push(e);
    }
  }

  el.append = function(childBox) {
    // 자식 태그를 복제해서 각 부모 태그에 붙인다.
    for (let parent of el) {

      // 자식들이 들어있는 상자에서 자식을 한 개씩 꺼내 복제하여 각 부모의 자식으로 붙인다.
      for (let child of childBox) {
        parent.appendChild(child.cloneNode(true));
      }
    }

    // 자식 태그는 제거한다.
    for (let child of childBox) {
      if (child.parentElement != null || child.parentElement != undefined) {
        child.parentElement.removeChild(child);
      }
    }

    return this;
  };

  el.appendTo = function(parents) {
    // 자식 태그를 복제해서 각 부모 태그에 붙인다.
    for (let parent of parents) {

      // 자식들이 들어있는 상자에서 자식을 한 개씩 꺼내 복제하여 각 부모의 자식으로 붙인다.
      for (let child of el) {
        parent.appendChild(child.cloneNode(true));
      }
    }

    // 자식 태그는 제거한다.
    for (let child of el) {
      if (child.parentElement != null || child.parentElement != undefined) {
        child.parentElement.removeChild(child);
      }
    }

    return this;
  };

  el.html = function(content) {
    for (let e of el) {
      e.innerHTML = content;
    }

    return this;
  };

  el.on = function(eventName, listener) {
    for (let e of el) {
      e.addEventListener(eventName, listener);
    }

    return this;
  };

  return el;
}

var $ = jQuery;
</pre>
<br>
<br>
<strong>jQuery 만들기 - 4. 리팩토링</strong>
<br>
<br>
<pre>
(HTML)

var tbody = $("tbody");

document.querySelector("#btn1").onclick = () => {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange = () => {
        if (xhr.readyState == 4) {
            if (xhr.status == 200) {

                console.log(xhr.responseText);

                var arr = JSON.parse(xhr.responseText);
                console.log(arr);
                
                for (var b of arr) {
                	var tr = $("<tr>");
                	
                	tr[0].innerHTML = "<td>" + b.no + "</td>" + 
                	   "<td>" + b.title + "</td>" + 
                	   "<td>" + b.writer + "</td>" +
                	   "<td>" + b.viewCnt + "</td>";

                	tbody.append(tr);
                }
            }
        }
    };
    xhr.open("GET", "http://localhost:3000/exam04-3", true);
    xhr.send();
};
////////////////////////
(JS)


//4. 리팩토링
function jQuery(selector) {
  let el = []; // 생성한 태그나 찾은 태그를 담는 배열

  if (selector.startsWith("<")) {
    el[0] = document.createElement(selector.substring(1, selector.length - 1));

  } else {
    let nodeList = document.querySelectorAll(selector);
    for (let e of nodeList) {
      el.push(e);
    }
  }

  el.append = function(childBox) {
    // 자식 태그를 복제해서 각 부모 태그에 붙인다.
    for (let parent of el) {

      // 자식들이 들어있는 상자에서 자식을 한 개씩 꺼내 복제하여 각 부모의 자식으로 붙인다.
      for (let child of childBox) {
        console.log(child);
        parent.appendChild(child.cloneNode(true));
      }
    }

    // 자식 태그는 제거한다.
    for (let child of childBox) {
      if (child.parentElement != null || child.parentElement != undefined) {
        child.parentElement.removeChild(child);
      }
    }
  };


  return el;
}

var $ = jQuery;
</pre>
<br>
<hr>
<br>
<h1>2022-12-20</h1>
<br>
<br>
<strong>메서드와 파라미터</strong>
<br>
<br>
<pre>
  function hello(name) {
    console.log(name + "님 환영합니다");

};

hello("홍길동");
ㄴ> 메서드(파라미터)
예) ++a;
연산자
hello,++

함수정의 = 연산정의


<strong>메서드와 객체</strong>


function Greeting(n) {
  this.name = n;  // 여기서 this는 
}
  Greeting.prototype.hello = function (type) {
    if (type == '높임말'){  
    console.log(this.name+"님 환영합니다/");
    }else {
      console.log(this.name+"반갑다");
    }
  }
}

new를 통해 생성된 객체는 해당 함수의 주소를 리턴한다

obj.hello("평어");
주데이터(피연산자)
-obj: 사용할 데이터
연산자
-hello: 메서드 ->작업수행
보조데이터(피연산자)
-("평어"): 메서드가 작업을 수행하기위한 보조 데이터

jQuery
-cross-browser를 지원 해서 다른 브라우저에서도 똑같은 
기능을 구현할 수 있도록 해준다

min
-js파일을 주석,함수이름등, 줄일수 있는것을 전부 줄여 파일 용량을 줄여준다
한번 min한 파일은 함수 이름이 a 등으로 한글자로 바뀌므로 다시 원본처럼 되
돌릴수 없다 google에 (javascript minify) 를 검색하면 줄여주는 사이트가 나
온다 하지만 보통 기업들에서 min파일과 원본 파일을 따로 올려두므로 필요한
목적에 맞게 사용하면 된다
</pre>
<br>
<br>
<pre>jQuery 만들기</pre>
<br>
<br>
<pre>

function jQuery(selector) {      // jQuery생성하여 ElementBox로 초기화
  return new ElementBox(selector);    
}


function ElementBox(selector) {
  this.el = []; 

  if (selector.startsWith("<")) {     // this에 첫번째에 엘리먼트를 생성해 추가 
    this.el[0] = document.createElement(selector.substring(1, selector.length - 1));

  } else {
    let nodeList = document.querySelectorAll(selector);  
    for (let e of nodeList) {
      this.el.push(e);
    }
  }
}

variable
-각 반복에 서로 다른 속성값이 variable에 할당됩니다.

*for... in

쉽게 객체의 속성을 확인(콘솔이나 다른 방법으로 출력)할 수 있기 때문에실질적으로
디버깅을 위해 사용될 수 있다. 배열이 데이터의 저장에 있어서는 더 실용적이지만, 
키-값 쌍이 선호되는 데이터의 경우(속성이 "key"의 역할을 함)특정 값을 가진 키
가 있는지 확인하려는 경우에 for...in을 사용할 수 있습니다.



iterable
-반복되는 열거가능(enumerable)한 속성이 있는 객체.

*for... of

명령문은 반복가능한 객체 (Array, Map (en-US), Set, String, TypedArray, 
arguments 객체 등을 포함)에 대해서 반복하고 각 개별 속성값에 대해 실행
되는 문이 있는 사용자 정의 반복 후크를 호출하는 루프를 생성합니다.




startsWith()
-메서드는 어떤 문자열이 특정 문자로 시작하는지 확인하여
 결과를 true 혹은 false로 반환합니다




1. jQuery생성
  
1) ajax()
2) getJSON()
3) post()

  예) {
    jQuery.post = function(url, data,success) {
      jQuery.ajax({
        data: data,
        url: url,
        method: "POST",
        success: success
      });
    };
  }

  위와 같은 함수는 jQuery에 등록된 함수이고 prototype에
  등록된 함수를 사용가능 
  
  

  
2. jQuery안에 ElementBox.prototype에 함수를 등록

1) append
2) appendTo
3) html

  예) {
    ElementBox.prototype.append = function(childBox) {
      for (let parent of this.el) {
    
        for (let child of childBox.el) {
          parent.appendChild(child.cloneNode(true));
        }
      }
    
      for (let child of childBox.el) {
        if (child.parentElement != null || child.parentElement != undefined) {
          child.parentElement.removeChild(child);
        }
      }
    
      return this;
    };
  }


  jQuery를 생성하고 그 안에서 사용할 수 있는 함수를 정의

</pre>
<br>
<hr>
<br>
<h1>2022-12-21</h1>
<br>
<br>
<pre>
<strong>CSS다루는법</strong>
1. HTML에 style 태그로 입력해주는 방법
2. css파일에 설정후 HTML에 link 태그로 연결시켜주는 방법 
3. 부트스트랩에서 스타일을 가져와 활용한다 
4. jQuery에서 css와 jquery메소드를 가져와서 적용




*CDN 방식으로 라이브러리 파일 지정

방법
1. 브라우저에서 서버1로 요청을 하면 1.html을 받아 cache에 일시적으로 저장한다
2. google에 요청하면 jquery.js를 받아 동일하게 저장
3. 서버2로 요청하여 2.html 을 동일하게 저장


장점
위 과정에서 동일한 파일이 있을 경우 다시 저장하지 않아 페이지 로딩 시간이 단축된다   

단점
의존 라이브러리가 외부에 있어 통제가 불가능하여 해킹방지 코드 삽입 할수 없다 그리고
서버가 다운 되었을때 대비가 부족하다 그렇기 때문에 정부기관이나 금융기업들은 CDN방식
사용하지 않는다 



*외부 라이브러리 관리 

방법
웹페이지 루트 폴더로 접근해서 
npm init
npm install 라이브러리 --save 등록
npm install 라이브러리-ui --save

npm install bootstrap@5.2.3 --save


각 서버마다 html과 관련된 jquery파일을 같이 보관한다 만약 브라우저에서 요청을 하면
이미 있는 파일 이라해도 서버마다 파일을 따로 받아 저장


장점
관리와 보안을 쉽게할 수 있다

단점
네트워크 오버헤드발생 




<!-- 
  <script>
    // 최근 방식: recommanded
  $(() => {
    console.log("ready 호출됨11");
  });

    // 예전 방식: deprecated
  $(document).ready(() => {
    console.log("ready 호출됨22");
  });

  $(() => {
    console.log("ready 호출됨33");
  });

  window.onload = function() {
    console.log("load 이벤트 발생");
  };

  
  // ready()와 onload로 등록한 함수는 jquery의 버전에 따라 실행 순서가 다르다
  // 따라서 한가지 방법을 사용하는것을 추천한다
  // 또한 요즘은 script를 아래 두는 방식을 많이 쓴다 이렇게 쓰면 문제가 발생하지 않는다

</script>
</head>
<body>
<h1>load 이벤트- $(document).ready()</h1>

<script>
  console.log("11111");
</script>

<script src="exam08.js"></script>

<script>
  console.log("2222");
</script> 
-->

</pre>
<br>
<br>
<strong>*해커톤</strong>
주제: 공공데이터를 이용한 웹서비스 개발
기간: 2022-12-21 16:30 ~ 2022-12-22 16:00 
발표: 2022-12-22-16:00~18:00
발표내용: 프로젝트 소개 및 시연

</section>
</main>
</div>
<footer id="footer">

<li><small><a href="https://github.com/96abab/test.io.git">96abab.GitHub.com - test.io</a></small></li>
</footer>
</body>
</html>
